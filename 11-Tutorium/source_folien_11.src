\InputIfFileExists{../global.src}\relax\relax

\iffull
\def\smlll{\texorpdfstring{\def\RSsmallest{2pt}\smaller[2]}{}}
\title[Elftes Tutorium -- Übungsblatt 11]{Einfache Kreise und Inversion\\\small Tutorium 11}
\date{\sffamily KW 5}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{11}
\fi


\section{Präsenzaufgabe}
\begin{frame}[c]{Präsenzaufgabe}
    \onslide<2->{\begin{aufgabe}{Nächste Ausfahrt links}
        \onslide<3->{Geben Sie die Adjazenzliste für den Graphen links an und zeichnen Sie den Graphen für die Adjazenzmatrix rechts.}
        \vspace*{-.5\baselineskip}\begin{center}
            \onslide<4->{\scalebox{.75}{\begin{tikzpicture}[scale=1.325,align-half-base]
                \node[dot] (1) at (0,0) {1};
                \node[dot] (2) at (3,0) {2};
                \node[dot] (0) at (0,-3) {0};
                \node[dot] (3) at (3,-3) {3};
                \node[dot] (5) at (.85,-.85) {5};
                \node[dot] (6) at (2.15,-.85) {6};
                \node[dot] (4) at (.85,-2.15) {4};
                \node[dot] (7) at (2.15,-2.15) {7};

                \graph[edges={-Kite}] {(1) -> (2) -> (3) -> (0) -> (1) -> (5) -> (6) -> (7) -> (4) -> (5), (4) -> (0), (3) -> (7), (6) -> (2)};
            \end{tikzpicture}}}\hskip2.5cm\onslide<5->{\(
    \begin{pmatrix}
        0 & 3 & 0 & 0 & 6 \\
        3 & 0 & 5 & 0 & 7 \\
        0 & 5 & 0 & 1 & 9 \\
        4 & 0 & 1 & 0 & 2 \\
        6 & 7 & 9 & 2 & 0 \\
    \end{pmatrix}
            \)}\vspace*{-.5\baselineskip}
        \end{center}
    \end{aufgabe}}
\end{frame}

\begin{frame}[c]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Zuerst eine Adjazenzliste:
    \end{itemize}
    \begin{center}
        \onslide<3->{\scalebox{.75}{\begin{tikzpicture}[scale=1.325,align-half-base]
            \node[dot] (1) at (0,0) {1};
            \node[dot] (2) at (3,0) {2};
            \node[dot] (0) at (0,-3) {0};
            \node[dot] (3) at (3,-3) {3};
            \node[dot] (5) at (.85,-.85) {5};
            \node[dot] (6) at (2.15,-.85) {6};
            \node[dot] (4) at (.85,-2.15) {4};
            \node[dot] (7) at (2.15,-2.15) {7};

            \graph[edges={-Kite}] {(1) -> (2) -> (3) -> (0) -> (1) -> (5) -> (6) -> (7) -> (4) -> (5), (4) -> (0), (3) -> (7), (6) -> (2)};
        \end{tikzpicture}}}\hskip2cm\begin{minipage}{.2\linewidth}
    \small\begin{enumerate}[<+(1)->]
            \item<4->[0]  \(\!\to 1\)
            \item<5->[1]  \(\!\to 2 \to 5\)
            \item<6->[2]  \(\!\to 3\)
            \item<7->[3]  \(\!\to 7 \to 0\)
            \item<8->[4]  \(\!\to 5 \to 0\)
            \item<9->[5]  \(\!\to 6\)
            \item<10->[6] \(\!\to 2 \to 7\)
            \item<11->[7] \(\!\to 4\)
        \end{enumerate}
    \end{minipage}
    \end{center}
\end{frame}

{\def\g<#1>#2{{\only<-3|handout:0>{\text{\phantom{\bfseries#2}}}\only<4->{\color{gray}\text{\only<#1|handout:0>{\color{paletteA}\bfseries}#2}}}}
\MakeThePinguExplainIt[text width=3.77cm]{cap=!hide,glasses=!hide,halo,halo raise=2mm,devil horns,right item angle=5,cup=!hide,bow tie}{Natürlich~können~die\\Kanten~in~die~andere\\~Richtung~auch~ein~ande-\\res~Gewicht~aufweisen.}
\begin{frame}[c]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Nun mit der Adjazenzmatrix (Kanten wie \tikz[align-half-base]{\draw[Kite-Kite] (0,0) -- (1,0);} können auch\\ungerichtet dargestellt werden):
    \end{itemize}
    \begin{center}
        \onslide<3->{\(
            \bordermatrix{~ & \g<0>1 & \g<0>2 & \g<0>3 & \g<0>4 & \g<0>5 \cr
        \g<5>1 & 0 & 3 & 0 & 0 & 6 \cr
        \g<6>2 & 3 & 0 & 5 & 0 & 7 \cr
        \g<7>3 & 0 & 5 & 0 & 1 & 9 \cr
        \g<8>4 & 4 & 0 & 1 & 0 & 2 \cr
        \g<9>5 & 6 & 7 & 9 & 2 & 0 \cr
        }
    \)}\hskip2cm\onslide<4->{\begin{tikzpicture}[align-half-base,scale=1.5]
        \node[dot] (1) at (0,0) {1};
        \node[dot] (2) at (1.5,1) {2};
        \node[dot] (3) at (3,0) {3};
        \node[dot] (4) at (0,-1.5) {4};
        \node[dot] (5) at (3,-1.5) {5};
        \onslide<5->{%
            \colorlet{g}{black}\only<6|handout:0>{\colorlet{g}{gray}}\only<7-|handout:0>{\colorlet{g}{lightgray}}
            \only<-5|handout:0>{\draw[-Kite,g] (1) to[bend left=10,edge node={node[above,sloped]{3}}] (2);}
            \only<-8|handout:0>{\draw[-Kite,g] (1) to[bend right=20,edge node={node[above,sloped]{6}}] (5);}
        }
        \onslide<6->{
            \colorlet{g}{black}\only<7|handout:0>{\colorlet{g}{gray}}\only<8-|handout:0>{\colorlet{g}{lightgray}}
            \draw[Kite-Kite,g] (2) to[bend right=10,edge node={node[above,sloped]{3}}] (1);
            \only<-6|handout:0>{\draw[-Kite,g] (2) to[bend left=10,edge node={node[above,sloped]{5}}] (3);}
            \only<-8|handout:0>{\draw[-Kite,g] (2) to[bend right=20,edge node={node[below,sloped]{7}}] (5);}
        }
        \onslide<7->{
            \colorlet{g}{black}\only<8|handout:0>{\colorlet{g}{gray}}\only<9-|handout:0>{\colorlet{g}{lightgray}}
            \draw[Kite-Kite,g] (3) to[bend right=10,edge node={node[above,sloped]{5}}] (2);
            \only<-7|handout:0>{\draw[-Kite,g] (3) to[bend right=20,edge node={node[above,sloped]{1}}] (4);}
            \only<-8|handout:0>{\draw[-Kite,g] (3) to[bend left=10,edge node={node[right]{9}}] (5);}
        }
        \onslide<8->{
            \colorlet{g}{black}\only<9|handout:0>{\colorlet{g}{gray}}%\only<10->{\colorlet{g}{lightgray}}
            \draw[-Kite,g] (4) to[bend left=20,edge node={node[left]{4}}] (1);
            \draw[Kite-Kite,g] (4) to[bend left=20,edge node={node[above,sloped]{1}}] (3);
            \only<-8|handout:0>{\draw[-Kite,g] (4) to[bend right=10,edge node={node[below,sloped]{2}}] (5);}
        }
        \onslide<9->{
            \draw[Kite-Kite] (5) to[bend left=20,edge node={node[above,sloped]{6}}] (1);
            \draw[Kite-Kite] (5) to[bend left=20,edge node={node[below,sloped]{7}}] (2);
            \draw[Kite-Kite] (5) to[bend right=10,edge node={node[right]{9}}] (3);
            \draw[Kite-Kite] (5) to[bend left=10,edge node={node[below,sloped]{2}}] (4);
        }
    \end{tikzpicture}}\vspace*{-2\baselineskip}
    \end{center}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[left=-18mm,scale=.8] at(current page.{5.25}) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}}

\section{Übungsblatt 11}
\subsection{Aufgabe 1}
\iffull
\begin{frame}[c]{Übungsblatt 11 - Aufgabe 1}
    \scriptsize \onslide<2->{In dieser Aufgabe sollen Sie ein Programm schreiben, welches arithmetische Ausdrücke mit der umgekehrten polnischen Notation abarbeiten kann. Dabei handelt es sich um eine Schreibweise, bei der die Operatoren hinter den Operanden stehen, und nicht dazwischen wie bei der üblichen Infixnotation.
    Der arithmetische Ausdruck $(2 + 5) \times (4 - 1)$ lässt sich mit der UPN folgendermaßen darstellen:
    \T{2 5 + 4 1 - $\times$}
    Mit Hilfe dieser Notation lassen sich arithmetische Ausdrücke stapelweise abarbeiten.
    Um dies in der Praxis umzusetzen, sollen Sie folgendermaßen vorgehen:}

    \begin{enumerate}
    \item<3-> Zuerst sollen Sie einen Stack implementieren, welcher nach dem \T{LIFO}-Prinzip arbeitet (\say{last in first out}). In dieser Aufgabe soll dieser Stack Integer Werte verwalten. Hierfür benötigen Sie neben einem Konstruktor die folgenden Methoden:
        \begin{itemize}
            \item \tiny Die Methode \bjava{public void push(int value)} soll den übergebenen Wert oben auf dem Stack platzieren.
            \item \tiny Die Methode \bjava{public int pop()} soll den obersten Wert auf dem Stack entfernen und zurückgeben. Beachten Sie, dass der Stack unter Umständen leer sein kann. Werfen Sie in diesem Fall eine Exception.
        \end{itemize}
    Verwenden Sie für Ihre Implementierung keine Arrays oder vorgefertigten dynamischen Datenstrukturen, sondern implementieren Sie den Stack selbst als (einfach) verkettete Liste.
    \item<4-> Erweitern Sie ihre Stack-Implementierung nun um die folgenden Methoden:
        \begin{itemize}
            \item \tiny Die Methode \bjava{public void add()} soll die obersten zwei Elemente auf dem Stack addieren und das Ergebnis auf den Stack pushen.
            \item \tiny Die Methode \bjava{public void subtract()} soll das oberste Element vom darauffolgenden Element subtrahieren und das Ergebnis auf den Stack pushen.
            \item \tiny Die Methode \bjava{public void multiply()} soll die obersten zwei Elemente auf dem Stack multiplizieren und das Ergebnis auf den Stack pushen.
        \end{itemize}
        Beachten Sie bei diesen Methoden den Fall, dass eventuell weniger als zwei Elemente auf dem Stack vorhanden sein könnten.
    \end{enumerate}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 11 - Aufgabe 1a)\hfill Stack}
    \SetupLstHl\lstfs{10}\begin{itemize}[<+(1)->]
        \item Unser Stack baut sich erstmal ganz analog zur Queue von letzter Woche (\only<2->{\textattachfile{\curpath RPNStack.java}{RPNStack.java}}).
\begin{onlyenv}<3-5|handout:0>
\begin{plainjava}
public class Queue {
    class Element {
        public final int value;
        public Element next = null;
        public Element(int value) { this.value = value; }
    }
    private Element first;
    private Element last;
    private int length;
}
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<6->
\begin{plainjava}[morekeywords={[3]{RPNStack}}]
public class RPNStack {
    class Element {
        public final int value;
        public Element next = null;
        public Element(int value) { this.value = value; }
    }
    private Element first;
    // private Element last;
    private int length;
}
\end{plainjava}
\end{onlyenv}
    \item<4-> Allerdings nehmen wir bei einem Stack die Elemente nur von einer Seite.
    \item<5-> Wir sparen uns also \bjava{last} und nennen die Klasse nun \solGet{keywordC}{RPNStack}.
    \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 1a)\hfill Stack push}
    \SetupLstHl\lstfs{10}\begin{itemize}[<+(1)->]
        \item Anstelle von \bjava{enqueue} und \bjava{dequeue} nun \bjava{push} und \bjava{pop}:
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{RPNStack}}]
!*\onslide<3->*!|ihl|public class RPNStack {|ihl|
!*\onslide<4->*!    |ihl|class Element { final int value; Element next = null; }|ihl|
!*\onslide<4->*!    |ihl|private Element first;|ihl|
!*\onslide<4->*!    |ihl|private int length;|ihl|
!*\onslide<5->*!    public void push(int value) {
!*\onslide<6->*!        Element top = new Element(value);
!*\onslide<7->*!        top.next = this.first;
!*\onslide<7->*!        this.first = top;
!*\onslide<8->*!        this.length++;
!*\onslide<5->*!    }
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 1a)\hfill Stack pop}
    \SetupLstHl\lstfs{10}
\begin{plainjava}[morekeywords={[3]{RPNStack}}]
!*\onslide<2->*!|ihl|public class RPNStack {|ihl|
!*\onslide<2->*!    |ihl|class Element { final int value; Element next = null; }|ihl|
!*\onslide<2->*!    |ihl|private Element first;|ihl|
!*\onslide<2->*!    |ihl|private int length;|ihl|
!*\onslide<3->*!    |ihl|public void push(int value) { :ldots: }|ihl|
!*\onslide<2->*!
!*\onslide<4->*!    public int pop() {
!*\onslide<5->*!        if(this.length == 0) throw new NoSuchElementException();
!*\onslide<6->*!        int value = this.first.value;
!*\onslide<6->*!        this.first = this.first.next;
!*\onslide<7->*!        this.length--;
!*\onslide<8->*!        return value;
!*\onslide<4->*!    }
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\MakeThePinguExplainIt[text width=6.77cm]{cap=!hide,glasses=!hide,halo,halo raise=2mm,devil horns,right item angle=-48,cup=!hide,bow tie}{Aufgabe für die \#coolenKids\texttrademark\ Wie kann man das mit Lambdas/Methoden Referenzen noch mehr \#exciting machen?}
\begin{frame}[t,fragile]{Übungsblatt 11 - Aufgabe 1b)}
    \SetupLstHl\lstfs{10}\begin{itemize}[<+(1)->]
        \item Wir können für jede Operation eine Methode wie folgt implementieren:
\begin{plainjava}[morekeywords={[3]{RPNStack}}]
!*\onslide<3->*!public void subtract() {
!*\onslide<4->*!    if(this.length < 2) throw new NoSuchElementException();!*\onslide<7->*! // Nötig? :yields: Nö
!*\onslide<5->*!    int a = this.pop();
!*\onslide<5->*!    int b = this.pop();
!*\onslide<6->*!    this.push(b - a);!*\onslide<7->*! // this.push(-this.pop() + this.pop())
!*\onslide<3->*!}
\end{plainjava}
        \item<8-> Aber wo wäre da der Spaß? Wir wollen eine Enumeration! \info{Als Übung. Natürlich.}
\begin{plainjava}[morekeywords={[3]{RPNStack, BinaryOperation}}]
!*\onslide<9->*!|ihl|public class RPNStack {|ihl|
!*\onslide<9->*!    |ihl|class Element { final int value; Element next = null; }|ihl|
!*\onslide<9->*!    |ihl|:ldots:|ihl|
!*\onslide<10->*!   private enum BinaryOperation {
!*\onslide<11->*!      ADD, SUB, MUL
!*\onslide<10->*!   }
!*\onslide<9->*!|ihl|}|ihl|
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<12->{\node[left=-10mm,scale=.8] at(current page.{-25.25}) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 1b)\hfill BinaryOperation}
    \SetupLstHl\lstfs{9}\vspace*{-.45\baselineskip}
\begin{plainjava}[morekeywords={[3]{RPNStack, BinaryOperation}}]
!*\onslide<2->*!|ihl|public class RPNStack {|ihl|
!*\onslide<2->*!    |ihl|:ldots:|ihl|
!*\onslide<2->*!    |ihl|public void push(int value) { :ldots: }|ihl|
!*\onslide<2->*!    |ihl|public int pop() throws NoSuchElementException { :ldots: }|ihl|
!*\onslide<2->*!    |ihl|private enum BinaryOperation { ADD, SUB, MUL }|ihl|
!*\onslide<3->*!    private void performBinaryOperation(BinaryOperation operation) {
!*\onslide<4->*!        if(this.length < 2) throw new NoSuchElementException();!*\onslide<13->*! // Nötig? :yields: Nopsie
!*\onslide<5->*!        int a = this.pop();
!*\onslide<5->*!        int b = this.pop();
!*\onslide<6->*!        switch(operation) {
!*\onslide<7->*!            case ADD: this.push(a + b); break;
!*\onslide<8->*!            case SUB: this.push(b - a); break;
!*\onslide<9->*!            case MUL: this.push(a * b); break;
!*\onslide<6->*!        }
!*\onslide<3->*!    }
!*\onslide<10->*!    public void add() { this.performBinaryOperation(BinaryOperation.ADD); }
!*\onslide<11->*!    public void subtract() { this.performBinaryOperation(BinaryOperation.SUB); }
!*\onslide<12->*!    public void multiply() { this.performBinaryOperation(BinaryOperation.MUL); }
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\subsection{Aufgabe 2}
\iffull
\begin{frame}[c]{Übungsblatt 11 - Aufgabe 2}
    \scriptsize\onslide<2->{In dieser Aufgabe sollen Sie einen \say{Ringbuffer} implementieren. Hierbei handelt es sich um eine dynamische Datenstruktur ähnlich zu einer Queue, jedoch verweist hier das letzte Element der Queue wieder auf das Erste. Zusätzlich hat ein Ringbuffer eine fest vorgegebene Kapazität. Solch eine Datenstruktur findet zum Beispiel Anwendung in Szenarien wo es einen Produzenten gibt der Werte liefert, und einen Konsumenten, der diese Werte verarbeitet.
    Hierfür werden intern die zwei Zeiger \T{head} und \T{tail} verwendet. Alle Positionen bis zum \T{tail} Zeiger sind beginnend beim \T{head} Zeiger belegt. Falls die zwei Zeiger auf das selbe Element verweisen, so ist der Ringbuffer entweder komplett gefüllt oder aber komplett leer ist. Um diese zwei Fälle zu unterscheiden, benötigt man eine zusätzliche Zustandsvariable.}

    \onslide<3->{Um den Ringbuffer zu implementieren, definieren Sie sich zunächst einen Konstruktor, welcher die Kapazität des Ringbuffers als Parameter übernimmt und die Datenstruktur anlegt.
    Implementieren Sie basierend darauf nun die folgenden zwei Methoden:
    \begin{itemize}
        \item Die Methode \bjava{public void addValue(int value)} soll den übergebenen Wert an der Position im Ringbuffer speichern, auf die der Zeiger \T{tail} zeigt.
        Sollte der Buffer komplett gefüllt sein, soll eine \bjava{BufferOverflowException} geworfen werden.
        \item Die Methode \bjava{public int getValue()} soll den Wert an der Position zurückliefern, auf die der Zeiger \T{head} zeigt. Sollte der Buffer leer sein, soll eine \bjava{NoSuchElementException} geworfen werden.
    \end{itemize}}

    \onslide<4->{Verwenden Sie für ihre Implementierung keine Arrays oder vorgefertigten dynamischen Datenstrukturen, sondern implementieren Sie den Ringbuffer selbst als (einfach) verkettete Liste.}
\end{frame}
\fi

\begin{frame}[c]{Übungsblatt 11 - Aufgabe 2}
    \begin{itemize}[<+(1)->]
        \item Von uns wird ein einfacher Ringbuffer verlangt. \begin{itemize}
            \item Idee: Eine veränderbare \bjava{Element}-Klasse.
            \item Wir generieren einen Kreis mit gegebener Kapazität.
            \item Wir rotieren mit \bjava{head}.
        \end{itemize}
    \end{itemize}
    \medskip
\begin{center}
    \tikzset{dot/.append style={text width=1.65em}}\lstfs{8}\def\g{\solGet{numbers}{\color{gray}0}}%
    \onslide<6->{\bjava[morekeywords={[3]{RingBuffer}}]{rb = new RingBuffer(5)}}\onslide<7->{~\(\Longrightarrow\)~\scalebox{.65}{\begin{tikzpicture}[align-half-base,scale=1.4]
        \foreach[count=\i,remember=\i as \li (initially 0)] \a in {\g,\g,\g,\g,\g} {
            \node[dot] (\i) at ({(\i-1)*360/5+90}:1.125cm) {\lstfs{10}\a};
            \ifnum\i>1
                \draw[-Kite] (\i) to[bend left=16] (\li);
            \fi
        }
        \node[align=center] at (0,0) {\bjava{isFull =}\\\bjava{false}};
        \draw[-Kite] (1) to[bend left=16] (5);

        \draw[Kite-] (1.110) -- ++(-.25,.35) node[above] {\T{head}};
        \draw[Kite-] (1.70) -- ++(.25,.35) node[above] {\T{tail}};
    \end{tikzpicture}}}\onslide<8->{~\(\Longrightarrow\)~\bjava[morekeywords={[3]{RingBuffer}}]{rb.addValue(12)}}\onslide<9->{~\(\Longrightarrow\)~\scalebox{.65}{\begin{tikzpicture}[align-half-base,scale=1.4]
        \foreach[count=\i,remember=\i as \li (initially 0)] \a in {\bjava{12},\g,\g,\g,\g} {
            \node[dot] (\i) at ({(\i-1)*360/5+90}:1.125cm) {\lstfs{10}\a};
            \ifnum\i>1
                \draw[-Kite] (\i) to[bend left=16] (\li);
            \fi
        }
        \node[align=center] at (0,0) {\bjava{isFull =}\\\bjava{false}};

        \draw[-Kite] (1) to[bend left=16] (5);

        \draw[Kite-] (1.90) -- ++(0,.35) node[above] {\T{head}};
        \draw[Kite-] (5.90) -- ++(0,.35) node[above] {\T{tail}};
    \end{tikzpicture}}}
\end{center}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 2\hfill Grundkonstrukt}
    \SetupLstHl\lstfs{10}\begin{itemize}[<+(1)->]
        \item Wir beginnen wieder mit der Queue-Idee (\only<2->{\textattachfile{\curpath RingBuffer.java}{RingBuffer.java}}).
\begin{onlyenv}<3-6|handout:0>
\begin{plainjava}
public class Queue {
    class Element {
        public final int value;
        public Element next = null;
        public Element(int value) { this.value = value; }
    }
    private Element first;
    private Element last;
    private int length;
}
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<7->
\begin{plainjava}[morekeywords={[3]{RingBuffer}}]
public class RingBuffer {
    class Element {
        public /* final */ int value; // Jetzt veränderbar
        public Element next = null;
        public Element(int value) { this.value = value; }
    }
    private Element head;
    private Element tail;
    private boolean isFull;
}
\end{plainjava}
\end{onlyenv}
    \item<4-> Hier heißen Start und Ende eben \bjava{head} und \bjava{tail}.
    \item<5-> Weiter soll \bjava{Element} veränderbar sein.
    \item<6-> Anstelle der Länge speichern wir zunächst einfach mal, ob der Buffer voll ist.
    \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 2\hfill Grundkonstruktor}
    \SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Der Konstruktor übernimmt hier die Arbeit, eine \say{leere} Ringliste zu konstruieren.
        \item Der naive Ansatz:
    \end{itemize}
\begin{plainjava}
!*\onslide<4->*!|ihl|public class RingBuffer {|ihl|
!*\onslide<4->*!    |ihl|class Element { int value; Element next = null; }|ihl|
!*\onslide<4->*!    |ihl|private Element head, tail;|ihl|
!*\onslide<4->*!    |ihl|private boolean isFull;|ihl|
!*\onslide<5->*!    public RingBuffer(int capacity) {
!*\onslide<6->*!        this.isFull = capacity <= 0;
!*\onslide<6->*!        if(this.isFull) return;
!*\onslide<4->*!
!*\onslide<7->*!        Element current = new Element(0); // Magic-Number-Standard
!*\onslide<7->*!        this.head = this.tail = current;
!*\onslide<4->*!
!*\onslide<8->*!        // TODO: füllen
!*\onslide<5->*!    }
!*\onslide<4->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 2\hfill Grundkonstruktor, II}
\SetupLstHl\lstfs{9}\begin{plainjava}
!*\onslide<2->*!|ihl|public class RingBuffer {|ihl|
!*\onslide<2->*!    |ihl|class Element { int value; Element next = null; }|ihl|
!*\onslide<2->*!    |ihl|private Element head, tail;|ihl|
!*\onslide<2->*!    |ihl|private boolean isFull;|ihl|
!*\onslide<3->*!    public RingBuffer(int capacity) {
!*\onslide<4->*!        // ..
!*\onslide<4->*!        |ihl|Element current;|ihl|
!*\onslide<2->*!
!*\onslide<5->*!        for(int i = 1; i < capacity; i++) {
!*\onslide<6->*!            Element next = new Element(0);
!*\onslide<6->*!            current.next = next;
!*\onslide<2->*!
!*\onslide<7->*!            if(i == capacity - 1) !*\onslide<8->*!// Verbindung des letztes Elementes
!*\onslide<7->*!                next.next = this.head;
!*\onslide<2->*!
!*\onslide<9->*!            current = next;
!*\onslide<5->*!        }
!*\onslide<3->*!    }
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\MakeThePinguExplainIt[text width=10.65cm]{cap=!hide,glasses=!hide,cloak=pingu@black,right item angle=-6,cup=!hide}{\bjava{Objects.equals(tail, head)} wäre keine gute Idee. Es funktioniert aus zwei Gründen: 1)~\bjava{Objects::equals} handhabt ein \bjava{tail = null}, welches aber nur bei \bjava{capacity = 0} auftritt (es ist ja sonst ein \say{Ring}) und 2) wir haben es nicht für \bjava{Element} implementiert. Die Standardimplementation ist einfach mit \bjava{==}. Dennoch: Wir wollen hier die Identität und \textit{nicht} die Gleichheit prüfen. Das ist ein Fall, in dem \bjava{==} viel besser ist.}
\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 2\hfill Pump It}
\SetupLstHl\lstfs{9}\begin{plainjava}
!*\onslide<2->*!|ihl|public class RingBuffer {|ihl|
!*\onslide<2->*!    |ihl|class Element { int value; Element next = null; }|ihl|
!*\onslide<2->*!    |ihl|private Element head, tail;|ihl|
!*\onslide<2->*!    |ihl|private boolean isFull;|ihl|
!*\onslide<3->*!    |ihl|public RingBuffer(int capacity) { :ldots: }|ihl|

!*\onslide<4->*!    public void addValue(int value) {
!*\onslide<5->*!        if ((this.head == this.tail) && this.isFull) // sind wir wirklich voll?
!*\onslide<5->*!            throw new BufferOverflowException(); // java.nio!
!*\onslide<3->*!
!*\onslide<6->*!        this.tail.value = value;
!*\onslide<6->*!        this.tail = this.tail.next;
!*\onslide<3->*!
!*\onslide<9->*!        // was wäre mit equals?
!*\onslide<7->*!        if (this.tail == this.head)
!*\onslide<8->*!            this.isFull = true;
!*\onslide<4->*!    }
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[left=-21mm,scale=.8] at(current page.{-23.25}) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Aufgabe 2\hfill Take It}
\SetupLstHl\lstfs{9}\begin{plainjava}
!*\onslide<2->*!|ihl|public class RingBuffer {|ihl|
!*\onslide<2->*!    |ihl|class Element { int value; Element next = null; }|ihl|
!*\onslide<2->*!    |ihl|private Element head, tail;|ihl|
!*\onslide<2->*!    |ihl|private boolean isFull;|ihl|
!*\onslide<2->*!    |ihl|public RingBuffer(int capacity) { :ldots: }|ihl|
!*\onslide<3->*!    |ihl|public void addValue(int value) { :ldots: }|ihl|
!*\onslide<4->*!    public int getValue() {
!*\onslide<4->*!        if ((this.head == this.tail) && !this.isFull) // sind wir leer?
!*\onslide<4->*!           throw new NoSuchElementException();
!*\onslide<4->*!
!*\onslide<4->*!        this.isFull = false;
!*\onslide<4->*!        int value = this.head.value;
!*\onslide<4->*!        this.head = this.head.next; // Nicht direkt gefordert, aber logisch :D
!*\onslide<4->*!
!*\onslide<4->*!        return value;
!*\onslide<4->*!    }
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\begin{frame}[c]{Übungsblatt 11 - Aufgabe 2\hfill Thats It}
\begin{itemize}[<+(1)->]
    \itemsep6pt
    \item Ein paar Ideen, die das Ganze interessanter machen.
    \item Anstelle einfach \bjava{this.tail.value = value} zu setzen, kann man probieren immer neue \bjava{Element}-Objekte zu erzeugen und einzufügen und wieder zu entfernen.
    \item Erlauben, dass die Kapazität auch nach der Erstellung verändert werden kann (vergrößern und verkleinern).
    \item Wenn der Ringbuffer voll ist, soll das älteste \bjava{Element} durch das neue ersetzt werden.
\end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 5/6}
\iffull
\begin{frame}[c]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Shake It}
    \onslide<2->{In dieser Aufgabe sollen Sie noch einmal einen Sortieralgorithmus selbst implementieren.
    Dieses Mal handelt es sich um den (Cocktail) Shaker Sort, welcher eine Variation des Bubblesort Algorithmus darstellt.
    Hierbei wird das Array in jedem Sortierschritt alternierend von vorne und hinten durchlaufen, wobei die bereits sortieren Elemente vorne und hinten nicht mehr betrachtet werden.
    Auch diesen Algorithmus sollen Sie wieder rekursiv implementieren.
    Wenn Sie nicht wissen wie Sie beginnen sollen, versuchen Sie den Algorithmus zuerst iterativ zu implementieren und wandeln Sie anschließend die Schleifen in rekursive Methodenaufrufe um.
    Auch bei dieser Aufgaben soll ihre fertige Implementierung des Algorithmus keine Schleifen und keine vorgefertigten Sortierfunktion (wie z.B. \bjava{Arrays.sort()}) enthalten.}
\end{frame}
\fi

\begin{frame}[c,fragile]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Bubblesort}
\lstfs{8}\begin{columns}[c,onlytextwidth]
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<2->*!static void bubbleSort(int[] arr) {
!*\onslide<2->*!    for (int n = arr.length; n > 1; n--) {
!*\onslide<2->*!        for (int i = 0; i < n - 1; i++) {
!*\onslide<2->*!            if (arr[i] > arr[i + 1])
!*\onslide<2->*!                swap(arr, i, i + 1);
!*\onslide<2->*!        }
!*\onslide<2->*!    }
!*\onslide<2->*!}
\end{plainjava}
\column{.5\linewidth}
\begin{plainjava}
!*\onslide<3->*!static void bubbleSort(int[] arr, int n) {
!*\onslide<3->*!    if (n > 1) {
!*\onslide<3->*!        move(arr, 0, n);
!*\onslide<3->*!        bubbleSort(arr, n - 1);
!*\onslide<3->*!    }
!*\onslide<3->*!}

!*\onslide<3->*!static void move(int[] arr, int i, int n) {
!*\onslide<3->*!    if (i < n - 1) {
!*\onslide<3->*!        if (arr[i] > arr[i + 1])
!*\onslide<3->*!            swap(arr, i, i + 1);
!*\onslide<3->*!        move(arr, i + 1, n);
!*\onslide<3->*!    }
!*\onslide<3->*!}
\end{plainjava}
\end{columns}\medskip
\begin{center}
\onslide<4->{Show me the moves (\only<4->{\textattachfile{\curpath ShakerSort.java}{ShakerSort.java}})}
\end{center}
\end{frame}

\newsavebox\movecodebox
\savebox\movecodebox{\lstfs{9}\begin{minipage}{8cm}
\begin{plainjava}^^J
static void move(int[] arr, int i, int n) \{^^J
:ws::ws:if (i < n - 1) \{^^J
:ws::ws::ws::ws:if (arr[i] > arr[i + 1])^^J
:ws::ws::ws::ws::ws::ws:swap(arr, i, i + 1);^^J
:ws::ws::ws::ws:move(arr, i + 1, n);^^J
:ws::ws:\}^^J
\}^^J
\end{plainjava}
\end{minipage}}
\begin{frame}[c,fragile]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Ein Blick auf move}
\lstfs{10}\begin{plainjava}
!*\onslide<3->*!static void moveUp(int[] array, int index, int end) {
!*\onslide<4->*!    if (index < end) { // Exemplarisch mit dem unteren
!*\onslide<5->*!        if (array[index] < array[index - 1])
!*\onslide<5->*!            swap(array, index, index - 1);
!*\onslide<6->*!        return moveUp(array, index + 1, end);
!*\onslide<4->*!    }
!*\onslide<3->*!}
!*\onslide<3->*!
!*\onslide<7->*!static void moveDown(int[] array, int index, int end) {
!*\onslide<8->*!    if (index > end) {
!*\onslide<9->*!        if (array[index] < array[index - 1])
!*\onslide<9->*!            swap(array, index, index - 1);
!*\onslide<10->*!        return moveDown(array, index - 1, end);
!*\onslide<8->*!    }
!*\onslide<7->*!}!*\onslide<1->*!
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<2->{\node[above left,scale=.65,yshift=.75cm] at(current page.south east) {\usebox\movecodebox};}
\end{tikzpicture}%
\end{frame}

\savebox\movecodebox{\lstfs{9}\begin{minipage}{8cm}
\begin{plainjava}^^J
static void bubbleSort(int[] arr, int n) \{^^J
:ws::ws:if (n > 1) \{^^J
:ws::ws::ws::ws:move(arr, 0, n);^^J
:ws::ws::ws::ws:bubbleSort(arr, n - 1);^^J
:ws::ws:\}^^J
\}^^J
\end{plainjava}
\end{minipage}}
\begin{frame}[c,fragile]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Ping Pong}
\begin{plainjava}
!*\onslide<3->*!static void shakerSort(int[] array, int n) {
!*\onslide<4->*!    int offset = array.length - n;
!*\onslide<5->*!    if (n > array.length / 2) { // perförmänce büüst
!*\onslide<6->*!        moveUp(array, offset + 1, n);
!*\onslide<6->*!        moveDown(array, n - 1, offset);
!*\onslide<3->*!
!*\onslide<7->*!        shakerSort(array, n - 1);
!*\onslide<5->*!    }
!*\onslide<3->*!}!*\onslide<1->*!
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<2->{\node[above left,scale=.65,yshift=.75cm] at(current page.south east) {\usebox\movecodebox};}
\end{tikzpicture}%
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Effizienter}
\SetupLstHl\lstfs{7}\begin{plainjava}
!*\onslide<2->*!|ihl|static|ihl| boolean |ihl|moveUp(int[] array, int index, int end,|ihl| boolean swapped|ihl|) {|ihl|
!*\onslide<2->*!    |ihl|if (index < end) {|ihl|
!*\onslide<2->*!        |ihl|if (array[index] < array[index - 1])|ihl| {
!*\onslide<2->*!            |ihl|swap(array, index, index - 1);|ihl|
!*\onslide<2->*!            swapped = true;
!*\onslide<2->*!        }
!*\onslide<2->*!        |ihl|return moveUp(array, index + 1, end,|ihl| swapped|ihl|);|ihl|
!*\onslide<2->*!    |ihl|}|ihl|
!*\onslide<2->*!    return swapped;
!*\onslide<2->*!|ihl|}|ihl|

!*\onslide<3->*!|ihl|static|ihl| boolean |ihl|moveDown(int[] array, int index, int end,|ihl| boolean swapped|ihl|) {|ihl|
!*\onslide<3->*!    |ihl|if (index > end) {|ihl|
!*\onslide<3->*!        |ihl|if (array[index] < array[index -1])|ihl| {
!*\onslide<3->*!            |ihl|swap(array, index, index - 1);|ihl|
!*\onslide<3->*!            swapped = true;
!*\onslide<3->*!        }
!*\onslide<3->*!        |ihl|return moveDown(array, index - 1, end,|ihl| swapped|ihl|);|ihl|
!*\onslide<3->*!    |ihl|}|ihl|
!*\onslide<3->*!    return swapped;
!*\onslide<3->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 11 - Zusatzaufgabe 5/6 \hfill Effizienter, II}
\SetupLstHl\lstfs{10}\begin{plainjava}
!*\onslide<2->*!|ihl|public static void shakerSort(int[] array, int n) {|ihl|
!*\onslide<2->*!    |ihl|int offset = array.length - n;|ihl|
!*\onslide<2->*!    |ihl|if (n > array.length / 2) {|ihl|
!*\onslide<2->*!        if(!|ihl|moveUp(array, offset + 1, n,|ihl| false|ihl|)|ihl|) return;
!*\onslide<2->*!        if(!|ihl|moveDown(array, n - 1, offset,|ihl| false|ihl|)|ihl|) return;
!*\onslide<2->*!
!*\onslide<2->*!        |ihl|shakerSort(array, n - 1);|ihl|
!*\onslide<2->*!    |ihl|}|ihl|
!*\onslide<2->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
\end{frame}

\section{Der End-Pengu}
\begin{frame}[c]
\pause\begin{center}
    \scalebox{1.75}{\begin{tikzpicture}
        \pingu[left wing wave, eyes wink, rook, hair 2=pingu@green,name=saphira,sign post left=Li(s)t!,lightsaber right,right item angle=80]% torch :C
    \end{tikzpicture}}
    \end{center}
\end{frame}


\iffull\end{document}\fi