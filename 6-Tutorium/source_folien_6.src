
\input ../global.src
\usepackage{lecture-personal-resize}
\pgfmathsetseed{\number\pdfrandomseed}

\title[Sechstes Tutorium -- Übungsblatt 6]{Tik-Tok Victoryyy\\\small Sieg auf ganzer Linie, 6}
\date{\sffamily KW 49}
\author{Florian Sihler}
\institute{Institute of Distributed Systems \(\circ\) University Ulm}

\usepackage[prefix=]{xcolor-material}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text}
\hypersetup{colorlinks=false}
\pingudefaults{lightsaber left outer glow factor=.05,lightsaber right outer glow factor=.05}

\begin{document}
\Titlepage{6}

\section{Präsenzaufgabe}
\begin{frame}[fragile]{Präsenzaufgabe}
    \begin{aufgabe}{Natürlich bin ich ein Teil von dir}
        \pause{}Implementieren Sie eine \bjava{Member}-Klasse für Mitglieder einer Bibliothek.
        Diese soll einen nicht-leeren Namen und Vornamen (veränderbar), sowie ein Geburtsdatum im Format \T{TT.MM.YYYY} (unveränderbar) verwalten.
\begin{enumerate}[<+(1)->]
    \item Definieren Sie die Klasse, inklusive aller notwendiger Attribute und mit sinnvollen Modifikatoren.\pause{} Fügen sie \textit{Getter}-Methoden so hinzu, dass die Objekte von außen nicht mehr geändert werden können.\pause{}\par
    {\footnotesize\textit{Hinweis:} Ein Datum kann mit der Klasse \bjava{SimpleDateFormat} geparsed werden.\pause{} Nutzen Sie \bjava{SimpleDateFormat::parse} und \bjava{SimpleDateFormat::format}, zur Konversion von \bjava{String} in \bjava{java.util.Date} und umgekehrt.\pause{} Übergeben Sie dem Konstruktor das Datumsformat als \bjava{\"dd.MM.yyyy\"}. Ein Datum kann durch \bjava{Date::clone} kopiert werden.\par}
\end{enumerate}\vspace*{-\medskipamount}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe}
    \begin{aufgabe}{Natürlich bin ich ein Teil von wir}
        \pause Implementieren Sie eine \bjava{Member}-Klasse mit nicht-leerem Namen und Vornamen, sowie ein Geburtsdatum im Format \T{TT.MM.YYYY}.
\begin{enumerate}[<+(1)->]
    \setcounter{enumi}{1}
    \item Implementieren Sie einen Konstruktor \bjava{Member(String, String, String)}, der alle Attribute übergeben bekommt \textit{und} überprüft. Wird auch nur eine Bedingung verletzt, soll eine \bjava{IllegalArgumentException} geworfen werden.\smallskip\pause{}\par
    {\footnotesize\textit{Hinweis:} \bjava{SimpleDateFormat::parse} wirft eine \bjava{java.text.ParseException}, wenn der String \textit{nicht} dem gewünschten Format entspricht.\par}
\end{enumerate}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe}
    \begin{aufgabe}{Natürlich bin ich ein Teil von mir}
        \pause Implementieren Sie eine \bjava{Member}-Klasse mit nicht-leerem Namen und Vornamen, sowie ein Geburtsdatum im Format \T{TT.MM.YYYY}.
\begin{enumerate}[<+(1)->]
    \setcounter{enumi}{2}
    \item Implementieren Sie eine Methode der Gestalt: \bjava{public boolean equals(Member other)}, welche das \bjava{Member}-Objekt mit \bjava{other} vergleicht.\pause{} Hat \bjava{other} den Wert \bjava{null}, so soll eine \bjava{NullPointerException} geworfen werden.
\end{enumerate}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe -- Übersicht}
    \begin{aufgabe}{Oh schau mal, da sind sie!}
        \bjava{Member}: nicht-leere Namen, Vornamen und Geburtsdatum (fest, \T{dd.MM.yyyy}).
\begin{enumerate}[<+(1)->]
    \item Attribute (samt Modifikatoren). \textit{Getter}, die Änderungen von außen verhindern.
    \item Konstruktor \bjava{Member(String, String, String)}, der Parameter \textit{auch} überprüft. Bei Fehler: \bjava{IllegalArgumentException}.\smallskip\pause{}\par
    {\footnotesize\textit{Hinweis:} \bjava{SimpleDateFormat::parse} wirft \bjava{java.text.ParseException}.\par}
    \item \bjava{public boolean equals(Member other)}, welches das \bjava{Member}-Objekt mit \bjava{other} vergleicht (\bjava{NullPointerException} wenn \bjava{other} \bjava{null} ist).
\end{enumerate}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Die ganze Freude befindet sich hier: \only<2->{\textattachfile{Member.java}{Member.java}}.
        \item Wir beginnen mit den bloßen Attributen:
\begin{plainjava}
!*\onslide<4->*!public class Member {
!*\onslide<5->*!    private String name;
!*\onslide<5->*!    private String surname;
!*\onslide<5->*!    private final Date birthday;
!*\onslide<4->*!}
\end{plainjava}
        \item<6-> Frage: was bedeutet das \bjava{final} bei \bjava{birthday}?\par\info{Es schützt nur die Variable \bjava{birthday} vor einer Neuzuweisung. Nicht eine Änderung der Werte \emph{in} dem zugewiesenen Datum. \onslide<7->{Übrigens: bei Strings schützt \bjava{final} jede Veränderung, obwohl es sich auch bei \bjava{String} um eine Klasse handelt. Dies liegt daran, dass Strings in Java \emph{immutable} sind. Bei jeder Veränderung wird ein neues String-Objekt erzeugt.}}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Nun die Getter:
\begin{plainjava}
!*\onslide<3->*!public String getName() { return this.name; }
!*\onslide<3->*!
!*\onslide<4->*!public String getSurname() { return this.surname; }
!*\onslide<3->*!
!*\onslide<5->*!public Date getBirthday() {
!*\onslide<6->*!    return (Date) this.birthday.clone();
!*\onslide<5->*!}
\end{plainjava}
        \item<7-> Have you ever heard the tragedy of Darth Clon\textbf{e}able the wise? \onslide<8->{Well, then prepare yourself for\ldots\ something at least.}
    \end{itemize}
\end{frame}

{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{1.5em}\centering
\begin{tikzpicture}
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{\pingu[eyes wink]}
    \only<3|handout:0>{\pingu[right wing grab, lightsaber right, lightsaber right disabled]}
    \only<4|handout:0>{\pingu[right wing grab, eyes angry, lightsaber right=purple]}
    \only<5|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple]}
    \only<6|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,right item angle=-70],bill angry}
    \only<7|handout:0>{\pingu[right wing wave, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70],bill angry}
    \only<8->{\pingu[right wing grab, eyes angry, lightsaber right=purple,lightsaber right double,right item angle=-70,bill angry,right item angle=-80,lightsaber right yshift=-.45mm]}
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Object}
    \begin{itemize}[<+(1)->]
        \item \bjava{Object} ist die Klasse, welche die grundlegenden Eigenschaften für jede andere Klassen zur Verfügung stellt.
        \item Wir werden sie später im Rahmen von Vererbung genauer kennen lernen.\par
            Bis da hin: \bjava{toString} stammt beispielsweise dort her.
        \item Diese Klasse \bjava{Object} liefert auch die Methode \bjava{clone}, die auf jedem Objekt aufgerufen werden kann\pause\ldots\pause{} \ldots\pause{} \ldots
        \item \bjava{clone} muss aber von jeder Klasse selbst und individuell implementiert werden, wenn es denn unterstützt werden soll.
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Kopien}
    \begin{itemize}[<+(1)->]
        \item Da die Variable eines Objekts in Java nur eine Referenz auf das eigentliche Objekt enthält, erzeugen wir durch den folgenden Code \emph{keine} Kopie:\pause{}
\begin{plainjava}
Scanner a = new Scanner(System.in);
Scanner b = a;
\end{plainjava}
        \item Oft stellen sich auch Fragen wie:
         \begin{itemize}
             \item Was soll kopiert werden?
             \item Funktioniert eine Kopie überhaupt?
             \item Was ist, wenn das zu kopierende Objekt selbst wieder (zum Beispiel in den Attributen) Referenzen auf andere Objekte enthält?
             \item Was, wenn diese Referenzen zirkulär sind?
         \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Kopien}
    \begin{itemize}[<+(1)->]
        \item Deswegen unterscheiden wir zwei Arten von Kopien: \emph{shallow} und \emph{deep}.\par
            \info{Genau genommen gibt es noch viel mehr, wie zum Beispiel \emph{lazy}, aber das soll uns hier nicht weiter stören.}
        \item Eine \emph{shallow copy} kopiert \say{so wenig wie möglich}. Oder auch nur \say{die erste Hierarchieebene.}
        \item Eine \emph{deep copy} kopiert das komplette Objekt, sowie alle Objekt-Referenzen die dieses Objekt wieder besitzt und so weiter.
        \item Während shallow copies meist von Hand geschrieben werden,\pause{} wird eine deep copy meistens durch (De-)Serialisierung gelöst.\par\pause{}\info{Sonst müssten bei einer deep copy auch alle vom Objekt verwendeten Ressourcen wieder deep-copyable sein.\pause{} Das Verfahren hat allerdings ebenfalls Nachteile. Stichwort: \bjava{transient}.}
    \end{itemize}
\end{frame}

\begingroup
\lstset{add to literate={X}{{{\solGet{keywordC}{X}}}}1 {Y}{{{\solGet{keywordC}{Y}}}}1 {Z}{{{\solGet{keywordC}{Z}}}}1}
\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Kopien, Beispiel}
    \begin{itemize}[<+(1)->]
        \item Betrachten wir die folgende Klasse (\bjava{Y} und \bjava{Z} seien ebenfalls gegeben):\pause
\begin{plainjava}
class X {
    int a;
    Y y;
    Z z;
}
\end{plainjava}
        \item Eine \emph{shallow copy} würde ein neues \bjava{X}-Objekt erzeugen und die Attribute durch \say{\bjava{=}} zuweisen.\pause{} Damit wird \bjava{a} kopiert, \bjava{y} und \bjava{z} referenzieren aber (je) dasselbe Objekt.
        \item Eine \emph{deep copy} würde rekursiv auch neue Objekte von \bjava{Y} und \bjava{Z} erzeugen.\par\pause{} \info{Quizfrage: was passiert oder besser, was kann alles passieren, wenn \bjava{Y} wieder eine Referenz auf \bjava{X} enthält?}
        \item Und was davon macht jetzt \bjava{Object::clone()}?\pause{} Spoiler: Nobody knows.
    \end{itemize}
\end{frame}
\endgroup

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Cloneable}
    \begin{itemize}[<+(1)->]
        \item Das Interface Cloneable \emph{fordert nichts} von einer gegebene Klasse.
        \item Es ist ein sogenanntes \say{Marker} interface.\pause{} Wer es implementiert, sorgt dafür, dass gewisse Methoden sich einem gewissen Vertrag unterwerfen.\pause\par\info{Diese Erklärung ist an sich nachträglich entstanden. Die komplette Geschichte um das \bjava{Cloneable}-Interface ist eine einzige Tragödie.}
        \item Aus dem Java-Contract:\pause
\lstfs{9}
\begin{plainjava}
/*
 * Note that this interface does not contain the clone method.
 * Therefore, it is not possible to clone an object merely by virtue of the
 * fact that it implements this interface. !*\onslide<+(1)->*! Even if the clone method is invoked
 * reflectively, there is no guarantee that it will succeed.
 */
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Cloneable, Schadensbericht}
    \begin{itemize}[<+(1)->]
        \item Das Interface widerspricht der sonstigen Schreibweise.\pause{} \info{Clonable vs. Cloneable.}
        \item Es fordert keine Methode und kann theoretisch von jeder Klasse implementiert werden.
        \item Es liefert keine weiteren Informationen über die Kopie.
        \item Es stellt keine Anforderungen an die Java-Syntax (Sichtbarkeit), die nicht gleichermaßen geprüft werden können.
        \item Der Rückgabewert der \bjava{Object::clone}-Methode ist stets \bjava{Object}, wir brauchen also einen expliziten Cast.\pause{} \info{Wie bei \bjava{(Date) this.birthday.clone()}.}
        \item \ldots\pause{} \ldots\pause{} \ldots
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Exkurs: Long story short}
    \begin{itemize}[<+(1)->]
        \item Manche Java Klassen implementieren \bjava{Cloneable} korrekt.\pause{} \info{Wie \bjava{Date}}.
        \item Ansonsten haben sich andere Prinzipien durchgesetzt. So beispielsweise Copy-Konstruktoren.
        \item Diesen werden noch später im Semester begegnen.
        \item Also kehren wir uns lieber von der dunklen Seite ab und zur Präsenzaufgabe zurück\ldots
    \end{itemize}
\end{frame}

{
\setbeamercolor{background canvas}{bg=black}
\begin{frame}[c,plain]{}
\vspace*{1.5em}\centering
\begin{tikzpicture}
    \pgfinterruptboundingbox% to avoid clanky changes
    \only<2|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm]
        \pingu[xshift=3cm,yshift=.5cm]
        \pingu[]
    }
    \only<3|handout:0>{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right, lightsaber right disabled,]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left, lightsaber left disabled]
        \pingu[right wing grab, lightsaber right, lightsaber right disabled, eyes shiny,left wing wave, lightsaber left, lightsaber left disabled,right item angle=-80,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \only<4->{
        \pingu[xshift=-3cm,yshift=.5cm,right wing grab, lightsaber right=orange]
        \pingu[xshift=3cm,yshift=.5cm,left wing grab, lightsaber left=orange]
        \pingu[right wing grab, lightsaber right=pingu@blue, eyes shiny,left wing wave, lightsaber left=green,right item angle=-80,lightsaber right double,lightsaber right yshift=-.5mm,left item angle=75]
    }
    \endpgfinterruptboundingbox
\end{tikzpicture}~~~~~~~~~~~~~~
\end{frame}
}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Der Konstruktor samt Prüfung:\pause{} \info{Bonusfrage: was ist mit \bjava{throws}? Warum ist es nicht nötig?}
\lstfs{9}
\begin{plainjava}
!*\onslide<4->*!public Member(String name, String surname, String birthday) {
!*\onslide<5->*!    if (name.length() <= 0)
!*\onslide<5->*!        throw new IllegalArgumentException("Name ist leer");
!*\onslide<6->*!    if (surname.length() <= 0)
!*\onslide<6->*!        throw new IllegalArgumentException("Nachname ist leer");
!*\onslide<4->*!
!*\onslide<7->*!    this.name = name;
!*\onslide<7->*!    this.surname = surname;
!*\onslide<8->*!    try {
!*\onslide<9->*!        this.birthday = dateFormat.parse(birthday);
!*\onslide<8->*!    } catch(ParseException e) {
!*\onslide<10->*!        throw new IllegalArgumentException("Kein gültiges Datum", e);
!*\onslide<8->*!    }
!*\onslide<4->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Nun noch unsere Variante der \bjava{equals} Methode.\pause{} \info{Diese gleicht \emph{nicht} der \bjava{Object::equals}-Methode!\pause{} Die kommt später.}
\lstfs{9}
\begin{plainjava}
!*\onslide<4->*!public boolean equals(Member other) {
!*\onslide<5->*!    if (other == null)
!*\onslide<5->*!        throw new NullPointerException();
!*\onslide<4->*!
!*\onslide<6->*!    return this.name.equals(other.name)
!*\onslide<6->*!        && this.surname.equals(other.surname)
!*\onslide<6->*!        && this.birthday.equals(other.birthday);
!*\onslide<4->*!}
\end{plainjava}
        \item<7-> Ist die \bjava{if}-Abfrage hier notwendig? \onslide<8->{\info{Nein. \bjava{others.name} würde auch eine \bjava{NullPointerException} werfen.}}
        \item<9-> Ist sie doch gut? \onslide<10->{\info{Ja-ein. Sie macht das Wissen über die möglichen werte von \bjava{other} explizit. An sich sollte man aber eher eine eigene Exception dafür konstruieren und diese dann werfen, oder direkt \bjava{false} zurückliefern.}}
    \end{itemize}
\end{frame}


\section{Übungsblatt 6}
\subsection{Aufgabe 1a)}
\begin{frame}[t,fragile]{Übungsblatt 6 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item
    \end{itemize}
\end{frame}

\subsection{Aufgabe 1b)}
\begin{frame}[t,fragile]{Übungsblatt 6 - Aufgabe 1b)}
    \begin{itemize}[<+(1)->]
        \item
    \end{itemize}
\end{frame}

\subsection{Aufgabe 1c)}
\begin{frame}[t,fragile]{Übungsblatt 6 - Aufgabe 1c)}
    \begin{itemize}[<+(1)->]
        \item

    \end{itemize}
\end{frame}



\definecolor{bee}{RGB}{255, 224, 108}
\definecolor{wings}{RGB}{205, 245, 253}
\colorlet{wings}{wings!70!white}
\newsavebox\beebox
\def\lbody{ (left) to[out=270,in=150] (0,-.725) to[out=30,in=270] (right)}
\savebox\beebox{\begin{tikzpicture}[body/.style={pingu@black!82!BlueGrey50},scale=4,very path/.append style={line join=round}]
% wings
\coordinate (wl) at(20:2.55mm);
\coordinate (wr) at(160:2.55mm);
\draw[very thick,body,fill=wings!80!white,rotate around=-32:(wl)] (wl) ellipse [x radius=6.15mm, y radius=2.75mm];
\draw[very thick,body,fill=wings!80!white,rotate around=32:(wr)] (wr) ellipse [x radius=6.15mm, y radius=2.75mm];
\draw[very thick,body,fill=wings,rotate around=19:(wl)] (wl) ellipse [x radius=6.55mm, y radius=3.125mm];
\draw[very thick,body,fill=wings,rotate around=-19:(wr)] (wr) ellipse [x radius=6.55mm, y radius=3.125mm];
% body
\path (-.375,0) coordinate (left) -- (.375,0) coordinate (right);
\filldraw[ultra thick,body]\lbody;
\scope\clip\lbody;
\foreach \angl in {30,1} {
\fill[bee] (-\angl:.75) to[bend left=14] (180+\angl:.75) -- ++(0,-1.75mm)
                     to[bend right=14] (-\angl-14:.75) -- cycle;
}\endscope
% left and right arm
\foreach\m/\s/\k in {right/-2.45/95,left/-.75/80} {
\scope[shift=(\m),yshift=\s,rotate around=\k:(\m),scale=.166]
\fill[body] (-.965,0) arc(270:90:.29) -- ++(1.233,0) arc (90:-90:.29) -- cycle;
\endscope}
% sting
\draw[line cap=round,body,thick] (0,-.725) -- ++(0,-.035);
% head
\draw[ultra thick,body,fill=bee,rounded corners=6pt] (.85mm,-.55mm) to[bend right=30,looseness=.9] ([xshift=1.45mm,yshift=1.35mm]right) arc(0:180:{(.75cm+2*1.45mm)/2} and {(.75cm+2*1.45mm)/2.05}) to[bend right=30,looseness=.9] (-.85mm,-.55mm) -- cycle;
% eyes [intersect with left and right]
\fill[body] (left|-0,2.265mm)++(.6mm,0) coordinate (el) circle[radius=.6mm];
\coordinate (ell) at ([yshift=-.8mm]el);
\fill[red!21!bee,rotate around=3:(ell)] ([yshift=-.8mm]el) ellipse[x radius=.412mm, y radius=.165mm];
\fill[body] (right|-0,2.265mm)++(-.6mm,0) coordinate (er) circle[radius=.6mm];
\coordinate (err) at ([yshift=-.8mm]er);
\fill[red!21!bee,rotate around=-1:(err)] ([yshift=-.8mm]er) ellipse[x radius=.4mm, y radius=.155mm];
% mouth
\scope[yshift=1mm]
\draw[thick,line cap=round] (-.6mm,0) arc (180:360:.6mm and .415mm);
% antenna
\draw[body,line cap=round,ultra thick] (123:4mm) to[out=110,in=-41] ++(-1mm,3mm) coordinate (@);
\fill[body,rotate around=-41:(@)] ([xshift=-.1mm,yshift=-.185mm]@) ellipse[x radius=.55mm,y radius=.35mm];
\draw[body,line cap=round,ultra thick] (57:4mm) to[out=70,in=180+41] ++(1mm,3mm) coordinate (@);
\fill[body,rotate around=41:(@)] ([xshift=-.1mm,yshift=-.2mm]@) ellipse[x radius=.55mm,y radius=.35mm];
\endscope
\end{tikzpicture}}

\newsavebox\pingudoc
\savebox\pingudoc{\tikz\pingu[body=pingu@black,shirt=pingu@red!80!pingu@black!70!white,bow tie=orange!90!purple, left wing wave, cape=pingu@white!75!gray, halo, halo raise=1.55mm,halo above,cloak wings=false,right eye wink,right,cloak cap=pingu@white!75!gray,monocle left,monocle left glass=pingu@bronze,cane right=pingu@bronze!90!pingu@black, cane right raise=-1.65mm];}
\section{Der End-Pinguuuu}
\begin{frame}[c]
   \pause\begin{center}
    \scalebox{1.25}{\begin{tikzpicture}
        \node[scale=.265,rotate=-13] (bb) at (0,0) {\usebox\beebox};
        \node[left,yshift=-16mm,scale=1.33] at (bb.west) {\usebox\pingudoc};
    \end{tikzpicture}}
   \end{center}
\end{frame}% TODO: cape only? not above? just shirt above? hemd vielleicht?
\end{document}
