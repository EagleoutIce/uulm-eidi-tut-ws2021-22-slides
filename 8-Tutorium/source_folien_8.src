% #region preamble
\InputIfFileExists{../global.src}\relax\relax

\iffull

\title[Achtes Tutorium -- Übungsblatt 8]{(Still) Stay at Home\\\small Tutorium 8}
\date{\sffamily KW 2}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{8}
\fi

% #endregion

\section{Präsenzaufgabe}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Unbekannt}
        Jo Diggie
    \end{aufgabe}
\end{frame}

\section{Übungsblatt 8}
\subsection{Aufgabe 1 a)}
\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1}
    \begin{itemize}[<+(1)->]
        \item Taxi nach Heim bittedange (\only<2->{\textattachfile{\curpath Taxi.java}{Taxi.java}}).
    \end{itemize}
\end{frame}

\section{Altes Präsentatio}
\subsection{Listentausch}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Listentausch, \ldots}
        \pause{}Implementieren Sie eine einfach verkettete Liste, die Integerwerte speichern kann.\pause{} Implementieren Sie eine Methode (+ Hilfsmethoden), die zwei Listenelemente anhand ihrer Indizes vertauscht.\pause{} Die Liste fängt wie ein Array bei 0 zu zählen an. Beachten Sie auch Randbedingungen, wie eine leere Liste.
    \end{aufgabe}
\end{frame}

\def\Element#1{%
    \begin{tabular}{|>{\centering}p{1em}|p{1em}|}
        \hline
            \strut#1 & \\
        \hline
    \end{tabular}%
}

\def\EndElement{
    \begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
        \hline
            \strut/\\
        \hline
    \end{tabular}
}

\newsavebox{\xx}
\sbox{\xx}{\solGet{comments}{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
    \node[inner sep=0pt] (a) at (1.5*0,0) {\Element{1}};
    \node[inner sep=0pt] (b) at (1.5*2.25,0) {\Element{2}};
    \node[inner sep=0pt] (c) at (1.5*4.5,0) {\Element{3}};
    \node[inner sep=0pt] (d) at (1.5*6.75,0) {\Element{4}};
    \node[inner sep=0pt] (e) at (1.5*8.75,0) {\EndElement};
    \foreach[remember=\i as \li (initially a)] \i in {b,c,d,e}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) to[edge label={\T{.next}}] (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }
\end{tikzpicture}}}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Wir konstruieren eine Klasse für das Element.
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<4->*!    int value;
!*\onslide<4->*!    Element next;
!*\onslide<3->*!
!*\onslide<5->*!    public Element (int value, Element next) {
!*\onslide<6->*!        this.value = value;
!*\onslide<6->*!        this.next = next;
!*\onslide<5->*!    }
!*\onslide<3->*!
!*\onslide<7->*!    // !*\usebox{\xx}*!
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, II}
\begin{itemize}[<+(1)->]
    \item Wir benötigen eine weitere Methode:
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<3->*!
!*\onslide<4->*!    // ...
!*\onslide<4->*!    public Element findBefore(int x) {
!*\onslide<5->*!        if(x > 1) { // 0 & 1
!*\onslide<6->*!            if(next != null)
!*\onslide<7->*!                return next.findBefore(x-1);
!*\onslide<8->*!            else return null; // nicht gefunden
!*\onslide<5->*!        } else return this;
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, III}
    \begin{itemize}[<+(1)->]
        \item Wir verwalten sie in einer Listenklasse:
    \begin{plainjava}
!*\onslide<3->*!public class List {
!*\onslide<4->*!    Element head;
!*\onslide<5->*!    public List() { head = null;}
!*\onslide<3->*!
!*\onslide<6->*!    public Element findBefore(int x){
!*\onslide<7->*!        if(head == null) return null;
!*\onslide<8->*!        else head.findBefore(x);
!*\onslide<6->*!    }
!*\onslide<3->*!
!*\onslide<9->*!    // ...
!*\onslide<3->*!}
    \end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, IV}
    \begin{itemize}[<+(1)->]
        \item Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
!*\onslide<3->*!public void swap(int i, int j) {
!*\onslide<3->*!    if(i == j) return; // Gleich
!*\onslide<4->*!    if(i > j) { // Aufsteigend sortiert:
!*\onslide<5->*!        int tmp = i; i = j; j = tmp;
!*\onslide<4->*!    }
!*\onslide<6->*!    Element ai = findBefore(i);
!*\onslide<7->*!    Element bj = findBefore(j);
!*\onslide<8->*!    if(ai != null && bj != null) { // In Liste
!*\onslide<9->*!        Element b = bj.next, a;
!*\onslide<10->*!        if(i == 0) a = head; // Kopf
!*\onslide<11->*!        else a = ai.next;
!*\onslide<12->*!        if(a != null && b != null) { // Exist.
!*\onslide<13->*!            if(i == 0) head = b;
!*\onslide<14->*!            else ai.next = b;
!*\onslide<15->*!            // Swap
!*\onslide<16->*!            bj.next = a;
!*\onslide<17->*!            Element tmp = a.next;
!*\onslide<18->*!            a.next = b.next; b.next = tmp;
!*\onslide<12->*!        }
!*\onslide<8->*!    }
!*\onslide<3->*!}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<19->{\centering\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }
        \draw[densely dashed,Kite-Kite] (a.north) to[bend left] (c.north);
        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{head}};

    \end{tikzpicture}\\[0.5em]}
    \onslide<20->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (a) -- ++(0,0.75) node[above] {\T{head}};

    \end{tikzpicture}}\\[0.5em]
    \onslide<21->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, V}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VI}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,-0.65) -| (d.south);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
            \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
            \fill ($(a.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
            \fill ($(c.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
            \fill ($(b.east)+(-1em,0)$) circle (2pt);

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}
    }
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VII}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- ++(0,-0.65) -| ([xshift=0.25cm]b.south);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (c) at (0,0) {\Element{3}};
            \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (4.5,0) {\Element{1}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \foreach[remember=\i as \li (initially c)] \i in {b,a,d}{
                \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
                \fill ($(\li.east)+(-1em,0)$) circle (2pt);
            }

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}
    }
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}{Präsenzaufgabe - Lösung, VIII}
    \begin{itemize}
        \item Übung: versucht mit Hilfsmethoden wie \bjava{swapElements(Element, Element)} oder \bjava{elementsInList(Element, Element)}, \ldots{} die Struktur zu vereinfachen.
    \end{itemize}
\end{frame}

\subsection{Komplexitätsklassen}
\begin{frame}[c]{Präsenzaufgabe, 2}
    \begin{aufgabe}{It's complex, isn't it?}
        \pause{}Sie sehen gleich ein Programm, welches ein Array an Integer-Werten sortiert. Ihre Aufgaben sind die folgenden: \begin{enumerate}[<+(1)->]
            \item Schätzen Sie die Laufzeit des folgenden Codes gemäß der \(\mathcal{O}\)-Notation ab.
            \item Welchen \say{Trick} nutzt der Algorithmus?
            \item Welches Wissen über die Domäne macht sich der Algorithmus zu Nutze? Welche Nachteile bringt das mit sich?
            \item Geben Sie ein Beispiel an, für das dieser konkrete Algorithmus viel mehr Zeit braucht als notwendig!
            \item Für welche Anwendungsfälle ist der Algorithmus gut geeignet?
        \end{enumerate}
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile,c]{Präsenzaufgabe, 2}
    \addtocounter{tcb@cnt@libx@box@addon@Task@normal}{-1}% :)
    \begin{aufgabe}{It's complex, isn't it?}
\lstfs{7}%
\begin{plainjava}[lineskip=3pt,aboveskip=-7pt,belowskip=-4pt]
!*\onslide<2->*!public static void sort(int min, int max, int[] arr) {
!*\onslide<3->*!    if (min > max) throw new IllegalArgumentException("Intervall [min, max]");
!*\onslide<4->*!    int[] counts = new int[max - min + 1];
!*\onslide<5->*!    for(int e : arr) {
!*\onslide<6->*!        if(!(min <= e && e <= max)) throw new IllegalArgumentException("Element außerhalb Intervall.");
!*\onslide<7->*!        counts[e - min]++;
!*\onslide<5->*!    }
!*\onslide<2->*!
!*\onslide<8->*!    int k = 0;
!*\onslide<9->*!    for(int i = 0; i < arr.length; i++) {
!*\onslide<10->*!        while(counts[k] <= 0) k++;
!*\onslide<10->*!        arr[i] = k + min;
!*\onslide<10->*!        counts[k]--;
!*\onslide<9->*!    }
!*\onslide<2->*!}
\end{plainjava}%
\vspace*{-\baselineskip}\begin{tikzpicture}[overlay,remember picture]
    \onslide<11->{\node[above left=5mm,yshift=.45cm,text width=75mm] at(current page.south east) {%
    \scriptsize\begin{enumerate}
        \item \color{gray}(Worst-Case) Laufzeit in \(\mathcal{O}\)-Notation.
        \item \color{gray}Welchen \say{Trick} nutzt der Algorithmus?
        \item \color{gray}Welches Domänenwissen nutzt der Algorithmus? Welche Nachteile hat das?
        \item \color{gray}Beispiel, das viel mehr Zeit braucht als notwendig!
        \item \color{gray}Für welche Anwendungsfälle ist er gut geeignet?
    \end{enumerate}
    };}
\end{tikzpicture}%
    \end{aufgabe}
\end{frame}

\begin{frame}[c]{Präsenzaufgabe, 2 - Lösung}
    \begin{enumerate}[<+(1)->]
        \item Die Laufzeit skaliert linear in der Länge des Arrays und der Differenz \(max - min\) (Traversierung von \T{counts}). Damit befinden wir uns in \(\mathcal{O}\bigl(\max(\text{\T{arr.length}}, (max-min))\bigr)\). \info{Das innere While wird durch \T{k} nur genau \(max - min\) oft durchlaufen.}
        \item Der Algorithmus zählt (in counts), wie oft eine Zahl im Intervall vorkommt und reproduziert so das Array \info{er ist also nicht stabil}.
        \item Er nutzt das Wissen über ganze Zahlen \(\Q\), sowie die im Array enthaltenen Extremwerte! Im Zweifelsfall kennen wir z.B. \(\max(\text{\T{arr}})\) gar nicht.
        \item Ein Array bei dem \(\text{\T{arr.length}} \ll max - min\). So wird ein unnötig großes \T{counts}-Array traversiert. Beispiel: \bjava{sort(0,42:_:000, new int[]\{3, 0, 40:_:000\})}.
        \item Arrays mit kleinem Wertebereich, welches zudem möglichst gleichverteilt alle Werte aus diesem wertebereich abdeckt.
    \end{enumerate}
\end{frame}


\section{Eine End-Enteee}
\pgfmathsetmacro{\relativefibrethickness}{0.50}
\pgfmathsetmacro{\relativefibrevariation}{0.11}
\pgfmathsetmacro{\numberoffibres}{9}
\pgfmathsetmacro{\fibresteps}{25}
\pgfmathsetmacro{\boardwidth}{10}
\pgfmathsetmacro{\boardheight}{10}
\colorlet{backgroundcolor}{brown}
\colorlet{fibrecolor}{brown!82!black}
\definecolor{shieldsilver}{HTML}{C0C0C0}
\pgfmathsetmacro{\segmentwidth}{\boardwidth/(\numberoffibres+1)}
\pgfmathsetmacro{\segmentvariation}{\relativefibrethickness/2*\segmentwidth}

\pgfmathsetmacro{\secondfibre}{2*\segmentwidth}
\pgfmathsetmacro{\lastfibre}{\numberoffibres*\segmentwidth}

\pgfmathsetmacro{\stepheight}{\boardheight/\fibresteps}
\begin{frame}[c]
    \begin{tikzpicture}[overlay,remember picture]
        \node[above left,yshift=0.45cm,scale=.9] at (current page.south east) {\tikz{\pingu[right wing wave,eyes wink,small]}};
    \end{tikzpicture}
    \begin{center}
        \begin{tikzpicture}
        % Let ducks fight... whatever? ^^
            % \node at(0,0) {\includegraphics[width=4.25cm]{Durotan.png}};
            \node[scale=2.25] at (7,0) {\begin{tikzpicture}
                \duck[invisible,water=blue!90!white]
                \begin{scope}[xshift=-1.25cm,scale=1.1]
                    \fill[gray,rotate=-24] (0.1,1.21) rectangle (1*1.1,1*1.23); % make triangle
                    \fill[gray,rotate=-24]
                        (1.2,1.22) ellipse (1*0.15 and 1*0.03) (1.08,1.22)
                        ellipse (1*0.03 and 1*0.15);
                \end{scope}
                \duck[beard=red!20!brown]
                \node[red!20!brown,rounded corners=1,scale=0.72] at (0.59,1.76) {\rotatebox{-28}{\faMinus}};
                \node[red!20!brown,rounded corners=1,scale=0.75] at (0.86,1.70) {\rotatebox{-2}{\faMinus}};
                \duck[invisible,viking=gray]

                \begin{scope}[scale=0.1,xshift=2.75cm]
                    % Shield
                    \draw[line width=2.75pt,shieldsilver] (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                    % the dots:
                    \pgfmathsetmacro\bwradius{\boardwidth/2+2.75/11 pt}
                    \foreach \i in {0,20,...,360} {
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:\bwradius) circle (3.75pt);
                    }

                    \clip (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                    \filldraw[backgroundcolor] (0,0) rectangle ++(\boardwidth,\boardheight);

                    \foreach \x in {1,2,...,\numberoffibres}
                    {
                        \fill[fibrecolor] ($(\x*\segmentwidth-\segmentvariation,0) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        \foreach \y in {1,...,\fibresteps}
                        {   -- ($(\x*\segmentwidth-\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        }
                        -- ($(\x*\segmentwidth+\segmentvariation,\boardheight)+ (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        \foreach \y in {\fibresteps,...,0}
                        {   -- ($(\x*\segmentwidth+\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        }
                        -- cycle;
                    }
                    % shield post
                    \fill[shieldsilver] (\boardwidth/2,\boardheight/2) circle (46.25pt);
                    \foreach \i in {0,40,...,360} {
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:40.25pt) circle (3.75pt);
                    }
                    \begin{scope}
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2) circle (0.85);
                        \clip (\boardwidth/2,\boardheight/2) circle (0.85);
                        \shade[outer color=shieldsilver!85!black, inner color=shieldsilver!90!white] (\boardwidth/2-0.35,\boardheight/2+0.8) circle (1.32);
                    \end{scope}
                \end{scope}
                %\def\swordscaler{1}
                %\fill[gray,rotate=24] (0.1,0.21) rectangle (\swordscaler*1.1,\swordscaler*0.23); % make triangle
                %\fill[gray!70!black,rotate=24]
                %    (1.2,0.22) ellipse (\swordscaler*0.15 and \swordscaler*0.03) (1.08,0.22)
                %    ellipse (\swordscaler*0.03 and \swordscaler*0.15);
            \end{tikzpicture}};
        \end{tikzpicture}
    \end{center}
\end{frame}
\iffull\end{document}\fi
