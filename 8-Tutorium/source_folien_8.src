% #region preamble
\InputIfFileExists{../global.src}\relax\relax

\lstset{add to literate=%
    {CustomTime}{{{\solGet{keywordC}{CustomTime}}}}{10} %
    {StringTime}{{{\solGet{keywordC}{StringTime}}}}{10} %
    {CalendarDateTime}{{{\solGet{keywordC}{CalendarDateTime}}}}{16} %
    {DateFormatTime}{{{\solGet{keywordC}{DateFormatTime}}}}{14} %
    {Taxi}{{{\solGet{keywordC}{Taxi}}}}{4} %
    {Reservation}{{{\solGet{keywordC}{Reservation}}}}{11} %
}

\iffull

\title[Achtes Tutorium -- Übungsblatt 8]{So once, we had holidays\\\small Dreamy Doggos 8}
\date{\sffamily KW 2}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{8}
\newsavebox\doggominimal \savebox\doggominimal{\tikz\doggo[collar=shadeB,collar ring=!hide,body=shadeB,body back=shadeB,nose=shadeB];}
{\setbeamercolor{background canvas}{bg=paletteB}
\begin{frame}[c,plain]
\centering\only<2->{\scalebox{2.85}{\usebox\doggominimal}}%
\end{frame}}
\newsavebox\superlovepengu
\savebox\superlovepengu{\tikz{\pingu[wings shock,heart=shadeB,eyes color=pingu@white,name=pingu,small,body type=chubby]; \node[pingu@red!90!pingu@white] at(pingu-eye-left) {\faHeart}; \node[pingu@red!90!pingu@white] at(pingu-eye-right) {\faHeart};}}
\newsavebox\doggoleft \savebox\doggoleft{\tikz\doggo[collar=paletteB,height delta=-.5mm];}
\newsavebox\doggoright \savebox\doggoright{\tikz\doggo[collar=purple,height delta=.1mm,body=black!50!gray!85!doggo@brown];}
\begin{frame}[c,plain]
\centering
\onslide<2->{\scalebox{2.35}{%
\usebox\doggoleft\only<3->{~~%
\reflectbox{\usebox\doggoright}}}}
\onslide<4->{\begin{tikzpicture}[overlay, remember picture]
    \node[above left=.175cm] at(current page.south east) {\usebox\superlovepengu};
\end{tikzpicture}}
\end{frame}
\section{Kurzes Recap}
\begin{frame}[c]{Kurzes Recap --- Weihnachten}
\begin{enumerate}[<+(1)->]
    \itemsep8pt
    \item Algorithmenkonstruktion
    \item Programmkonstrukte (Namen \& Programmfluss)
    \item Arrays und Iterationen
    \item Unterprogramme
    \item Objektorientierte Programmierung
\end{enumerate}
\end{frame}

{\def\comm#1{\hfill\textcolor{gray}{\footnotesize#1}}\begin{frame}[c]{Algorithmenkonstruktion}
\begin{itemize}[<+(1)->]
    \itemsep14pt
    \item Totale Korrektheit\smallskip \begin{itemize}
        \itemsep3.5pt
        \item \textit{Terminiertheit:}\hfill Endliche Schritte für jede Eingabe.
        \item \textit{Partielle Korrektheit:}\hfill Wenn terminiert, dann korrekt.
    \end{itemize}
    \item Algorithmusdiskussion\smallskip
    \begin{itemize}
        \itemsep3.5pt
        \item Problemspezifikation\comm{Was meinen Sie mit \say{schnell}?}
        \item Problemabstraktion\comm{Was ist gegeben, was ist gesucht?}
        \item Algorithmenentwurf\comm{Wie kommen wir von gegeben zu gesucht?}
        \item Korrektheitsnachweis\comm{Löst unser Ansatz das Problem?}
        \item Aufwandsanalyse\comm{Wie verhält er sich?}
     \end{itemize}
\end{itemize}
\end{frame}}
{\def\mto{\ensuremath{\to}}
\def\dt#1{{\large\bfseries\textcolor{paletteB!68!white}{\strut#1}}}
\begin{frame}[c]{Programmkonstrukte}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Implizite Typkonvertierung:\quad \dt{byte}~\mto~\dt{short}~\mto~\dt{int}~\mto~\dt{long}~\mto~\dt{float}~\mto~\dt{double}\\
   Zahlen von klein zu groß, sowie: \dt{char}~\mto~\dt{int}.
   \item Präzedenzregeln:\quad Post vor Prä, sonst wie Arithmetik \& Logik.
   \item Default-Werte:\quad Zahlen und Zeichen \bjava{0}, Boolean \bjava{false}, Rest \bjava{null}.
   \item Überschatten:\quad Lokal über Global.
\end{itemize}
\end{frame}
\begin{frame}[c]{Arrays und Iterationen}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item Arrays sind komplexe Datentypen.
   \item Mehrdimensionale Arrays sind eindimensionale Arrays von eindimensionalen Arrays von\ldots
   \item Die drei Schleifenarten sind gleichmächtig. \begin{itemize}
      \item Maximum bekannt: \bjava{for}
      \item Mindestens ein mal: \bjava{do}-\bjava{while}
      \item Sonst: \bjava{while}
   \end{itemize}
\end{itemize}
\end{frame}
}

\begin{frame}[c]{Unterprogramme}
\begin{itemize}[<+(1)->]
   \itemsep18pt
   \item \textit{Überladung:}\quad Gleicher Name, andere Signatur. \begin{itemize}
      \item \textit{Signatur:} Name \& Parametertypliste
      \item Müssen zudem in selber Klasse sein (später: Vererbung)
   \end{itemize}
   \item Beim Aufruf macht Java call-by-value: \begin{itemize}
      \item Alle Parameter werden kopiert (Stack).
   \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[c]{Objektorientierte Programmierung}
\begin{itemize}[<+(1)->]
\itemsep18pt
\item Eine Klasse definiert die Blaupause für Objekte. \begin{itemize}
    \item Attribute definieren den Zustand.
    \item Methoden definieren den Verhalten.
\end{itemize}
\item Der Konstruktor baut den initialen Zustand \begin{itemize}
    \item \textit{Instanziierung}: Erzeugen eines neuen Objektes.
    \item Wenn keiner: erzeugt Java den leeren Standardkonstruktor.
    \item \bjava{this} erlaubt Aufruf von Überladungen.
\end{itemize}
\item Klassen, Methoden,~\ldots:\qquad \textit{Sichtbarkeit}  (\bjava{public},~\ldots)
\item \textit{Gültigkeit}sbereich: Wo die Daten \say{existieren}.
\end{itemize}
\end{frame}
\fi
% #endregion
\section{Präsenzaufgabe}
\def\gcdex#1#2{\pgfmathparse{gcd(#1,#2)}\bjava{ggt(#1, #2) :yields:} \expandafter\bjava\expandafter{\pgfmathresult}}
\begin{frame}[c]{Präsenzaufgabe}
    \onslide<2->{\begin{aufgabe}{Teil mich. Nochmal. Nochmal!}
        \onslide<3->{In dieser Aufgaben sollen Sie mit Hilfe des \textit{euklidischen Algorithmus} den größten gemeinsamen Teiler zweier ganzer Zahlen \(a\) und $b$ bestimmen. Implementieren Sie den Algorithmus einmal \textit{iterativ} und einmal \textit{rekursiv}.}
        \onslide<4->{Welchen jeweiligen Vor- und Nachteil haben die beiden Lösungen?}\medskip

        \onslide<5->{\Fleqn\multicolsep0pt\abovedisplayskip5pt\belowdisplayskip0pt\textit{Beispiele:}
        \begin{multicols}{2}
        \begin{itemize}
            \item<6-> \gcdex{39}{27}
            \begin{align*}
                39 &= 1 \cdot 27 + 12 \\
                27 &= 2 \cdot 12 + 3 \\
                12 &= 4 \cdot \smash{\fbox{3}} + 0
            \end{align*}
            \item<7-> \gcdex{15}{7}
            \begin{align*}
                15 &= 2 \cdot 7 + 1 \\
                7 &= 7 \cdot \smash{\fbox{1}} + 0
            \end{align*}
        \end{itemize}
        \end{multicols}}\vspace*{-.5\baselineskip}
    \end{aufgabe}}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Der größter gemeinsame Teiler also: \only<2->{\textattachfile{\curpath Euclid.java}{Euclid.java}}.
        \item Die Definition:\pause
\begin{equation*}
    \ggt(a, b) = \begin{cases}
        a & \text{ wenn } b = 0 \\
        \ggt(b, a \bmod b) & \text{ sonst.}
    \end{cases}
\end{equation*}
    \item In Java? Unfassbar anders natürlich!
\begin{plainjava}
!*\onslide<6->*!public static int ggt(int a, int b) {
!*\onslide<7->*!    if(b == 0)
!*\onslide<7->*!        return a;
!*\onslide<8->*!    else
!*\onslide<8->*!        return ggt(b, a % b);
!*\onslide<6->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Die iterative Variante:
\begin{plainjava}
!*\onslide<3->*!public static int ggt(int a, int b) {
!*\onslide<4->*!    while(b != 0) {
!*\onslide<5->*!        // swap a, b = b, a % b
!*\onslide<6->*!        int tmp = a % b;
!*\onslide<6->*!        a = b;
!*\onslide<6->*!        b = tmp;
!*\onslide<4->*!    }
!*\onslide<7->*!    return a;
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Iteration vs. Rekursion}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Die \textit{iterative} Lösung ist performanter und braucht weniger Speicher.
        \item Die \textit{rekursive} Lösung ist kompakter und übersichtlicher.
    \end{itemize}
\end{frame}

\section{Übungsblatt 8}
% #region Aufgabe 1
\subsection{Aufgabe 1}
\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item Taxi nach Heim bittedange (\only<2->{\textattachfile{\curpath Taxi.java}{Taxi.java}}).
    \end{itemize}\vfill
\begin{columns}[onlytextwidth,c]
\column{.515\linewidth}
\onslide<3->{\only<4->{\color{gray}}\scriptsize Implementieren Sie eine \mark<5->{Klasse \T{Taxi}} mit \mark<9->{privaten, unveränderlichen} Instanzvariablen für die folgenden Eigenschaften:\def\bul{\textcolor{gray}{\textbullet}}\def\G{\only<4->{\color{gray}}\scriptsize}
\begin{itemize}
    \itemsep0pt
    \item[\bul] \G \mark<7->{Grundpreis} einer Fahrt in \mark<7->{Euro}
    \item[\bul] \G Den \mark<7->{Kilometerpreis} in \mark<7->{Euro}
    \item[\bul] \G Den \mark<7->{Kraftstoffverbrauch} in \mark<7->{$\frac{L}{100km}$}
    \item[\bul] \G Das \mark<7->{Tankvolumen} des Taxis in \mark<7->{Liter}
\end{itemize}
Fügen Sie weiterhin die folgenden \mark<11->{privaten, veränderlichen} Variablen hinzu:
\begin{itemize}
    \itemsep0pt
    \item[\bul] \G Den \mark<7->{Tankinhalt} in \mark<7->{Litern}
    \item[\bul] \G Den \mark<7->{Stand des Taxometers} in \mark<7->{Euro}
    \item[\bul] \G Die \mark<7->{Gesamteinnahmen} in \mark<7->{Euro}
\end{itemize}
Erstellen Sie nun einen \mark<13->{öffentlichen Konstruktor} um diese Variablen sinnvoll zu initialiseren.}
\column{.485\linewidth}
\SetupLstHl\lstfs{9}%
\begin{plainjava}
!*\onslide<6->*!public class Taxi {
!*\onslide<10->*!   private final !*\onslide<8->*!double basicCharge;
!*\onslide<10->*!   private final !*\onslide<8->*!double kilometerPrice;
!*\onslide<10->*!   private final !*\onslide<8->*!double fuelConsumption;
!*\onslide<10->*!   private final !*\onslide<8->*!double fueltankCapacity;
!*\onslide<10->*!
!*\onslide<12->*!   private !*\onslide<8->*!double remainingFuel;
!*\onslide<12->*!   private !*\onslide<8->*!double taxometer;
!*\onslide<12->*!   private !*\onslide<8->*!double totalEarnings;
!*\onslide<10->*!
!*\onslide<14->*!   public Taxi(|ihl|:ldots:|ihl|) {
!*\onslide<14->*!       |ihl|:ldots:|ihl|
!*\onslide<14->*!   }
!*\onslide<6->*!}
\end{plainjava}
\end{columns}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 8 - Aufgabe 1a)}
\SetupLstHl
{\lstfs{8}\begin{plainjava}[columns=fixed]
|ihl|public class Ta:c:xi {|ihl|
|ihl|   private final double basicCharge;       private final double kilometerPrice;|ihl|
|ihl|   private final double fuelConsumption;   private final double fueltankCapacity;|ihl|
|ihl|   private double remainingFuel;           private double taxometer;|ihl|
|ihl|   private double totalEarnings;|ihl|
\end{plainjava}
}\lstfs{10}\begin{plainjava}
!*\onslide<2->*!   public Taxi(double basicCharge, double kilometerPrice,
!*\onslide<2->*!                double fuelConsumption, double fueltankCapacity) {
!*\onslide<3->*!      this.basicCharge = basicCharge;
!*\onslide<3->*!      this.kilometerPrice = kilometerPrice;
!*\onslide<3->*!      this.fuelConsumption = fuelConsumption;
!*\onslide<3->*!      this.fueltankCapacity = fueltankCapacity;
!*\onslide<2->*!
!*\onslide<4->*!      this.remainingFuel = fueltankCapacity;
!*\onslide<5->*!      this.taxometer = 0.0;
!*\onslide<5->*!      this.totalEarnings = 0.0;
!*\onslide<2->*!   }!*\onslide<1->*!
\end{plainjava}
{\lstfs{8}\begin{plainjava}
|ihl|}|ihl|
\end{plainjava}}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1b)}
    \begin{itemize}
        \item<2-> Overdriven sie mich home:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public double drive(double distance) {
!*\onslide<4->*!    double requiredFuel = distance * fuelConsumption / 100;
!*\onslide<5->*!    if(this.remainingFuel < requiredFuel)
!*\onslide<6->*!        return -1; // Fahrt nicht möglich
!*\onslide<3->*!
!*\onslide<7->*!    this.remainingFuel -= requiredFuel;
!*\onslide<8->*!    this.taxometer += basicCharge + distance * kilometerPrice;
!*\onslide<3->*!
!*\onslide<9->*!    return taxometer;
!*\onslide<3->*!}
\end{plainjava}
\end{frame}


\MakeThePinguExplainIt[text width=7.9cm]{cap=!hide,crown,bow tie,right item angle=-60}{Wir könnten auch \bjava{else if} benutzen. So verschmilzt aber ein Guard mit Funktionalität.}
\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1c)}
    \begin{itemize}
        \item<2-> Money Please:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public boolean pay(double amount) {
!*\onslide<4->*!    if (amount < taxometer)
!*\onslide<4->*!        return false;
!*\onslide<5->*!    if (amount > taxometer)
!*\onslide<5->*!        System.out.format("Received !*\solGet{literals}{\solGet{keywordB}{\%.2f}}*!€ tip%n", amount - taxometer);
!*\onslide<3->*!
!*\onslide<6->*!    taxometer = 0.0;
!*\onslide<7->*!    totalEarnings += amount;
!*\onslide<8->*!    return true;
!*\onslide<3->*!}
\end{plainjava}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<9->{\node[left=-7mm,scale=.8] at(current page.-20) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1d)}
    \begin{itemize}
        \item<2-> Einmal auftankeeen:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public void refill(double pricePerLitre) {
!*\onslide<4->*!    double refill = Math.min(
!*\onslide<4->*!        this.totalEarnings / pricePerLitre,
!*\onslide<4->*!        this.fueltankCapacity - this.remainingFuel
!*\onslide<4->*!    ); // Können wir finanziell gesehen volltanken?
!*\onslide<3->*!
!*\onslide<5->*!    this.remainingFuel += refill;
!*\onslide<6->*!    this.totalEarnings -= refill * pricePerLitre;
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1e)}
    \begin{itemize}
        \item<2-> Eine beispielhafte (musterlösungsverdächtige) Verwendung:
    \end{itemize}
\SetupLstHl\lstfs{9}
\begin{plainjava}
!*\onslide<3->*!|ihl|public static void main(String[] args) {|ihl|
!*\onslide<4->*!    Taxi taxi = new Taxi(3, 0.5, 10, 50);
!*\onslide<5->*!    double totalCost = taxi.drive(250);
!*\onslide<6->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<6->*!    else System.out.println("Trip costs " + totalCost);
!*\onslide<7->*!    // pay
!*\onslide<7->*!    if (taxi.pay(totalCost + 3.00)) System.out.println("Tipped 3,00€");
!*\onslide<8->*!    // drive
!*\onslide<8->*!    totalCost = taxi.drive(450);
!*\onslide<8->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<9->*!    // refill & drive
!*\onslide<9->*!    taxi.refill(1.7);
!*\onslide<10->*!    totalCost = taxi.drive(450);
!*\onslide<11->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<11->*!    else System.out.println("Trip costs " + totalCost);
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\iffull
\rExecute{javac Taxi.java}
\begin{frame}[c,fragile]{Eine Anwendung}
\begin{itemize}[<+(1)->]
    \item \rbash[:\pause]{java Taxi}
\end{itemize}
\end{frame}
% #endregion

\section{Übungsblatt 8 -- Zusatzaufgabe 3/6}
\iffull
\begin{frame}[c]{Zusatzaufgabe 3/6}
\centering\pingudefaultsappend{heart=shadeB}%
\begin{tikzpicture}
\only<2->{\pingu[eyes wink,headband,blush,name=pingu-a]}
\only<4->{\pingu[xshift=3.5cm,yshift=-2mm,eyes shiny,small,hat,tie,name=pingu-b]}
\only<5->{\pingu[xshift=7cm,eyes angry,bill=angry,sunglasses,cap,name=pingu-c]}
\only<6->{\pingu[xshift=10.5cm,headphones,santa beard,right eye shiny,eye patch left,name=pingu-d]}
\pgfonlayer{foreground}
\only<2->{\onslide<3->{\node[above right=.25cm,yshift=.5cm,xshift=-24mm,rectangle callout,rounded corners=1pt,align=left,callout absolute pointer={(pingu-a-head-left)},draw,fill=white] at (pingu-a-head-left) {\textbf{Herbert}\\16.01.2022 16:31};}}
\only<4->{\node[above right=.25cm,yshift=.5cm,xshift=-19mm,rectangle callout,rounded corners=1pt,align=left,callout absolute pointer={(pingu-b-head-left)},draw,fill=white] at (pingu-b-head-left) {\textbf{Josefine}\\18.01.2022 9:45};}
\only<5->{\node[above right=.25cm,yshift=.5cm,xshift=-16mm,rectangle callout,rounded corners=1pt,align=left,callout absolute pointer={(pingu-c-head-left)},draw,fill=white] at (pingu-c-head-left) {\textbf{Ute}\\25.01.2022 11:05};}
\only<6->{\node[above right=.25cm,yshift=.5cm,xshift=-15mm,rectangle callout,rounded corners=1pt,align=left,callout absolute pointer={(pingu-d-head-left)},draw,fill=white] at (pingu-d-head-left) {\textbf{Bernd}\\01.03.2022 15:25};}
\endpgfonlayer
\end{tikzpicture}\smallskip
\begin{center}
    \onslide<7->{\textbf{\Large Reservieren, Bitte.}}
\end{center}\vspace*{-\medskipamount}
\end{frame}
\fi
\begin{frame}[c]{Zusatzaufgabe 3/6}
    \begin{itemize}[<+(1)->]
        \itemsep10pt
        \item Wir werden zuerst betrachten, wie wir mit Zeitpunkten umgehen können.
        \begin{itemize}
            \item Manuell speichern als \bjava{<int>.<byte>.<byte> <byte>:<byte>}
            \item Speichern als \bjava{String}
            \item Speichern als \bjava{java.util.Date}
        \end{itemize}
        \item Dann, wie wir Zeitpunkte vergleichen können.
        \item Anschließend werde ich noch etwas zu \bjava{toString} und \bjava{equals} verlieren.
    \end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 3/6 -- Datumsdarstellung}
\begin{frame}[c,fragile]{Zusatzaufgabe 3/6\hfill Manueller Zeitpunkt}
\begin{plainjava}
!*\onslide<2->*!public class CustomTime {
!*\onslide<3->*!    public final int year;
!*\onslide<3->*!    public final byte month;
!*\onslide<3->*!    public final byte day;
!*\onslide<2->*!
!*\onslide<4->*!    public final byte hour;
!*\onslide<4->*!    public final byte minute;
!*\onslide<2->*!
!*\onslide<5->*!    public CustomTime(String date, String time) {
!*\onslide<6->*!        // parse
!*\onslide<5->*!    }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}


\MakeThePinguExplainIt[text width=7cm]{cap=!hide,glasses round,glasses=!hide,straw hat,left eye shiny,right item angle=-20}{In dieser Aufgaben können wir auch annehmen, dass das Datum \say{korrekt} ist.
 Mit einem kleinen diesbezüglichen Kommentar entfällt damit die Prüfung (ebenso wie die Prüfung von \say{\bjava{.}} und \say{\bjava{:}}).}
\begin{frame}[c,fragile]{Zusatzaufgabe 3/6\hfill Manueller Zeitpunkt}
\SetupLstHl\begin{plainjava}
|ihl|public class Custom:c:Time {|ihl|
|ihl|    public final int year;|ihl|
|ihl|    public final byte month, day;|ihl|
|ihl|    public final byte hour, minute;|ihl|

    public CustomTime(String date, String time) {
!*\onslide<2->*!        this.year = Integer.parseInt(date.substring(0,4));
!*\onslide<3->*!        this.month = Byte.parseByte(date.substring(5,7));
!*\onslide<4->*!        if(month < 0 || month > 12)
!*\onslide<4->*!            throw new IllegalArgumentException("0 <= month <= 12");
!*\onslide<5->*!        // ...
!*\onslide<1->*!    }
|ihl|}|ihl|
\end{plainjava}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<6->{\node[left=-7mm,scale=.8] at(current page.3) {\usebox\pinguexplainbox};}
    \only<7->{\node[above left=.25cm,yshift=.35cm] at(current page.south east) {\textattachfile{\curpath CustomTime.java}{CustomTime.java}};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill Als Zeichenkette}
\begin{itemize}[<+(1)->]
    \item Das Speichern ist so besonders einfach:
\begin{plainjava}
!*\onslide<3->*!public class StringTime {
!*\onslide<4->*!    public final String date;
!*\onslide<4->*!    public final String time;
!*\onslide<3->*!
!*\onslide<5->*!    public StringTime(String date, String time) {
!*\onslide<6->*!        this.date = date;
!*\onslide<6->*!        this.time = time;
!*\onslide<5->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \item<7-> Zur Möglichkeiten der Verrechnung kommen wir da noch.
\end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \only<8->{\node[above left=.25cm,yshift=.35cm] at(current page.south east) {\textattachfile{\curpath StringTime.java}{StringTime.java}};}
\end{tikzpicture}
\end{frame}

\iffull
\begin{frame}{Zusatzaufgabe 3/6\hfill Als Java-Datum}
\begin{columns}[onlytextwidth,c]
\column{.8\linewidth}
\begin{itemize}[<+(1)->]
    \item Was kann das eigentlich?
    \item So schlimm kann das ja nicht sein\ldots
    \item Suche: \say{Oracle Date} \textit{\textcolor{gray}{me pls xoxo}}
    \vspace*{2.35em}
    \item<6-> Öhm\ldots\ Ich muss los.
    \item<10-> Quasi alles Deprecated? Schon in \textbf{Java 1}?
    \vspace*{1.5em}
    \item<11-> Aiii \textit{schnief} Looooopf \textit{gluk} maiiii Laiiiif.
\end{itemize}
\column{.2\linewidth}
\centering\onslide<5->{\includegraphics[height=6.15cm]{\curpath java-date-all.png}}%
\only<7->{\llap{\smash{\raisebox{-.2cm}{\downsizeHeight{6.55cm}{\begin{tikzpicture}
    \node[rotate=-14,draw,inner sep=1pt,ultra thick,gray] (a) at (0,0) {\includegraphics[scale=.85]{\curpath java-date-a.png}};
    \onslide<8->{\node[rotate=16,draw,yshift=-4.5cm,xshift=2cm,inner sep=1pt,ultra thick,gray] (b) at (a.south) {\includegraphics[scale=1.65]{\curpath java-date-b.png}};}
    \onslide<9->{\node[draw,xshift=-5cm,yshift=-1.85cm,inner sep=1pt,ultra thick,gray] (c) at (b.south) {\includegraphics[scale=2]{\curpath java-date-c.png}};}
\end{tikzpicture}}\hspace*{-.5\linewidth}}}}}%
\end{columns}
\end{frame}
\fi

\MakeThePinguExplainIt[text width=5.5cm]{cap=!hide,eyes wink,headband,right item angle=-20}{Java beginnt auch bei Monaten in der Regel mit \(0\)!}
\begin{frame}[c,fragile]{Zusatzaufgabe 3/6\hfill Als Java-Datum mit Kalender}
\begin{itemize}[<+(1)->]
    \item Kurzgesagt: \bjava{Date} ist fernab der Internationalisierung. Es hält nur die Sekunden seit \say{Unix Epoch} \info{1. Januar 1970, Mitternacht}.
    \item Wir konstruieren es durch andere Klassen. \pause Mit dem \say{Gregorianischen Kalender}:\lstfs{10}
\begin{plainjava}
!*\onslide<5->*!public class CalendarDateTime {
!*\onslide<6->*!    private final Date date;
!*\onslide<5->*!
!*\onslide<6->*!    public CalendarDateTime(String date, String time) {
!*\onslide<7->*!        CustomTime custom = new CustomTime(date, time);
!*\onslide<8->*!        GregorianCalendar calendar = new GregorianCalendar();
!*\onslide<9->*!        calendar.set(custom.year, custom.month - 1, custom.day,
!*\onslide<9->*!            custom.hour, custom.minute);
!*\onslide<10->*!        this.date = calendar.getTime();
!*\onslide<6->*!    }
!*\onslide<11->*!    // :ldots:
!*\onslide<5->*!}
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<12->{\node[left=-7mm,scale=.8] at(current page.-25) {\usebox\pinguexplainbox};}
    \only<13->{\node[above right=.25cm,yshift=.25cm] at(current page.south west) {\textattachfile{\curpath CalendarDateTime.java}{CalendarDateTime.java}};}
\end{tikzpicture}
\end{frame}

\newsavebox\qrSimpleDateFormat \savebox\qrSimpleDateFormat{\fancyqr[height=2.5cm]{https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html}}
\begin{frame}[c,fragile]{Zusatzaufgabe 3/6\hfill Als Java-Datum mit DateFormat}
\begin{itemize}[<+(1)->]
    \item Java kennt aber auch Datumsformate, wie das \bjava{SimpleDateFormat}:\lstfs{10}
\begin{plainjava}
!*\onslide<4->*!public class DateFormatTime {
!*\onslide<5->*!    private final Date date;
!*\onslide<5->*!
!*\onslide<7->*!    public final SimpleDateFormat dateFormat =
!*\onslide<8->*!            new SimpleDateFormat("yyyy.MM.dd HH:mm");
!*\onslide<4->*!
!*\onslide<6->*!    public DateFormatTime(String date, String time) !*\onslide<6-9|handout:0>*! {
!*\onslide<10->*!                throws ParseException {
!*\onslide<9->*!        this.date = dateFormat.parse(date + " " + time);
!*\onslide<6->*!    }
!*\onslide<4->*!    // ...
!*\onslide<4->*!}!*\onslide<3->*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<3->{\node[above left=.25cm,yshift=.5cm] (fqr) at(current page.south east) {\usebox\qrSimpleDateFormat};
    \node[above left,xshift=-5mm,gray] at(fqr.south west) {\bjava{SimpleDateFormat}};}
    \only<11->{\node[above right=.25cm,yshift=.25cm] at(current page.south west) {\textattachfile{\curpath DateFormatTime.java}{DateFormatTime.java}};}
\end{tikzpicture}
\end{frame}
\fi

\subsection{Zusatzaufgabe 3/6 -- Datumsvergleich}
\begin{frame}[c]{Zusatzaufgabe 3/6\hfill Zwei Datumsies Vergleichen}
\begin{itemize}[<+(1)->]
    \itemsep10pt
    \item Daten vergleichen ist einfach: Sind Jahre, Tage,~\ldots\ identisch?
    \item Zu sagen, wie viele Minuten zwischen zwei Daten liegen, ist schwieriger.
    \begin{itemize}
        \itemsep2pt
        \item Wie viele Minuten liegen zwischen dem 28. Februar 23:59 und dem 1. März 0:05 im selben Jahr?
        \item Wir müssen Schaltjahre beachten.
        \item Und Schaltsekunden!
        \item Und Säkularjahre\ldots
    \end{itemize}
    \item In der Regel dampft man Daten daher auf ihre (Nano-/Milli-/\ldots-)Sekunden seit einem Zeitpunkt herunter.
    \begin{itemize}
        \itemsep2pt
        \item \bjava{java.util.Date} tut dies bereits \info{Millisekunden}!
        \item Dies Manuell korrekt zu tun ist \emph{sehr aufwändig} \info{Die zugehörige Methode \bjava{computeTime} in \bjava{GregorianCalendar} hat beispielsweise allein 200 Zeilen.}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill Minuten zwischen zwei Daten}
\begin{itemize}[<+(1)->]
    \itemsep10pt
    \item Die Minuten zwischen zwei Daten \bjava{a} und \bjava{b} erhalten wir so wie folgt:
\begin{plainjava}
!*\onslide<3->*!long aStamp = a.getTime();
!*\onslide<3->*!long bStamp = b.getTime();
!*\onslide<4->*!double diffInMinutes =  (aStamp - bStamp) / (1000 * 60d)
\end{plainjava}
    \item<5-> Magic Numbers: \begin{itemize}
        \itemsep2pt
        \item<6-> 1000 Millisekunden bilden eine Sekunde.
        \item<7-> 60 Sekunden bilden eine Minute.
    \end{itemize}
\end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 3/6 -- Die Reservierung soweit}
\MakeThePinguExplainIt[text width=6.25cm]{cap=!hide,blush,cape,shirt=lightgray,second shirt=cprimary,hair=cprimary}{Warum nicht \bjava{static}? Nun, das hat etwas mit \bjava{Thread}s zu tun\ldots}
\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill Die Reservierung soweit}
    \begin{itemize}[<+(1)->]
        \item Nun eine Variante mit \bjava{SimpleDateFormat}.
\begin{plainjava}
!*\onslide<3->*!public class Reservation {
!*\onslide<4->*!    private final String name;
!*\onslide<4->*!    private final Date resDate;
!*\onslide<3->*!
!*\onslide<5->*!    public final SimpleDateFormat dateFormat =
!*\onslide<5->*!            new SimpleDateFormat("yyyy.MM.dd HH:mm");
!*\onslide<6->*!    public Reservation(String name, String date, String time)
!*\onslide<6->*!            throws ParseException {
!*\onslide<7->*!        this.name = name;
!*\onslide<7->*!        this.resDate = dateFormat.parse(date + " " + time);
!*\onslide<6->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<8->{\node[left=-5.5mm,scale=.8] at(current page.0) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile,c]{Mini-Exkurs: Mit Ausnahmen umgehen}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item \bjava{ParseException} ist eine \say{checked-Exception}~\(\Rightarrow\) wir müssen sie behandeln.
        \item In dieser Aufgabe können wir eine korrekte Eingabe annehmen.
        \item Dies erlaubt ein Unterdrücken des Fehlers:
\begin{plainjava}
!*\onslide<5->*!try {
!*\onslide<5->*!    |ihl|...|ihl|
!*\onslide<5->*!} catch (ParseException ex) {
!*\onslide<5->*!    |ihl|ex.printStackTrace();|ihl|
!*\onslide<5->*!}
\end{plainjava}
        \item<6-> Allgemein ist aber das Weiterreichen sicherer:
\begin{plainjava}
!*\onslide<7->*!|ihl|public Reserv:c:ation(:ldots:)|ihl| throws ParseException |ihl|{|ihl|
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 3/6 -- toString, equals und main}
\newsavebox\qrStringFormat \savebox\qrStringFormat{\fancyqr[height=2cm]{https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html\#syntax}}
\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill toString}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item \bjava{toString} ist einfach, wenn wir zusätzlich noch die übergebenen Daten speichern.
        \item Mit \bjava{String::format} können wir uns aber interessanteren Freuden widmen:
\begin{plainjava}
!*\onslide<4->*!|ihl|public class Reser:c:vation {|ihl|
!*\onslide<4->*!|ihl|    private String name;|ihl|
!*\onslide<4->*!|ihl|    private Date resDate;|ihl|
!*\onslide<5->*!    public String toString() {
!*\onslide<6->*!        return String.format(Locale.ENGLISH, // March statt März
!*\onslide<7->*!            "%s reserved for !*\solGet{literals}{\solGet{keywordB}{\%2\$tB}}*! !*\solGet{literals}{\solGet{keywordB}{\%2\$td}}*!, !*\solGet{literals}{\solGet{keywordB}{\%2\$tY}}*! at !*\solGet{literals}{\solGet{keywordB}{\%2\$tH}}*!:!*\solGet{literals}{\solGet{keywordB}{\%2\$tM}}*!",
!*\onslide<8->*!            this.name, this.resDate
!*\onslide<6->*!        );
!*\onslide<5->*!    }
!*\onslide<4->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<9->{\node[above left=.25cm,yshift=.5cm] (fqr) at(current page.south east) {\usebox\qrStringFormat};
    \node[above left,xshift=-5mm,gray] at(fqr.south west) {Format String Syntax};}
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill toString}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item Aber halt. Es war ja \bjava{toString(Reservation)} gefordert.
        \item Nun, wir könnten dies wie folgt lösen (das ist aber unüblich):
\begin{plainjava}
!*\onslide<4->*!|ihl|public class Reser:c:vation {|ihl|
!*\onslide<4->*!|ihl|    private String name;|ihl|
!*\onslide<4->*!|ihl|    private Date resDate;|ihl|
!*\onslide<5->*!    public static String toString(Reservation r) {
!*\onslide<6->*!        return String.format(Locale.ENGLISH, // March statt März
!*\onslide<7->*!            "%s reserved for !*\solGet{literals}{\solGet{keywordB}{\%2\$tB}}*! !*\solGet{literals}{\solGet{keywordB}{\%2\$td}}*!, !*\solGet{literals}{\solGet{keywordB}{\%2\$tY}}*! at !*\solGet{literals}{\solGet{keywordB}{\%2\$tH}}*!:!*\solGet{literals}{\solGet{keywordB}{\%2\$tM}}*!",
!*\onslide<8->*!            r.name, r.resDate
!*\onslide<6->*!        );
!*\onslide<5->*!    }
!*\onslide<9->*!    public String toString() { toString(this); }
!*\onslide<4->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill toString -- Calendar}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item Gibt es Alternativen?
        \item Japp. Die gibt es. Beispielsweise mit \bjava{Calendar}:
\begin{plainjava}
!*\onslide<4->*!public static String toString(Reservation reservation) {
!*\onslide<5->*!    Calendar calendar = Calendar.getInstance();
!*\onslide<6->*!    calendar.setTime(reservation.resDate);
!*\onslide<7->*!    return "Reservierung für " + reservation.name
!*\onslide<8->*!            + " am " + calendar.get(Calendar.YEAR) + "."
!*\onslide<8->*!            + (calendar.get(Calendar.MONTH) + 1)  + "."
!*\onslide<8->*!            + calendar.get(Calendar.DAY_OF_MONTH)
!*\onslide<8->*!            + " um " + calendar.get(Calendar.HOUR_OF_DAY) + ":"
!*\onslide<8->*!            + calendar.get(Calendar.MINUTE)
!*\onslide<8->*!            + " Uhr.";
!*\onslide<4->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zusatzaufgabe 3/6\hfill equals}
    \SetupLstHl\begin{itemize}[<+(1)->]
        \item Felder vergleichen:\lstfs{10}
\begin{plainjava}
!*\onslide<3->*!|ihl|public class Reser:c:vation {|ihl|
!*\onslide<3->*!|ihl|    private String name;|ihl|
!*\onslide<3->*!|ihl|    private Date resDate;|ihl|
!*\onslide<4->*!    public boolean equals(Reservation reservation) {
!*\onslide<5->*!        return this == reservation ||
!*\onslide<6->*!           (Objects.equals(this.resDate, reservation.resDate)
!*\onslide<7->*!           &&  Objects.equals(this.name, reservation.name));
!*\onslide<4->*!    }
!*\onslide<3->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
    \item<8-> Der \bjava{==}-Vergleich ist nicht notwendig, zeigt aber die stärkere Aussage von \say{identisch} gegenüber \say{gleich}.
    \item<9-> \bjava{Object.equals(a, b)} entspricht \bjava{a.equals(b)}, kann aber auch mit \bjava{a == null} umgehen!
\end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Zusatzaufgabe 3/6\hfill main}
\SetupLstHl\begin{itemize}[<+(1)->]
    \item Eine Form der Verwendung:\lstfs{10}
\begin{plainjava}
!*\onslide<3->*!|ihl|public class Reser:c:vation {|ihl|
!*\onslide<3->*!  |ihl|public Reser:c:vation(String n, String d, String t) throws ParseException;|ihl|
!*\onslide<3->*!  |ihl|public String toString();|ihl|
!*\onslide<3->*!  |ihl|public boolean equals(Reser:c:vation reservation);|ihl|
!*\onslide<3->*!
!*\onslide<4->*!  public static void main(String[] args) throws ParseException {
!*\onslide<5->*!    Reservation r1 = new Reservation("Hugo", "2022.10.15", "14:32");
!*\onslide<5->*!    System.out.println(r1);
!*\onslide<6->*!    System.out.println("same: " + r1.equals(r1));
!*\onslide<7->*!    Reservation other = new Reservation("Hugo", "2022.10.15", "14:32");
!*\onslide<7->*!    System.out.println("other: " + r1.equals(other));
!*\onslide<8->*!    Reservation diff = new Reservation("Hugo", "2022.01.15", "14:33");
!*\onslide<8->*!    System.out.println("different: " + r1.equals(diff));
!*\onslide<3->*!  }
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 3/6 -- Der checkIn}
\begin{frame}[fragile,c]{Zusatzaufgabe 3/6\hfill Der checkIn}
\SetupLstHl\begin{itemize}[<+(1)->]
    \item Beim \bjava{checkIn} können wir das Minutenintervall leicht prüfen:\lstfs{10}
\begin{plainjava}
!*\onslide<3->*!|ihl|public class Reser:c:vation {|ihl|
!*\onslide<3->*!|ihl|  private String name;|ihl|
!*\onslide<3->*!|ihl|  private Date resDate;|ihl|
!*\onslide<4->*!  public boolean checkIn(Reservation reservation) {
!*\onslide<5->*!      long them = reservation.resDate.getTime();
!*\onslide<5->*!      long we = this.resDate.getTime();
!*\onslide<6->*!      double diffInMinutes =  (them - we) / (MS_IN_S * S_IN_MS);
!*\onslide<7->*!      // is it between 5 and 15 minutes?
!*\onslide<7->*!      return diffInMinutes >= -5  && diffInMinutes <= 15 ;
!*\onslide<4->*!  }
!*\onslide<3->*!|ihl|}|ihl|!*\onslide<1->*!
\end{plainjava}
    \item<8-> Dabei ist \bjava{MS\_IN\_S = 1000} und \bjava{S\_IN\_MS = 60}.
\end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \only<9->{\node[above left=.25cm,yshift=.25cm] at(current page.south east) {\textattachfile{\curpath Reservation.java}{Reservation.java}};}
\end{tikzpicture}
\end{frame}

% #region old
\iffull
\section{Altes Präsentatio}
\subsection{Listentausch}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Listentausch, \ldots}
        \pause{}Implementieren Sie eine einfach verkettete Liste, die Integerwerte speichern kann.\pause{} Implementieren Sie eine Methode (+ Hilfsmethoden), die zwei Listenelemente anhand ihrer Indizes vertauscht.\pause{} Die Liste fängt wie ein Array bei 0 zu zählen an. Beachten Sie auch Randbedingungen, wie eine leere Liste.\onslide<1->
    \end{aufgabe}
\end{frame}

\def\Element#1{%
    \begin{tabular}{|>{\centering}p{1em}|p{1em}|}
        \hline
            \strut#1 & \\
        \hline
    \end{tabular}%
}

\def\EndElement{
    \begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
        \hline
            \strut/\\
        \hline
    \end{tabular}
}

\newsavebox{\xx}
\sbox{\xx}{\solGet{comments}{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
    \node[inner sep=0pt] (a) at (1.5*0,0) {\Element{1}};
    \node[inner sep=0pt] (b) at (1.5*2.25,0) {\Element{2}};
    \node[inner sep=0pt] (c) at (1.5*4.5,0) {\Element{3}};
    \node[inner sep=0pt] (d) at (1.5*6.75,0) {\Element{4}};
    \node[inner sep=0pt] (e) at (1.5*8.75,0) {\EndElement};
    \foreach[remember=\i as \li (initially a)] \i in {b,c,d,e}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) to[edge label={\T{.next}}] (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }
\end{tikzpicture}}}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Wir konstruieren eine Klasse für das Element.
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<4->*!    int value;
!*\onslide<4->*!    Element next;
!*\onslide<3->*!
!*\onslide<5->*!    public Element (int value, Element next) {
!*\onslide<6->*!        this.value = value;
!*\onslide<6->*!        this.next = next;
!*\onslide<5->*!    }
!*\onslide<3->*!
!*\onslide<7->*!    // !*\usebox{\xx}*!
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, II}
\begin{itemize}[<+(1)->]
    \item Wir benötigen eine weitere Methode:
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<3->*!
!*\onslide<4->*!    // ...
!*\onslide<4->*!    public Element findBefore(int x) {
!*\onslide<5->*!        if(x > 1) { // 0 & 1
!*\onslide<6->*!            if(next != null)
!*\onslide<7->*!                return next.findBefore(x-1);
!*\onslide<8->*!            else return null; // nicht gefunden
!*\onslide<5->*!        } else return this;
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, III}
    \begin{itemize}[<+(1)->]
        \item Wir verwalten sie in einer Listenklasse:
    \begin{plainjava}
!*\onslide<3->*!public class List {
!*\onslide<4->*!    Element head;
!*\onslide<5->*!    public List() { head = null;}
!*\onslide<3->*!
!*\onslide<6->*!    public Element findBefore(int x){
!*\onslide<7->*!        if(head == null) return null;
!*\onslide<8->*!        else head.findBefore(x);
!*\onslide<6->*!    }
!*\onslide<3->*!
!*\onslide<9->*!    // ...
!*\onslide<3->*!}
    \end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, IV}
    \begin{itemize}[<+(1)->]
        \item Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
!*\onslide<3->*!public void swap(int i, int j) {
!*\onslide<3->*!    if(i == j) return; // Gleich
!*\onslide<4->*!    if(i > j) { // Aufsteigend sortiert:
!*\onslide<5->*!        int tmp = i; i = j; j = tmp;
!*\onslide<4->*!    }
!*\onslide<6->*!    Element ai = findBefore(i);
!*\onslide<7->*!    Element bj = findBefore(j);
!*\onslide<8->*!    if(ai != null && bj != null) { // In Liste
!*\onslide<9->*!        Element b = bj.next, a;
!*\onslide<10->*!        if(i == 0) a = head; // Kopf
!*\onslide<11->*!        else a = ai.next;
!*\onslide<12->*!        if(a != null && b != null) { // Exist.
!*\onslide<13->*!            if(i == 0) head = b;
!*\onslide<14->*!            else ai.next = b;
!*\onslide<15->*!            // Swap
!*\onslide<16->*!            bj.next = a;
!*\onslide<17->*!            Element tmp = a.next;
!*\onslide<18->*!            a.next = b.next; b.next = tmp;
!*\onslide<12->*!        }
!*\onslide<8->*!    }
!*\onslide<3->*!}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<19->{\centering\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }
        \draw[densely dashed,Kite-Kite] (a.north) to[bend left] (c.north);
        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{head}};

    \end{tikzpicture}\\[0.5em]}
    \onslide<20->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (a) -- ++(0,0.75) node[above] {\T{head}};

    \end{tikzpicture}}\\[0.5em]
    \onslide<21->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, V}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}%
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]%
    \onslide<3->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}%
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VI}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}%
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,-0.65) -| (d.south);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]%
    \onslide<3->{%
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
            \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
            \fill ($(a.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
            \fill ($(c.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
            \fill ($(b.east)+(-1em,0)$) circle (2pt);

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}%
    }%
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VII}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}%
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- ++(0,-0.65) -| ([xshift=0.25cm]b.south);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]%
    \onslide<3->{%
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (c) at (0,0) {\Element{3}};
            \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (4.5,0) {\Element{1}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \foreach[remember=\i as \li (initially c)] \i in {b,a,d}{
                \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
                \fill ($(\li.east)+(-1em,0)$) circle (2pt);
            }

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}%
    }%
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}{Präsenzaufgabe - Lösung, VIII}
    \begin{itemize}
        \item Übung: versucht mit Hilfsmethoden wie \bjava{swapElements(Element, Element)} oder \bjava{elementsInList(Element, Element)}, \ldots{} die Struktur zu vereinfachen.
    \end{itemize}
\end{frame}

\subsection{Komplexitätsklassen}
\begin{frame}[c]{Präsenzaufgabe, 2}
    \begin{aufgabe}{It is complex, isn't it?}
        \pause{}Sie sehen gleich ein Programm, welches ein Array an Integer-Werten sortiert. Ihre Aufgaben sind die folgenden: \begin{enumerate}[<+(1)->]
            \item Schätzen Sie die Laufzeit des folgenden Codes gemäß der \(\mathcal{O}\)-Notation ab.
            \item Welchen \say{Trick} nutzt der Algorithmus?
            \item Welches Wissen über die Domäne macht sich der Algorithmus zu Nutze? Welche Nachteile bringt das mit sich?
            \item Geben Sie ein Beispiel an, für das dieser konkrete Algorithmus viel mehr Zeit braucht als notwendig!
            \item Für welche Anwendungsfälle ist der Algorithmus gut geeignet?
        \end{enumerate}
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile,c]{Präsenzaufgabe, 2}
    \addtocounter{tcb@cnt@libx@box@addon@Task@normal}{-1}% :)
    \begin{aufgabe}{It's complex, isn't it?}
\lstfs{7}%
\begin{plainjava}[lineskip=3pt,aboveskip=-7pt,belowskip=-4pt]
!*\onslide<2->*!public static void sort(int min, int max, int[] arr) {
!*\onslide<3->*!    if (min > max) throw new IllegalArgumentException("Intervall [min, max]");
!*\onslide<4->*!    int[] counts = new int[max - min + 1];
!*\onslide<5->*!    for(int e : arr) {
!*\onslide<6->*!        if(!(min <= e && e <= max)) throw new IllegalArgumentException("Element außerhalb Intervall.");
!*\onslide<7->*!        counts[e - min]++;
!*\onslide<5->*!    }
!*\onslide<2->*!
!*\onslide<8->*!    int k = 0;
!*\onslide<9->*!    for(int i = 0; i < arr.length; i++) {
!*\onslide<10->*!        while(counts[k] <= 0) k++;
!*\onslide<10->*!        arr[i] = k + min;
!*\onslide<10->*!        counts[k]--;
!*\onslide<9->*!    }
!*\onslide<2->*!}
\end{plainjava}%
\vspace*{-\baselineskip}\begin{tikzpicture}[overlay,remember picture]
    \onslide<11->{\node[above left=5mm,yshift=.45cm,text width=75mm] at(current page.south east) {%
    \scriptsize\begin{enumerate}
        \item \color{gray}(Worst-Case) Laufzeit in \(\mathcal{O}\)-Notation.
        \item \color{gray}Welchen \say{Trick} nutzt der Algorithmus?
        \item \color{gray}Welches Domänenwissen nutzt der Algorithmus? Welche Nachteile hat das?
        \item \color{gray}Beispiel, das viel mehr Zeit braucht als notwendig!
        \item \color{gray}Für welche Anwendungsfälle ist er gut geeignet?
    \end{enumerate}
    };}
\end{tikzpicture}%
    \end{aufgabe}
\end{frame}

\begin{frame}[c]{Präsenzaufgabe, 2 - Lösung}
    \begin{enumerate}[<+(1)->]
        \item Die Laufzeit skaliert linear in der Länge des Arrays und der Differenz \(max - min\) (Traversierung von \T{counts}). Damit befinden wir uns in \(\mathcal{O}\bigl(\max(\text{\T{arr.length}}, (max-min))\bigr)\). \info{Das innere While wird durch \T{k} nur genau \(max - min\) oft durchlaufen.}
        \item Der Algorithmus zählt (in counts), wie oft eine Zahl im Intervall vorkommt und reproduziert so das Array \info{er ist also nicht stabil}.
        \item Er nutzt das Wissen über ganze Zahlen \(\Q\), sowie die im Array enthaltenen Extremwerte! Im Zweifelsfall kennen wir z.B. \(\max(\text{\T{arr}})\) gar nicht.
        \item Ein Array bei dem \(\text{\T{arr.length}} \ll max - min\). So wird ein unnötig großes \T{counts}-Array traversiert. Beispiel: \bjava{sort(0,42:_:000, new int[]\{3, 0, 40:_:000\})}.
        \item Arrays mit kleinem Wertebereich, welches zudem möglichst gleichverteilt alle Werte aus diesem wertebereich abdeckt.
    \end{enumerate}
\end{frame}
\fi
\section{Eine End-Ente, ein End-Doggo und ein End-Pingu}
\pgfmathsetmacro{\relativefibrethickness}{0.50}
\pgfmathsetmacro{\relativefibrevariation}{0.11}
\pgfmathsetmacro{\numberoffibres}{9}
\pgfmathsetmacro{\fibresteps}{25}
\pgfmathsetmacro{\boardwidth}{10}
\pgfmathsetmacro{\boardheight}{10}
\colorlet{backgroundcolor}{brown}
\colorlet{fibrecolor}{brown!82!black}
\definecolor{shieldsilver}{HTML}{C0C0C0}
\pgfmathsetmacro{\segmentwidth}{\boardwidth/(\numberoffibres+1)}
\pgfmathsetmacro{\segmentvariation}{\relativefibrethickness/2*\segmentwidth}

\pgfmathsetmacro{\secondfibre}{2*\segmentwidth}
\pgfmathsetmacro{\lastfibre}{\numberoffibres*\segmentwidth}

\pgfmathsetmacro{\stepheight}{\boardheight/\fibresteps}
\begin{frame}[c]
\vspace*{.955em}\begin{center}
    \raisebox{.2cm}{\scalebox{2.5}{\begin{tikzpicture}
        \doggo[height delta=.1mm,body=white!95!brown!89!pingu@red,eye=pingu@red!25!pingu@black]
    \end{tikzpicture}}}\!\!\!\!\!
    \scalebox{.8}{\begin{tikzpicture}
    % Let ducks fight... whatever? ^^
        % \node at(0,0) {\includegraphics[width=4.25cm]{Durotan.png}};
        \node[scale=2.25] at (7,0) {\begin{tikzpicture}
            \duck[invisible,water=blue!90!white]
            \begin{scope}[xshift=-1.25cm,scale=1.1]
                \fill[gray,rotate=-24] (0.1,1.21) rectangle (1*1.1,1*1.23); % make triangle
                \fill[gray,rotate=-24]
                    (1.2,1.22) ellipse (1*0.15 and 1*0.03) (1.08,1.22)
                    ellipse (1*0.03 and 1*0.15);
            \end{scope}
            \duck[beard=red!20!brown]
            \node[red!20!brown,rounded corners=1,scale=0.72] at (0.59,1.76) {\rotatebox{-28}{\faMinus}};
            \node[red!20!brown,rounded corners=1,scale=0.75] at (0.86,1.70) {\rotatebox{-2}{\faMinus}};
            \duck[invisible,viking=gray]

            \begin{scope}[scale=0.1,xshift=2.75cm]
                % Shield
                \draw[line width=2.75pt,shieldsilver] (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                % the dots:
                \pgfmathsetmacro\bwradius{\boardwidth/2+2.75/11 pt}
                \foreach \i in {0,20,...,360} {
                    \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:\bwradius) circle (3.75pt);
                }

                \clip (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                \filldraw[backgroundcolor] (0,0) rectangle ++(\boardwidth,\boardheight);

                \foreach \x in {1,2,...,\numberoffibres}
                {
                    \fill[fibrecolor] ($(\x*\segmentwidth-\segmentvariation,0) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                    \foreach \y in {1,...,\fibresteps}
                    {   -- ($(\x*\segmentwidth-\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                    }
                    -- ($(\x*\segmentwidth+\segmentvariation,\boardheight)+ (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                    \foreach \y in {\fibresteps,...,0}
                    {   -- ($(\x*\segmentwidth+\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                    }
                    -- cycle;
                }
                % shield post
                \fill[shieldsilver] (\boardwidth/2,\boardheight/2) circle (46.25pt);
                \foreach \i in {0,40,...,360} {
                    \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:40.25pt) circle (3.75pt);
                }
                \begin{scope}
                    \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2) circle (0.85);
                    \clip (\boardwidth/2,\boardheight/2) circle (0.85);
                    \shade[outer color=shieldsilver!85!black, inner color=shieldsilver!90!white] (\boardwidth/2-0.35,\boardheight/2+0.8) circle (1.32);
                \end{scope}
            \end{scope}
            %\def\swordscaler{1}
            %\fill[gray,rotate=24] (0.1,0.21) rectangle (\swordscaler*1.1,\swordscaler*0.23); % make triangle
            %\fill[gray!70!black,rotate=24]
            %    (1.2,0.22) ellipse (\swordscaler*0.15 and \swordscaler*0.03) (1.08,0.22)
            %    ellipse (\swordscaler*0.03 and \swordscaler*0.15);
        \end{tikzpicture}};
    \end{tikzpicture}}
\end{center}
\begin{tikzpicture}[overlay,remember picture]
    \node[above left,yshift=0.45cm,scale=.8] at (current page.south east) {\tikz{\pingu[right wing wave,eyes wink,eye patch right,small]}};
\end{tikzpicture}
\end{frame}
% #endregion
\iffull\end{document}\fi
