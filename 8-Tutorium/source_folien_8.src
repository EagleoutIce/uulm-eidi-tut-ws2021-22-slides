% #region preamble
\InputIfFileExists{../global.src}\relax\relax

\iffull

\title[Achtes Tutorium -- Übungsblatt 8]{So once, we had holidays\\\small Dreamy Doggos 8}
\date{\sffamily KW 2}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{8}
\fi

% #endregion

\section{Präsenzaufgabe}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Unbekannt}
        Jo Diggie
    \end{aufgabe}
\end{frame}

\section{Übungsblatt 8}
\subsection{Aufgabe 1}
\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item Taxi nach Heim bittedange (\only<2->{\textattachfile{\curpath Taxi.java}{Taxi.java}}).
    \end{itemize}\vfill
\begin{columns}[onlytextwidth,c]
\column{.515\linewidth}
\onslide<3->{\only<4->{\color{gray}}\scriptsize Implementieren Sie eine \mark<5->{Klasse \T{Taxi}} mit \mark<9->{privaten, unveränderlichen} Instanzvariablen für die folgenden Eigenschaften:\def\bul{\textcolor{gray}{\textbullet}}\def\G{\only<4->{\color{gray}}\scriptsize}
\begin{itemize}
    \itemsep0pt
    \item[\bul] \G \mark<7->{Grundpreis} einer Fahrt in \mark<7->{Euro}
    \item[\bul] \G Den \mark<7->{Kilometerpreis} in \mark<7->{Euro}
    \item[\bul] \G Den \mark<7->{Kraftstoffverbrauch} in \mark<7->{$\frac{l}{100km}$}
    \item[\bul] \G Das \mark<7->{Tankvolumen} des Taxis in \mark<7->{Liter}
\end{itemize}
Fügen Sie weiterhin die folgenden \mark<11->{privaten, veränderlichen} Variablen hinzu:
\begin{itemize}
    \itemsep0pt
    \item[\bul] \G Den \mark<7->{Tankinhalt} in \mark<7->{Litern}
    \item[\bul] \G Den \mark<7->{Stand des Taxometers} in \mark<7->{Euro}
    \item[\bul] \G Die \mark<7->{Gesamteinnahmen} in \mark<7->{Euro}
\end{itemize}
Erstellen Sie nun einen \mark<13->{öffentlichen Konstruktor} um diese Variablen sinnvoll zu initialiseren.}
\column{.485\linewidth}
\SetupLstHl\lstfs{9}%
\begin{plainjava}
!*\onslide<6->*!public class Taxi {
!*\onslide<10->*!   private final !*\onslide<8->*!double basicCharge;
!*\onslide<10->*!   private final !*\onslide<8->*!double kilometerPrice;
!*\onslide<10->*!   private final !*\onslide<8->*!double fuelConsumption;
!*\onslide<10->*!   private final !*\onslide<8->*!double fueltankCapacity;
!*\onslide<10->*!
!*\onslide<12->*!   private !*\onslide<8->*!double remainingFuel;
!*\onslide<12->*!   private !*\onslide<8->*!double taxometer;
!*\onslide<12->*!   private !*\onslide<8->*!double totalEarnings;
!*\onslide<10->*!
!*\onslide<14->*!   public Taxi(|ihl|:ldots:|ihl|) {
!*\onslide<14->*!       |ihl|:ldots:|ihl|
!*\onslide<14->*!   }
!*\onslide<6->*!}
\end{plainjava}
\end{columns}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 8 - Aufgabe 1a)}
\SetupLstHl
{\lstfs{8}\begin{plainjava}[columns=fixed]
|ihl|public class Taxi {|ihl|
|ihl|   private final double basicCharge;       private final double kilometerPrice;|ihl|
|ihl|   private final double fuelConsumption;   private final double fueltankCapacity;|ihl|
|ihl|   private double remainingFuel;           private double taxometer;|ihl|
|ihl|   private double totalEarnings;|ihl|
\end{plainjava}
}\lstfs{10}\begin{plainjava}
!*\onslide<2->*!   public Taxi(double basicCharge, double kilometerPrice,
!*\onslide<2->*!                double fuelConsumption, double fueltankCapacity) {
!*\onslide<3->*!      this.basicCharge = basicCharge;
!*\onslide<3->*!      this.kilometerPrice = kilometerPrice;
!*\onslide<3->*!      this.fuelConsumption = fuelConsumption;
!*\onslide<3->*!      this.fueltankCapacity = fueltankCapacity;
!*\onslide<2->*!
!*\onslide<4->*!      this.remainingFuel = fueltankCapacity;
!*\onslide<5->*!      this.taxometer = 0.0;
!*\onslide<5->*!      this.totalEarnings = 0.0;
!*\onslide<2->*!   }!*\onslide<1->*!
\end{plainjava}
{\lstfs{8}\begin{plainjava}
|ihl|}|ihl|
\end{plainjava}}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1b)}
    \begin{itemize}
        \item<2-> Overdriven sie mich home:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public double drive(double distance) {
!*\onslide<4->*!    double requiredFuel = distance * fuelConsumption / 100;
!*\onslide<5->*!    if(this.remainingFuel < requiredFuel)
!*\onslide<6->*!        return -1; // Fahrt nicht möglich
!*\onslide<3->*!
!*\onslide<7->*!    this.remainingFuel -= requiredFuel;
!*\onslide<8->*!    this.taxometer += basicCharge + distance * kilometerPrice;
!*\onslide<3->*!
!*\onslide<9->*!    return taxometer;
!*\onslide<3->*!}
\end{plainjava}
\end{frame}


\MakeThePinguExplainIt[text width=7.9cm]{cap=!hide,crown,bow tie,right item angle=-60}{Wir könnten auch \bjava{else if} benutzen. So verschmilzt aber ein Guard mit Funktionalität.}
\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1c)}
    \begin{itemize}
        \item<2-> Money Please:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public boolean pay(double amount) {
!*\onslide<4->*!    if (amount < taxometer)
!*\onslide<4->*!        return false;
!*\onslide<5->*!    if (amount > taxometer)
!*\onslide<5->*!        System.out.format("Received !*\solGet{literals}{\solGet{keywordB}{\%.2f}}*!€ tip%n", amount - taxometer);
!*\onslide<3->*!
!*\onslide<6->*!    taxometer = 0.0;
!*\onslide<7->*!    totalEarnings += amount;
!*\onslide<8->*!    return true;
!*\onslide<3->*!}
\end{plainjava}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<9->{\node[left=-7mm,scale=.8] at(current page.-20) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1d)}
    \begin{itemize}
        \item<2-> Einmal auftankeeen:
    \end{itemize}
\begin{plainjava}
!*\onslide<3->*!public void refill(double pricePerLitre) {
!*\onslide<4->*!    double refill = Math.min(
!*\onslide<4->*!        this.totalEarnings / pricePerLitre,
!*\onslide<4->*!        this.fueltankCapacity - this.remainingFuel
!*\onslide<4->*!    ); // Können wir finanziell gesehen volltanken?
!*\onslide<3->*!
!*\onslide<5->*!    this.remainingFuel += refill;
!*\onslide<6->*!    this.totalEarnings -= refill * pricePerLitre;
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 8 - Aufgabe 1e)}
    \begin{itemize}
        \item<2-> Eine beispielhafte (musterlösungsverdächtige) Verwendung:
    \end{itemize}
\SetupLstHl\lstfs{9}
\begin{plainjava}
!*\onslide<3->*!|ihl|public static void main(String[] args) {|ihl|
!*\onslide<4->*!    Taxi taxi = new Taxi(3, 0.5, 10, 50);
!*\onslide<5->*!    double totalCost = taxi.drive(250);
!*\onslide<6->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<6->*!    else System.out.println("Trip costs " + totalCost);
!*\onslide<7->*!    // pay
!*\onslide<7->*!    if (taxi.pay(totalCost + 3.00)) System.out.println("Tipped 3,00€");
!*\onslide<8->*!    // drive
!*\onslide<8->*!    totalCost = taxi.drive(450);
!*\onslide<8->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<9->*!    // refill & drive
!*\onslide<9->*!    taxi.refill(1.7);
!*\onslide<10->*!    totalCost = taxi.drive(450);
!*\onslide<11->*!    if (totalCost == -1) System.out.println("Not enough fuel left");
!*\onslide<11->*!    else System.out.println("Trip costs " + totalCost);
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\iffull
\rExecute{javac Taxi.java}
\begin{frame}[c,fragile]{Eine Anwendung}
\begin{itemize}[<+(1)->]
    \item \rbash[:\pause]{java Taxi}
\end{itemize}
\end{frame}
\fi

\section{Zusatzaufgabe 3/6}
\begin{frame}

\end{frame}

\iffalse
\section{Altes Präsentatio}
\subsection{Listentausch}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Listentausch, \ldots}
        \pause{}Implementieren Sie eine einfach verkettete Liste, die Integerwerte speichern kann.\pause{} Implementieren Sie eine Methode (+ Hilfsmethoden), die zwei Listenelemente anhand ihrer Indizes vertauscht.\pause{} Die Liste fängt wie ein Array bei 0 zu zählen an. Beachten Sie auch Randbedingungen, wie eine leere Liste.
    \end{aufgabe}
\end{frame}

\def\Element#1{%
    \begin{tabular}{|>{\centering}p{1em}|p{1em}|}
        \hline
            \strut#1 & \\
        \hline
    \end{tabular}%
}

\def\EndElement{
    \begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
        \hline
            \strut/\\
        \hline
    \end{tabular}
}

\newsavebox{\xx}
\sbox{\xx}{\solGet{comments}{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
    \node[inner sep=0pt] (a) at (1.5*0,0) {\Element{1}};
    \node[inner sep=0pt] (b) at (1.5*2.25,0) {\Element{2}};
    \node[inner sep=0pt] (c) at (1.5*4.5,0) {\Element{3}};
    \node[inner sep=0pt] (d) at (1.5*6.75,0) {\Element{4}};
    \node[inner sep=0pt] (e) at (1.5*8.75,0) {\EndElement};
    \foreach[remember=\i as \li (initially a)] \i in {b,c,d,e}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) to[edge label={\T{.next}}] (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }
\end{tikzpicture}}}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Wir konstruieren eine Klasse für das Element.
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<4->*!    int value;
!*\onslide<4->*!    Element next;
!*\onslide<3->*!
!*\onslide<5->*!    public Element (int value, Element next) {
!*\onslide<6->*!        this.value = value;
!*\onslide<6->*!        this.next = next;
!*\onslide<5->*!    }
!*\onslide<3->*!
!*\onslide<7->*!    // !*\usebox{\xx}*!
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, II}
\begin{itemize}[<+(1)->]
    \item Wir benötigen eine weitere Methode:
\begin{plainjava}
!*\onslide<3->*!public class Element {
!*\onslide<3->*!
!*\onslide<4->*!    // ...
!*\onslide<4->*!    public Element findBefore(int x) {
!*\onslide<5->*!        if(x > 1) { // 0 & 1
!*\onslide<6->*!            if(next != null)
!*\onslide<7->*!                return next.findBefore(x-1);
!*\onslide<8->*!            else return null; // nicht gefunden
!*\onslide<5->*!        } else return this;
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, III}
    \begin{itemize}[<+(1)->]
        \item Wir verwalten sie in einer Listenklasse:
    \begin{plainjava}
!*\onslide<3->*!public class List {
!*\onslide<4->*!    Element head;
!*\onslide<5->*!    public List() { head = null;}
!*\onslide<3->*!
!*\onslide<6->*!    public Element findBefore(int x){
!*\onslide<7->*!        if(head == null) return null;
!*\onslide<8->*!        else head.findBefore(x);
!*\onslide<6->*!    }
!*\onslide<3->*!
!*\onslide<9->*!    // ...
!*\onslide<3->*!}
    \end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, IV}
    \begin{itemize}[<+(1)->]
        \item Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
!*\onslide<3->*!public void swap(int i, int j) {
!*\onslide<3->*!    if(i == j) return; // Gleich
!*\onslide<4->*!    if(i > j) { // Aufsteigend sortiert:
!*\onslide<5->*!        int tmp = i; i = j; j = tmp;
!*\onslide<4->*!    }
!*\onslide<6->*!    Element ai = findBefore(i);
!*\onslide<7->*!    Element bj = findBefore(j);
!*\onslide<8->*!    if(ai != null && bj != null) { // In Liste
!*\onslide<9->*!        Element b = bj.next, a;
!*\onslide<10->*!        if(i == 0) a = head; // Kopf
!*\onslide<11->*!        else a = ai.next;
!*\onslide<12->*!        if(a != null && b != null) { // Exist.
!*\onslide<13->*!            if(i == 0) head = b;
!*\onslide<14->*!            else ai.next = b;
!*\onslide<15->*!            // Swap
!*\onslide<16->*!            bj.next = a;
!*\onslide<17->*!            Element tmp = a.next;
!*\onslide<18->*!            a.next = b.next; b.next = tmp;
!*\onslide<12->*!        }
!*\onslide<8->*!    }
!*\onslide<3->*!}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<19->{\centering\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }
        \draw[densely dashed,Kite-Kite] (a.north) to[bend left] (c.north);
        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{head}};

    \end{tikzpicture}\\[0.5em]}
    \onslide<20->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (a) -- ++(0,0.75) node[above] {\T{head}};

    \end{tikzpicture}}\\[0.5em]
    \onslide<21->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, V}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VI}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- (b.west);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{1}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,-0.65) -| (d.south);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,0.75) -| (a.north);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
            \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
            \fill ($(a.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
            \fill ($(c.east)+(-1em,0)$) circle (2pt);

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
            \fill ($(b.east)+(-1em,0)$) circle (2pt);

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}
    }
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung, VII}
    \begin{itemize}
        \item<1-> Nun können wir die Tauschoperation implementieren:\lstfs{7}
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
public void swap(int i, int j) {
    if(i == j) return; // Gleich
    if(i > j) { // Aufsteigend sortiert:
        int tmp = i; i = j; j = tmp;
    }
    Element ai = findBefore(i);
    Element bj = findBefore(j);
    if(ai != null && bj != null) { // In Liste
        Element b = bj.next, a;
        if(i == 0) a = head; // Kopf
        else a = ai.next;
        if(a != null && b != null) { // Exist.
            if(i == 0) head = b;
            else ai.next = b;
            // Swap
            bj.next = a;
            Element tmp = a.next;
            a.next = b.next; b.next = tmp;
        }
    }
}
    \end{plainjava}
\end{minipage}\hfill\begin{minipage}{0.475\linewidth}
    \onslide<1->{\centering{\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- (d.west);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]}
    \onslide<2->{\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
        \node[inner sep=0pt] (b) at (0,0) {\Element{2}};
        \node[inner sep=0pt] (a) at (2.25,0) {\Element{1}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \draw[-Kite] ($(a.east)+(-1em,0)$) -- ++(0,0.65) -| (d.north);
        \fill ($(a.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(c.east)+(-1em,0)$) -- ++(0,-0.65) -| ([xshift=0.25cm]b.south);
        \fill ($(c.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- (a.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
        \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
        \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
        \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
    \end{tikzpicture}}\\[0.5em]
    \onslide<3->{
        {\color{csecondary}\begin{tikzpicture}[scale=0.65,every node/.style={transform shape}]
            \node[inner sep=0pt] (c) at (0,0) {\Element{3}};
            \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
            \node[inner sep=0pt] (a) at (4.5,0) {\Element{1}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \foreach[remember=\i as \li (initially c)] \i in {b,a,d}{
                \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
                \fill ($(\li.east)+(-1em,0)$) circle (2pt);
            }

            \draw[Kite-] (a) -- ++(0,-0.75) node[below] {\T{a, ai}};
            \draw[Kite-] (b) -- ++(0,-0.75) node[below] {\T{bj, tmp}};
            \draw[Kite-] (c) -- ++(0,-0.75) node[below] {\T{b}};
            \draw[Kite-] (c) -- ++(0,0.75) node[above] {\T{head}};
        \end{tikzpicture}}
    }
\end{minipage}
    \end{itemize}
\end{frame}

\begin{frame}{Präsenzaufgabe - Lösung, VIII}
    \begin{itemize}
        \item Übung: versucht mit Hilfsmethoden wie \bjava{swapElements(Element, Element)} oder \bjava{elementsInList(Element, Element)}, \ldots{} die Struktur zu vereinfachen.
    \end{itemize}
\end{frame}

\subsection{Komplexitätsklassen}
\begin{frame}[c]{Präsenzaufgabe, 2}
    \begin{aufgabe}{It's complex, isn't it?}
        \pause{}Sie sehen gleich ein Programm, welches ein Array an Integer-Werten sortiert. Ihre Aufgaben sind die folgenden: \begin{enumerate}[<+(1)->]
            \item Schätzen Sie die Laufzeit des folgenden Codes gemäß der \(\mathcal{O}\)-Notation ab.
            \item Welchen \say{Trick} nutzt der Algorithmus?
            \item Welches Wissen über die Domäne macht sich der Algorithmus zu Nutze? Welche Nachteile bringt das mit sich?
            \item Geben Sie ein Beispiel an, für das dieser konkrete Algorithmus viel mehr Zeit braucht als notwendig!
            \item Für welche Anwendungsfälle ist der Algorithmus gut geeignet?
        \end{enumerate}
    \end{aufgabe}
\end{frame}

\begin{frame}[fragile,c]{Präsenzaufgabe, 2}
    \addtocounter{tcb@cnt@libx@box@addon@Task@normal}{-1}% :)
    \begin{aufgabe}{It's complex, isn't it?}
\lstfs{7}%
\begin{plainjava}[lineskip=3pt,aboveskip=-7pt,belowskip=-4pt]
!*\onslide<2->*!public static void sort(int min, int max, int[] arr) {
!*\onslide<3->*!    if (min > max) throw new IllegalArgumentException("Intervall [min, max]");
!*\onslide<4->*!    int[] counts = new int[max - min + 1];
!*\onslide<5->*!    for(int e : arr) {
!*\onslide<6->*!        if(!(min <= e && e <= max)) throw new IllegalArgumentException("Element außerhalb Intervall.");
!*\onslide<7->*!        counts[e - min]++;
!*\onslide<5->*!    }
!*\onslide<2->*!
!*\onslide<8->*!    int k = 0;
!*\onslide<9->*!    for(int i = 0; i < arr.length; i++) {
!*\onslide<10->*!        while(counts[k] <= 0) k++;
!*\onslide<10->*!        arr[i] = k + min;
!*\onslide<10->*!        counts[k]--;
!*\onslide<9->*!    }
!*\onslide<2->*!}
\end{plainjava}%
\vspace*{-\baselineskip}\begin{tikzpicture}[overlay,remember picture]
    \onslide<11->{\node[above left=5mm,yshift=.45cm,text width=75mm] at(current page.south east) {%
    \scriptsize\begin{enumerate}
        \item \color{gray}(Worst-Case) Laufzeit in \(\mathcal{O}\)-Notation.
        \item \color{gray}Welchen \say{Trick} nutzt der Algorithmus?
        \item \color{gray}Welches Domänenwissen nutzt der Algorithmus? Welche Nachteile hat das?
        \item \color{gray}Beispiel, das viel mehr Zeit braucht als notwendig!
        \item \color{gray}Für welche Anwendungsfälle ist er gut geeignet?
    \end{enumerate}
    };}
\end{tikzpicture}%
    \end{aufgabe}
\end{frame}

\begin{frame}[c]{Präsenzaufgabe, 2 - Lösung}
    \begin{enumerate}[<+(1)->]
        \item Die Laufzeit skaliert linear in der Länge des Arrays und der Differenz \(max - min\) (Traversierung von \T{counts}). Damit befinden wir uns in \(\mathcal{O}\bigl(\max(\text{\T{arr.length}}, (max-min))\bigr)\). \info{Das innere While wird durch \T{k} nur genau \(max - min\) oft durchlaufen.}
        \item Der Algorithmus zählt (in counts), wie oft eine Zahl im Intervall vorkommt und reproduziert so das Array \info{er ist also nicht stabil}.
        \item Er nutzt das Wissen über ganze Zahlen \(\Q\), sowie die im Array enthaltenen Extremwerte! Im Zweifelsfall kennen wir z.B. \(\max(\text{\T{arr}})\) gar nicht.
        \item Ein Array bei dem \(\text{\T{arr.length}} \ll max - min\). So wird ein unnötig großes \T{counts}-Array traversiert. Beispiel: \bjava{sort(0,42:_:000, new int[]\{3, 0, 40:_:000\})}.
        \item Arrays mit kleinem Wertebereich, welches zudem möglichst gleichverteilt alle Werte aus diesem wertebereich abdeckt.
    \end{enumerate}
\end{frame}


\section{Eine End-Enteee}
\pgfmathsetmacro{\relativefibrethickness}{0.50}
\pgfmathsetmacro{\relativefibrevariation}{0.11}
\pgfmathsetmacro{\numberoffibres}{9}
\pgfmathsetmacro{\fibresteps}{25}
\pgfmathsetmacro{\boardwidth}{10}
\pgfmathsetmacro{\boardheight}{10}
\colorlet{backgroundcolor}{brown}
\colorlet{fibrecolor}{brown!82!black}
\definecolor{shieldsilver}{HTML}{C0C0C0}
\pgfmathsetmacro{\segmentwidth}{\boardwidth/(\numberoffibres+1)}
\pgfmathsetmacro{\segmentvariation}{\relativefibrethickness/2*\segmentwidth}

\pgfmathsetmacro{\secondfibre}{2*\segmentwidth}
\pgfmathsetmacro{\lastfibre}{\numberoffibres*\segmentwidth}

\pgfmathsetmacro{\stepheight}{\boardheight/\fibresteps}
\begin{frame}[c]
    \begin{tikzpicture}[overlay,remember picture]
        \node[above left,yshift=0.45cm,scale=.9] at (current page.south east) {\tikz{\pingu[right wing wave,eyes wink,small]}};
    \end{tikzpicture}
    \begin{center}
        \begin{tikzpicture}
        % Let ducks fight... whatever? ^^
            % \node at(0,0) {\includegraphics[width=4.25cm]{Durotan.png}};
            \node[scale=2.25] at (7,0) {\begin{tikzpicture}
                \duck[invisible,water=blue!90!white]
                \begin{scope}[xshift=-1.25cm,scale=1.1]
                    \fill[gray,rotate=-24] (0.1,1.21) rectangle (1*1.1,1*1.23); % make triangle
                    \fill[gray,rotate=-24]
                        (1.2,1.22) ellipse (1*0.15 and 1*0.03) (1.08,1.22)
                        ellipse (1*0.03 and 1*0.15);
                \end{scope}
                \duck[beard=red!20!brown]
                \node[red!20!brown,rounded corners=1,scale=0.72] at (0.59,1.76) {\rotatebox{-28}{\faMinus}};
                \node[red!20!brown,rounded corners=1,scale=0.75] at (0.86,1.70) {\rotatebox{-2}{\faMinus}};
                \duck[invisible,viking=gray]

                \begin{scope}[scale=0.1,xshift=2.75cm]
                    % Shield
                    \draw[line width=2.75pt,shieldsilver] (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                    % the dots:
                    \pgfmathsetmacro\bwradius{\boardwidth/2+2.75/11 pt}
                    \foreach \i in {0,20,...,360} {
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:\bwradius) circle (3.75pt);
                    }

                    \clip (\boardwidth/2,\boardheight/2) circle (\boardwidth/2);
                    \filldraw[backgroundcolor] (0,0) rectangle ++(\boardwidth,\boardheight);

                    \foreach \x in {1,2,...,\numberoffibres}
                    {
                        \fill[fibrecolor] ($(\x*\segmentwidth-\segmentvariation,0) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        \foreach \y in {1,...,\fibresteps}
                        {   -- ($(\x*\segmentwidth-\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        }
                        -- ($(\x*\segmentwidth+\segmentvariation,\boardheight)+ (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        \foreach \y in {\fibresteps,...,0}
                        {   -- ($(\x*\segmentwidth+\segmentvariation,\y*\stepheight) + (rand*\relativefibrevariation*\relativefibrethickness,0)$)
                        }
                        -- cycle;
                    }
                    % shield post
                    \fill[shieldsilver] (\boardwidth/2,\boardheight/2) circle (46.25pt);
                    \foreach \i in {0,40,...,360} {
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2)++(\i:40.25pt) circle (3.75pt);
                    }
                    \begin{scope}
                        \fill[shieldsilver!85!black] (\boardwidth/2,\boardheight/2) circle (0.85);
                        \clip (\boardwidth/2,\boardheight/2) circle (0.85);
                        \shade[outer color=shieldsilver!85!black, inner color=shieldsilver!90!white] (\boardwidth/2-0.35,\boardheight/2+0.8) circle (1.32);
                    \end{scope}
                \end{scope}
                %\def\swordscaler{1}
                %\fill[gray,rotate=24] (0.1,0.21) rectangle (\swordscaler*1.1,\swordscaler*0.23); % make triangle
                %\fill[gray!70!black,rotate=24]
                %    (1.2,0.22) ellipse (\swordscaler*0.15 and \swordscaler*0.03) (1.08,0.22)
                %    ellipse (\swordscaler*0.03 and \swordscaler*0.15);
            \end{tikzpicture}};
        \end{tikzpicture}
    \end{center}
\end{frame}
\fi
\iffull\end{document}\fi
