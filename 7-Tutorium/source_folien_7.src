\InputIfFileExists{../global.src}\relax\relax

\iffull
\title[Siebtes Tutorium -- Übungsblatt 7]{Vom Überladen und Gesehen werden!\\\small Übergabepunkt 7}
\date{\sffamily KW 50}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{7}
\fi

% region Präsenzaufgabe
\section{Präsenzaufgabe}
\begin{frame}[fragile,c]{Präsenzaufgabe}
    \pause\begin{aufgabe}{Die Springer meiner Herzen sie umkreisen mich\ldots}
        \hfill\smash{\raisebox{1.1\baselineskip}{\llap{\tiny\color{white}\textit{Und mit jeder weitren Zeile, leide ich.~~~~~~~}}}}\vspace*{-\parskip-.75\baselineskip}\par\onslide<3->{Erstellen Sie eine \bjava{Circle}-Klasse mit privaten Instanzvariablen für Radius, Flächeninhalt und Umfang.} \onslide<4->{Definieren Sie einen öffentlichen Konstruktor der auf Basis eines Radius die Instanzvariablen initialisiert.} \onslide<5->{Erstellen Sie nun zusätzlich die Methoden:}
\begin{itemize}
    \item<6->\small \textit{Getter}-Methoden für die Instanzvariablen.
    \item<7->\small Eine Methode um die Kreiseigenschaften auf der Kommandozeile auszugeben.
    \item<8->\small Eine statische Methode, die für einen Kreisradius den Flächeninhalt zurückgibt.
    \item<9->\small Eine statische Methode, die für einen Kreisradius den Umfang zurückgibt.
\end{itemize}
\onslide<10->{\textit{Bonus:} Wäre es möglich zusätzliche Konstruktoren zu definieren, welche entweder nur den Flächeninhalt oder nur den Umfang als Parameter übernehmen?}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\MakeThePinguExplainIt[text width=7cm]{cap=!hide,vr-headset,vr-headset hair}{Anstelle von \bjava{radius * radius} geht auch \bjava{Math.pow(radius,2)} für \(\mathrm{radius}^2\).~~~Die Formeln sollten natürlich bekannt sein \Laughey.}
\newcommand<>{\mark}[1]{{\only#2{\color{black}}#1}}
\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item<2-> Das wichtigste Beiseite: \only<2->{\textattachfile{\curpath Circle.java}{Circle.java}}
        \item<3-> Wir gehen in die Analyse:\bigskip\par
\begin{columns}[c]
\column{.4\linewidth}
\small\onslide<4->{\only<5->{\color{gray}}Erstellen Sie eine \mark<6->{\only<4|handout:0>{\!\bjava{Circle}}\only<5->{\T{Circle}}-Klasse} mit \mark<10->{privaten} \mark<8->{Instanzvariablen für Radius, Flächeninhalt und Umfang}.}\medskip

\onslide<11->{\only<11>{\color{black}}\only<12->{\color{gray}}Definieren Sie einen \mark<13->{öffentlichen Konstruktor} der auf Basis eines \mark<15->{Radius} die \mark<17->{Instanzvariablen initialisiert}.}
\column{.6\linewidth}\lstfs{9}
\begin{plainjava}
!*\onslide<7->*!public class Circle {
!*\onslide<10->*!   private !*\onslide<9->*!double radius;
!*\onslide<10->*!   private !*\onslide<9->*!double area;
!*\onslide<10->*!   private !*\onslide<9->*!double circumference;
!*\onslide<10->*!
!*\onslide<14->*!   public Circle(!*\onslide<16->*!double radius!*\onslide<14->*!) {
!*\onslide<18->*!       this.radius = radius;
!*\onslide<19->*!       this.area = Math.PI * radius * radius;
!*\onslide<19->*!       this.circumference = 2 * Math.PI * radius;
!*\onslide<14->*!   }
!*\onslide<7->*!}
\end{plainjava}
\end{columns}
    \end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<20->{\node[left=-7mm,scale=.8] at(current page.5) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill Getter}
    \begin{itemize}[<+(1)->]
        \item Nun gilt es zu sondieren\ldots\pause
\lstfs{10}\SetupLstHl
\begin{plainjava}
|ihl|public class Circle {|ihl|
    |ihl|private double radius;|ihl|
    |ihl|private double area;|ihl|
    |ihl|private double circumference;|ihl|
    |ihl|:ldots:|ihl|
    |ihl|public Circle(double radius) { :ldots: }|ihl|

    !*\onslide<4->*!public double getRadius() { return radius; }
    !*\onslide<5->*!public double getArea() { return area; }
    !*\onslide<6->*!public double getCircumference() { return circumference; }
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill Dump}
    \begin{itemize}[<+(1)->]
        \item Ein printchen Liebe, ein printchen Freude\ldots\pause
\lstfs{10}\SetupLstHl
\begin{plainjava}
|ihl|public class Circle {|ihl|
    |ihl|private double radius;|ihl|
    |ihl|private double area;|ihl|
    |ihl|private double circumference;|ihl|

    |ihl|public Circle(double radius) { :ldots: }|ihl|
    |ihl|:ldots:|ihl|

    !*\onslide<4->*!public void printProperties() {
    !*\onslide<5->*!    System.out.println("Radius: " + this.radius + "cm");
    !*\onslide<6->*!    System.out.println("Fläche: " + this.area + "cm^2");
    !*\onslide<7->*!    System.out.println("Umfang: " + this.circumference + "cm");
    !*\onslide<4->*!}
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill Statische Methoden}
    \begin{itemize}[<+(1)->]
        \item Berechne Gefechte:\ldots\pause
\lstfs{10}\SetupLstHl
\begin{plainjava}
|ihl|public class Circle {|ihl|
    |ihl|private double radius;|ihl|
    |ihl|private double area;|ihl|
    |ihl|private double circumference;|ihl|

    |ihl|public Circle(double radius) { :ldots: }|ihl|
    |ihl|:ldots:|ihl|

    !*\onslide<4->*!public static double computeArea(double radius) {
    !*\onslide<5->*!    return Math.PI * radius * radius;
    !*\onslide<4->*!}
    !*\onslide<6->*!public static double computeCircumference(double radius) {
    !*\onslide<7->*!    return 2 * Math.PI * radius;
    !*\onslide<6->*!}
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill Refactoring}
    \begin{itemize}[<+(1)->]
        \item Die statischen Methoden können wir rückwirkend verwenden\ldots\pause
\lstfs{10}\SetupLstHl
\begin{plainjava}
|ihl|public class Circle {|ihl|
    |ihl|private double radius;|ihl|
    |ihl|private double area;|ihl|
    |ihl|private double circumference;|ihl|

!*\onslide<4->*!    public Circle(double radius) {
!*\onslide<4->*!        this.radius = radius;
!*\onslide<5->*!        this.area = Circle.computeArea(radius);
!*\onslide<6->*!        this.circumference = Circle.computeCircumference(radius);
!*\onslide<4->*!    }
!*\onslide<3->*!    |ihl|:ldots:|ihl|

    |ihl|public static double computeArea(double radius) { :ldots: }|ihl|
    |ihl|public static double computeCircumference(double radius) { :ldots: }|ihl|
|ihl|}|ihl|
\end{plainjava}
    \end{itemize}
\end{frame}


\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill Bonus}
    \begin{itemize}[<+(1)->]
        \item Da wir nur einen Parameter übergeben, hilft uns Overload\texttrademark\ leider nicht!\pause
\SetupLstHl%
\begin{plainjava}
|ihl|public class Circle {|ihl|
    |ihl|:ldots:|ihl|
    |ihl|public Circle(double radius) { :ldots: }|ihl|

!*\onslide<4->*!    public Circle(double area) { :ldots: }
!*\onslide<4->*!    public Circle(double circumference) { :ldots: }
!*\onslide<3->*!    |ihl|:ldots:|ihl|
|ihl|}|ihl|
\end{plainjava}
    \onslide<5->{Alle drei Konstruktoren würden durch \bjava{Circle(double)} identifiziert werden. Das erlaubt Java allerdings \textbf{nicht}.}
    \end{itemize}
\end{frame}


% \begin{frame}[t,fragile]{Präsenzaufgabe - Lösung, Exkurs}
%     \begin{itemize}[<+(1)->]
%         \item Hier eine \bjava{compareTo}-Implementation für Zeichenketten:
% \begin{plainjava}
% !*\onslide<3->*!static int compareStrings(String a, String b) {
% !*\onslide<4->*!    for(int i = 0; i < Math.min(a.length(), b.length()); i++) {
% !*\onslide<5->*!        if(a.charAt(i) != b.charAt(i))
% !*\onslide<5->*!            return a.charAt(i) - b.charAt(i);
% !*\onslide<4->*!    }
% !*\onslide<6->*!    return a.length() - b.length();  // Kürzere sind kleiner!
% !*\onslide<3->*!}
% \end{plainjava}
%     \item<7-> Diese hat ein Problem mit \bjava{null}. Wie liese sich dies lösen? \onslide<8->{\info{Dies verbleibt als Aufgabe \Laughey.}}
%     \item<9-> Ist dies die offizielle \bjava{String::compareTo}-Implementation? \onslide<10->{\info{Das hängt von der Implementation und der Java Version ab. Im Allgemeinen: fast. Die zugrundeliegende Implementation ist besser für diverse Encodings.}}
%     \end{itemize}
% \end{frame}

% \begin{frame}[t,fragile]{Präsenzaufgabe - Lösung, Exkurs}
%     \begin{itemize}[<+(1)->]
%         \item Und hier analog für Date:
% \begin{plainjava}
% !*\onslide<3->*!static int compareDates(Date a, Date b) {
% !*\onslide<4->*!    long aTime = a.getTime();
% !*\onslide<4->*!    long bTime = b.getTime();
% !*\onslide<5->*!    if(aTime == bTime) return 0;
% !*\onslide<6->*!    return aTime > bTime ? 1 : -1;
% !*\onslide<3->*!}
% \end{plainjava}
%     \item<7-> Warum geben wir hier nicht einfach die Differenz zurück? \onslide<8->{\info{Die Differenz zweier longs ist immernoch \bjava{long}. Zudem hätten wir im allgemeinen ein Überlaufproblem. Da man deswegen ohnehin nicht auf die Differenz vertrauen kann, ist es so sicherer.}}
%     \item<9-> Würde dieses Problem nicht auch bei \bjava{compareStrings} auftreten? \onslide<10->{\info{Nein, die Differenz zweier chars liefert einen Integer und entgeht damit dieser Problematik (zumindest in Java).}}
%     \end{itemize}
% \end{frame}

% endregion

\section{Übungsblatt 7}
% #region Aufgabe 1
\subsection{Aufgabe 1}
\MakeThePinguExplainIt[text width=7.9cm]{cap=!hide,hat,bow tie,right item angle=-60}{Alternativ ginge auch \bjava{digits[i] = Integer.}\\\bjava{parseInt(number.substring(i, i + 1))}}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item Man nennt mich Jörg, den Zeichenkettenspalter (\only<2->{\textattachfile{\curpath MethodOverloading.java}{MethodOverloading.java}}):
\begin{plainjava}
!*\onslide<3->*!public static int[] separateDigits(String number) {
!*\onslide<4->*!    int numDigits = number.length();
!*\onslide<5->*!    int[] digits = new int[numDigits];

!*\onslide<6->*!    for(int i = 0; i < numDigits; i++)
!*\onslide<7->*!        digits[i] = number.charAt(i) - '0';

!*\onslide<8->*!    return digits;
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<9->{\node[left=-7mm,scale=.8] at(current page.-20) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 1b)}
    \begin{itemize}[<+(1)->]
        \item Theoretisch können wir für die Verarbeitung die alte Methode benutzen:
\begin{plainjava}
!*\onslide<3->*!public static int[] separateDigits(int number) {
!*\onslide<4->*!    return separateDigits(Integer.toString(number));
!*\onslide<3->*!}
\end{plainjava}
        \item<5-> Das widerspricht aber der Aufgabenbeschreibung! Deswegen klammern wir uns an den ursprünglichen Wunsch\ldots
    \end{itemize}
\end{frame}

\MakeThePinguExplainIt[text width=11.66cm]{cap=!hide,hat,bow tie,right item angle=-65,small}{Betrachte \(n = 476 = \mathbf{4} \cdot 10^2 + \mathbf{7} \cdot 10^1 + \mathbf{6} \cdot 10^0\).\medskip\\
\(n / 10 = \mathbf{4} \cdot 10^{\mathbf{2-1}} + \mathbf{7} \cdot 10^{\mathbf{1-1}} + \mathbf{6} \cdot 10^{\mathbf{0-1}} = 47.6\)\\
\(n \bmod 10 = {\color{pingu-board-green!65!white}\mathbf{4} \cdot 10^{2}} + {\color{pingu-board-green!65!white}\mathbf{7} \cdot 10^{1}} + \mathbf{6} \cdot 10^{0} = 6\)\\
\(\log_{10} n = \log_{10}(\mathbf{4} \cdot 10^2 + \mathbf{7} \cdot 10^1 + \mathbf{6} \cdot 10^0) \approx_{\max} \log_{10}(\mathbf{4} \cdot 10^2) \approx 2.6 \)\medskip\\
Kleinste Ziffer: \(z = n \bmod 10\), Zahl ohne kleinste Ziffer: \(z = \floor{\frac{n}{10}}\). Anzahl Ziffern:
\(z = \floor{\log_{10} \abs{n} + 1}\) (beachte: \(0\)). Was ist mit \(100\)? Mit \(1000\)?}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 1b)}
    \begin{itemize}[<+(1)->]
        \item Deswegen implementieren wir das Ganze so:
\begin{plainjava}
!*\onslide<3->*!public static int[] separateDigits(int number) {
!*\onslide<4->*!    int numDigits = (int) (Math.log10(number) + 1);
!*\onslide<4->*!    int[] digits = new int[numDigits];

!*\onslide<5->*!    for (int i = numDigits - 1; i >= 0; i--) {
!*\onslide<6->*!        digits[i] = number % 10;
!*\onslide<6->*!        number /= 10;
!*\onslide<5->*!    }
!*\onslide<7->*!    return digits;
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<8->{\node[left=-7mm,scale=.65] at(current page.-21) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}


\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 1c)}
    \begin{itemize}[<+(1)->]
        \item Es ist \textbf{nicht} möglich, die zweite Methode mit \bjava{public static byte[] separateDigits(String number)} zu erzeugen.
        \item Warum?
        \item Die Signatur \bjava{separateDigits(String)} enthält (in Java) \emph{nicht} den Rückgabetyp. \onslide<5->{Daher, sind für Java beide Methoden nicht zu unterscheiden. Dies wird vom Java-Standard verboten.}
    \end{itemize}
\begin{tikzpicture}[remember picture,overlay]
    \onslide<6->{\node[above left=.35cm,yshift=.55cm,draw=gray,rounded corners=1pt,fill=shadeA!15!white,align=left,thick,font=\small] at(current page.south east) {\textbf{Method-Signature}:\\Name und Parametertypen\smallskip\\\textbf{Overloading / Überladung}:\\Gleicher Name, andere Signatur};}
\end{tikzpicture}
\end{frame}
% #endregion

% #region Aufgabe 2
\newsavebox\surferpingu
\savebox\surferpingu{%
\begin{tikzpicture}
\pgfonlayer{background}
    \fill[paletteB!80!pingu@white] (.9375cm,-14.75mm) ellipse[x radius=16mm,y radius=3.25mm];
\endpgfonlayer
    \pingu[wings wave,eyes wink,headband,body type=chubby];
\end{tikzpicture}}
\subsection{Aufgabe 2}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 2}
    \begin{itemize}[<+(1)->]
        \item<2-> Die Ausgabe eines Programms verstehen:\bigskip\par
\begin{columns}[c]
\column{.68\linewidth}\lstfs{8}
\begin{plainjava}
public class VariableScope {
    static int a = 23;!*\tikzmark{global_a}*!
    static int b = 47;!*\tikzmark{global_b}*!
    !*\tikzmark{print}*!public static void print() {
        System.out.println("a=" + !*\rlap{\tikzmarknode{start-global_a}{\phantom{a}}}*!a + ", b=" + !*\rlap{\tikzmarknode{start-global_b}{\phantom{b}}}*!b + "\n");
    }
    !*\tikzmark{print_int_int}*!public static void print(int !*\tikzmark{local_a}*!a, int !*\tikzmark{local_b}*!b) {
        System.out.println("a=" + !*\rlap{\tikzmarknode{start-local_a}{\phantom{a}}}*!a + ", b=" + !*\rlap{\tikzmarknode{start-local_b}{\phantom{b}}}*!b + "\n");
    }
    public static void main(String[] args) {
        int !*\rlap{\tikzmarknode{main_a}{\phantom{a}}}*!a = 17, !*\rlap{\tikzmarknode{main_b}{\phantom{b}}}*!b = 24;
        !*\tikzmark{start-print}*!print();
        !*\tikzmark{start-print_int_int}*!print(!*\rlap{\tikzmarknode{start2-main_a}{\phantom{a}}}*!a, !*\rlap{\tikzmarknode{start2-main_b}{\phantom{b}}}*!b);
        System.out.println("a=" + !*\rlap{\tikzmarknode{start-main_a}{\phantom{a}}}*!a + ", b=" + !*\rlap{\tikzmarknode{start-main_b}{\phantom{b}}}*!b);
    }
}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture,gray]
    \only<4->{\draw[-Kite] ([yshift=2pt,xshift=-2pt]pic cs:start-print) to[bend left=52] ([yshift=2pt,xshift=-2pt]pic cs:print);}

    \only<5->{\draw[-Kite] ([yshift=2pt,xshift=-2pt]start-global_a.north) to[bend right=28] ([yshift=3pt,xshift=2pt]pic cs:global_a);
    \draw[-Kite] ([yshift=2pt,xshift=-2pt]start-global_b.north) to[bend right=11]  coordinate[pos=.45] (pingu-p) ([yshift=3pt,xshift=2pt]pic cs:global_b);
        \node[above right=-1pt,scale=.14,rotate=-10] at (pingu-p) {\usebox\surferpingu};
    }

    \only<7->{\draw[-Kite] ([yshift=2pt]start2-main_a.north) to[out=128,in=285] ([yshift=-1pt]main_a.south);
    \draw[-Kite] ([yshift=2pt]start2-main_b.north) to[out=52,in=242] ([yshift=-1pt]main_b.south);}
    \only<8->{\draw[-Kite] ([yshift=2pt,xshift=-2pt]pic cs:start-print_int_int) to[bend left=52] ([yshift=2pt,xshift=-2pt]pic cs:print_int_int);}
    \only<9->{
        \draw[-Kite] ([yshift=2pt,xshift=3pt]start-local_a.north) to[bend right=28] ([yshift=3pt,xshift=4.5pt]pic cs:local_a);
        \draw[-Kite] ([yshift=2pt]start-local_b.north) to[bend right=10] ([yshift=3pt,xshift=4.5pt]pic cs:local_b);}
    \only<11->{\draw[-Kite] ([yshift=2pt]start-main_a.north) to[out=162,in=335] ([yshift=3pt,xshift=4pt]pic cs:main_a);
    \draw[-Kite] ([yshift=2pt]start-main_b.north) to[out=162,in=335] ([yshift=3pt,xshift=4pt]pic cs:main_b);}
\end{tikzpicture}
\column{.28\linewidth}
\begin{plainvoid}
!*\onslide<6->*!a=23, b=47!*\NLMarker*!
!*\onslide<6->*!!*\NLMarker*!
!*\onslide<10->*!a=17, b=24!*\NLMarker*!
!*\onslide<10->*!!*\NLMarker*!
!*\onslide<12->*!a=17, b=24!*\NLMarker*!
!*\onslide<12->*!!*\NLMarker*!
\end{plainvoid}
\end{columns}
\begin{tikzpicture}[remember picture,overlay]
    \onslide<13->{\node[below left=.45cm,yshift=-1.325cm,draw=gray,rounded corners=1pt,fill=shadeA!15!white,align=left,thick,font=\small] at(current page.north east) {\textbf{Shadowing / Überschatten}:\\\textcolor{gray}{[vielseitig, z.B.]} lokale Variable mit\\gleichem Namen wie globale.};} % \neq hiding
\end{tikzpicture}
    \end{itemize}
\end{frame}


\MakeThePinguExplainIt[text width=7cm]{cap=!hide,headphone=paletteB,right item angle=-25}{Ich verwende \say{\NLMarker} um eine neue Zeile zu markieren. Auch dann, wenn ich sie nicht im Text formatiere.}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 2\hfill In Worten}
    \begin{itemize}[<+(1)->]
        \item Wir erhalten \say{\bjava{a=23, b=47}\T{\NLMarker\NLMarker}} durch den Aufruf von \bjava{print()}, welcher die Werte der zwei statischen globalen Variablen ausgibt, da diese nicht \textbf{überschattet} werden.
        \item \say{\bjava{a=17, b=24}\T{\NLMarker\NLMarker}} erhalten wir durch \bjava{print(int a, int b)} welches durch die Namen der Parameter die globalen Variablen \bjava{a} und \bjava{b} überschattet. Die Parameter sind an die lokalen Variablen in \bjava{VariableScope::main} gebunden, wo sie ebenfalls die globalen Variablen \textbf{überschatten}.
        \item Analog erhalten wir \say{\bjava{a=17, b=24}\T{\NLMarker\NLMarker}} durch die eben angesprochene \textbf{Überschattung} in \bjava{VariableScope::main}.
    \end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<5->{\node[left=-7mm,scale=.8] at(current page.-25) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}
% #endregion

% #region Aufgabe 3
\subsection{Aufgabe 3}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 3\hfill Musterlösung}
    \begin{itemize}[<+(1)->]
        \item Die zwei Integer Variablen \bjava{a} und \bjava{b} haben nach dem Aufruf der \bjava{swap} Methode die selben Werte wie davor. Das liegt daran, dass in Java alle Parameter \textit{by value} übergeben werden, somit findet der Tausch der Werte in der \bjava{swap} Methode auf einer Kopie der Variablen statt.
        \item Die Werte der Array Variablen \bjava{c} und \bjava{d} sind nach dem Aufruf der \bjava{swap} Methode jedoch getauscht. Dies liegt daran, dass hier nur die Referenz auf das Array \textit{by value} übergeben wird, welche nicht verändert werden kann. Beim Zugriff auf die Arrays, werden jedoch die originalen Werte und keine Kopien geliefert, und somit können diese verändert werden.
    \end{itemize}
\end{frame}

\makeatletter
\lhns@elemwidth3cm
\lhns@minborderheight8cm
\makeatother
\newcommand<>\lm[1][]{\only#2{#1\llap{\tikz\fill[paletteB!60!white] circle [radius=2.25pt];\;}}}
\begin{frame}[t,fragile]{Übungsblatt 7 - Aufgabe 3}
\vspace*{-\topsep}\begin{columns}[onlytextwidth,c]
\lstfs{9}\column{.6\linewidth}
\begin{plainjava}
!*\onslide<2->*!public class SwapFunction {
!*\onslide<2->*!    !*\lm<10|handout:0>*!public static void swap(int a, int b) {
!*\onslide<2->*!        !*\lm<11|handout:1>*!int tmp = b; b = a; a = tmp;
!*\onslide<2->*!    }
!*\onslide<2->*!    !*\lm<15-16|handout:3>*!public static void swap(int[] a, int[] b) {
!*\onslide<2->*!        !*\lm<17|handout:0>*!if(a.length != b.length) return;
!*\onslide<2->*!        !*\lm<18,21,23,25|handout:0>*!for(int i = 0; i < a.length; i++) {
!*\onslide<2->*!            !*\lm<19-20,22,24|handout:0>*!int tmp = b[i]; b[i] = a[i]; a[i] = tmp;
!*\onslide<2->*!        }!*\lm<26|handout:4>[~~]*!
!*\onslide<2->*!    }
!*\onslide<2->*!    !*\lm<3|handout:0>*!public static void main(String[] args) {
!*\onslide<2->*!        !*\lm<4|handout:0>*!int a = 21; int b = 42;
!*\onslide<2->*!        !*\lm<5-6|handout:0>*!int[] c = {1, 2, 3};
!*\onslide<2->*!        !*\lm<7|handout:0>*!int[] d = {4, 5, 6};
!*\onslide<2->*!        !*\lm<8-9|handout:0>*!swap(a, b);!*\lm<12|handout:2>[~~]*!!*\onslide<9|handout:1>*! // :yields: swap(int, int)
!*\onslide<2->*!        !*\lm<13-14|handout:0>*!swap(c, d);!*\lm<27|handout:0>[~~]*!!*\onslide<14|handout:3>*! // :yields: swap(int[], int[])
!*\onslide<2->*!    }
!*\onslide<2->*!}
\end{plainjava}
\column{.4\linewidth}
\vspace*{-\baselineskip}\centering
\downsize\linewidth{\begin{tikzpicture}[lhns@basestyle/.append style={execute at begin node=\strut,font=\ttfamily},lhns@blockstyle/.append style={draw=gray,thick}]
\begin{heap-n-stack}{}

\heap{\only<-5|handout:0>{-heapland-}\only<6->{\,\{\only<-19|handout:-3>{1}\only<20-|handout:4->{4}, \only<-21|handout:-3>{2}\only<22-|handout:4->{5}, \only<-23|handout:-3>{3}\only<24-|handout:4->{6}\}}}
\only<7->{\heap{\,\{\only<-19|handout:-3>{4}\only<20-|handout:4->{1}, \only<-21|handout:-3>{5}\only<22-|handout:4->{2}, \only<-23|handout:-3>{6}\only<24-|handout:4->{3}\}}}
\renderheap

\only<3->{\stack{\textbf{main}}}
\only<4->{\stack{a = 21}}
\only<4->{\stack{b = 42}}
\only<5->{\stack{c}}
\only<7->{\stack{d}}
\only<10-11|handout:1>{\stack{\small\textbf{swap(int, int)}}
\stack{a = \only<10|handout:0>{21}\only<11>{42}}
\stack{b = \only<10|handout:0>{42}\only<11>{21}}
\only<11>{\stack{tmp = 42}}}
\only<15-26|handout:3>{\stack{\scriptsize\textbf{swap(int[], int[])}}
\stack{a}
\stack{b}
\only<16->{\draw[lhns] (stack-6.east) -- ++(.5,0) to[out=0,in=180] (heap-0.west);
\draw[lhns] (stack-7.east) -- ++(.5,0) to[out=0,in=192] (heap-1.west);}
}
\only<18-25|handout:0>{\stack{i = \only<18-20|handout:0>{0}\only<21-22|handout:0>{1}\only<23-24|handout:0>{2}\only<25|handout:0>{3}}}
\only<19-20,22,24|handout:0>{\stack{tmp = \only<19-20>{4}\only<22>{5}\only<24>{6}}}
\renderstack

\only<6->{\draw[lhns] (stack-3.east) to[out=0,in=180] (heap-0.west);}
\only<7->{\draw[lhns] (stack-4.east) to[out=0,in=180] (heap-1.west);}

\end{heap-n-stack}
\end{tikzpicture}}
\end{columns}
\end{frame}
% #endregion

% #region End Pingu
\definecolor{coffe}{RGB}{112,43,9}%
\definecolor{smokegray}{RGB}{222,219,219}%
\newsavebox{\smoke}\savebox{\smoke}{%
\begin{tikzpicture}
    \fill[smokegray,fill opacity=0.87] (0,0) .. controls (1.5,1.5)  and (-0.8,2) .. (0.35,3.5) .. controls (-1.45,2)  and (0.8,1.5) .. cycle;
    \begin{scope}[xshift=3.25em,yshift=-0.25em]
    \fill[smokegray,fill opacity=0.87] (-0.25,1.75) .. controls (-1,2.8)  and (0.64,3.3) .. (-0.65,4) .. controls (0.25,3.25) and (-1.75,3.3) .. cycle;
    \end{scope}
\begin{scope}[xshift=-2.5em,yshift=-3em]
    \fill[smokegray,fill opacity=0.87] (-0.25,1.75) .. controls (-1,2.8)  and (0.64,3.3) .. (-0.65,4) .. controls (0.25,3.25) and (-1.75,3.3) .. cycle;
    \end{scope}
\end{tikzpicture}}
\newsavebox{\calc}
\savebox{\calc}{%
\begin{tikzpicture}[e/.style={rectangle,rounded corners=1.8pt,fill=lightgray!85!white,minimum width=1.25em,minimum height=1.25em,font=\footnotesize}]
    \draw[rounded corners=4pt,fill=white] (0-0.15,-0.05) rectangle ++(2.6,3.5);
    % cp xd
    \node[e] at(0.25,0.33) {.}; \node[e] at(0.25+0.6,0.33) {0};
    \node[e,fill=shadeA] at(0.25+2*0.6,0.33) {=};
    \node[e] at(0.25+3*0.6,0.33) {+};
    \node[e] at(0.25,0.33+0.6) {1}; \node[e] at(0.25+0.6,0.33+0.6) {2};
    \node[e] at(0.25+2*0.6,0.33+0.6) {3};
    \node[e] at(0.25+3*0.6,0.33+0.6) {\raisebox{-1pt}{--}};
    \node[e] at(0.25,0.33+2*0.6) {4}; \node[e] at(0.25+0.6,0.33+2*0.6) {5};
    \node[e] at(0.25+2*0.6,0.33+2*0.6) {6};
    \node[e] at(0.25+3*0.6,0.33+2*0.6) {$\times$};
    \node[e] at(0.25,0.33+3*0.6) {7}; \node[e] at(0.25+0.6,0.33+3*0.6) {8};
    \node[e] at(0.25+2*0.6,0.33+3*0.6) {9};
    \node[e] at(0.25+3*0.6,0.33+3*0.6) {$\div$};
    \node[e,fill=lightgray!20!white,minimum width=6em,minimum height=2em,above=1em] (field) at(0.25+1.5*0.6,0.33+3*0.6) {};
    \node[below right,scale=0.7] at(field.north west) {{getKey(A,\,B);}};
    \node[above left,scale=0.8] at(field.south east) {\textsf{5}};
\end{tikzpicture}}
\newsavebox{\alice}\savebox{\alice}{%
    \begin{tikzpicture}
        \pingu[name=alice,right wing grab,cup straw=!hide,cup=paletteA]
        \node[scale=0.115,yshift=-4pt,xshift=-10pt,yscale=0.9] at(alice-bill) {\usebox{\smoke}};
    \end{tikzpicture}
}%
\newsavebox{\bob}\savebox{\bob}{%
    \begin{tikzpicture}
        \pingu[name=bob,right eye wink,sign post right={\raisebox{10pt}{\scalebox{0.65}{\parbox{1.2cm}{\centering\small I \textcolor{pingu@red!90!black}{\faHeart}\\[-0.1cm]\color{white}\LaTeX\\[-0.65cm]}}}}]
    \end{tikzpicture}
}%
\newsavebox{\eve}\savebox{\eve}{%
    \begin{tikzpicture}
        \pingu[name=eve,right wing hug,sunglasses,eyes angry]
        \node[pingu@black!80!purple] at (eve-belly-center) {\faWindows}; \begin{pgfinterruptboundingbox}\node[scale=0.25,rotate=13,yshift=1.4em,xshift=0.1em] at (eve-wing-right-tip) {\usebox{\calc}};\end{pgfinterruptboundingbox}
    \end{tikzpicture}
}%
\section{Der End-Pinguuuu}
\begin{frame}[c]
   \vspace*{3em}\par\pause\centering
\scalebox{1.25}{\begin{tikzpicture}
    \node[scale=.55] at(0,0)      (alice) {\usebox{\alice}};
    \node[scale=.55] at(7,0)      (bob)   {\usebox{\bob}};
    \node[scale=.55] at(3.5,-2.5) (eve)   {\usebox{\eve}};
    \draw[-Kite,transform canvas={yshift=0.33em}] (alice.east) node[above right] {\(A = 14\)} -- (bob.west);
    \draw[Kite-,transform canvas={yshift=-0.33em}] (alice.east) -- (bob.west)  node[below left] {\(B = 12\)};
    \draw[densely dashed] (eve.north) -- ++(0,2);
    \node[below,xshift=-0.4em] at (alice.south) {Alice};
    \node[below,xshift=-0.7em] at (bob.south) {Bob};
    \node[below] at (eve.south) {Eve};
\end{tikzpicture}}\par
\end{frame}
% #endregion
\iffull\end{document}\fi