\InputIfFileExists{../global.src}\relax\relax

\iffull
\def\smlll{\texorpdfstring{\def\RSsmallest{2pt}\smaller[2]}{}}
\title[Zwölftes Tutorium -- Übungsblatt 12]{Baum --- Traum --- Zauuuun --- Sieg\\\small Tutorium 12}
\date{\sffamily KW 6}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{12}
\fi

\section{Präsenzaufgabe}
\newsavebox\donotmesswithbeateagain \savebox\donotmesswithbeateagain{%
\pgfdeclarelayer{very-background}%
\pgfsetlayers{very-background,background,main,middle,foreground}%
\colorlet{darkdevil}{pingu@red!80!pingu@black}%
\begin{tikzpicture}%
\pingu[body=pingu@black,right eye devil=darkdevil,left eye angry,devil horns=darkdevil,devil fork right,eye patch left,halo=darkdevil,halo raise=5.44mm,cape=darkdevil,cloak padding=3mm,bow tie=darkdevil,left wing raise,name=beate,bow tie offset=5mm];

\node[above,darkdevil,opacity=0.25,scale=1.96,yshift=-0.65pt] (w) at(beate-wing-left-tip) {\faWindows};
\node[above,darkdevil,scale=1.8] (w) at(beate-wing-left-tip) {\faWindows};

\begin{pgfonlayer}{very-background}
    \scope[transparency group,opacity=.2]
    \coordinate (low-heart) at ([yshift=-0.65cm]beate-belly-center);
    \begin{scope}[canvas is zx plane at y=0]
        \foreach[count=\i] \a in {0,72,...,359} {
            \path (low-heart)++(\a-25:2.5cm) coordinate (pent-\i);
        }
        \draw[darkdevil,ultra thick,opacity=0.2] (pent-1) -- (pent-3) -- (pent-5) -- (pent-2) -- (pent-4) -- (pent-1);
        \draw[darkdevil,ultra thick,opacity=0.2] (low-heart) circle[radius=2.65cm];
        \draw[darkdevil,thick] (pent-1) -- (pent-3) -- (pent-5) -- (pent-2) -- (pent-4) -- (pent-1);
        \draw[darkdevil,thick] (low-heart) circle[radius=2.65cm];
        \draw[darkdevil,decoration={text along path,text={|\rotnfamily\tiny|THIS IS SO GOOD, WE HAVE SOOO MUCH FUN, DON'T WE? LOVE XOXO THIS IS FLO HATIN EVERYTHING AGAIN I AM DOING THIS THE SECOND TIME BUT WHO IS COUNTING I GUESS?},text color={darkdevil},reverse path=true},decorate] (low-heart) circle[radius=2.7cm];
    \end{scope}
    \endscope
\end{pgfonlayer}
\end{tikzpicture}}
\colorlet{darkdevil}{pingu@red!80!pingu@black}%
\newsavebox\donotmesswithbeateagainmask \savebox\donotmesswithbeateagainmask{%
\begin{tikzpicture}
    \pingu[body=pingu@black,right eye wink,left eye angry,devil fork right,eye patch left,halo,halo raise=5.44mm,cape=darkdevil,cloak padding=3mm,bow tie=darkdevil,left wing raise,name=beate2,mask,bow tie offset=5mm];
    \node[above,paletteD,opacity=0.25,scale=1.96,yshift=-0.65pt] (w) at(beate2-wing-left-tip) {\faLinux};
    \node[above,paletteD,scale=1.8] (w) at(beate2-wing-left-tip) {\faLinux};
\end{tikzpicture}
}
\begin{frame}[c,fragile]{Präsenzaufgabe}
    \begin{aufgabe}{Ich binde mich gleich doppelt an dich}
        \footnotesize\onslide<2->{In dieser Aufgabe sollen Sie ihre ersten Erfahrungen mit Java Interfaces machen. \tikzmarknode[outer sep=2pt]{moodle}{Im Moodle} finden Sie als Vorlage für diese Aufgabe die Klasse \bjava[morekeywords={[3]{DoublyLinkedList}}]{DoublyLinkedList} welche eine doppelt-verkettete Liste repräsentiert die Integer Werte speichern kann, sowie das Interface \bjava[morekeywords={[3]{SeekAndRemove}}]{SeekAndRemove}, welches drei verschiedene Methoden definiert um Elemente in der Liste zu suchen und diese zu Entfernen.}
        \begin{itemize}
            \item<3-> Die Methode \bjava{public void removeFirst(int value)} soll die Liste beginnend beim vordersten Element durchsuchen, und das erste Element entfernen welches den als Parameter übergebenen Wert hat.
            \item<3-> Die Methode \bjava{public void removeLast(int value)} soll die Liste beginnend beim hintersten Element durchsuchen, und das erste Element entfernen welches den als Parameter übergebenen Wert hat.
            \item<3-> Die Methode \bjava{public void removeFirst(int value)} soll alle Elemente entfernen die den als Parameter übergebenen Wert haben.
        \end{itemize}
        \onslide<4->{Sie sollen nun dieses Interface in der vorgegebenen Klasse \bjava[morekeywords={[3]{DoublyLinkedList}}]{DoublyLinkedList} implementieren.

        \textbf{Hinweis:} Sie können sich eine separate Hilfsmethode definieren um Elemente aus der Liste zu entfernen. Dies hilft redundanten Code in den Implementierungen der Methoden zu vermeiden.}
        \onslide<1->
    \end{aufgabe}
    \begin{tikzpicture}[overlay,remember picture]
        \onslide<5->{
            \clip[rounded corners=2pt] (moodle.south east) rectangle (moodle.north west) [invclip];
            \fill[black,opacity=0.8] (current page.south east) rectangle (current page.north west);
        }
        \onslide<6|handout:0>{\node at (current page.center) {\usebox\donotmesswithbeateagain};}
        \onslide<7->{\node (@) at (current page.center) {\usebox\donotmesswithbeateagainmask}; \node[below,paletteD] at (@.south) {Wear your mask!};}
    \end{tikzpicture}
\end{frame}

\newsavebox\interfacebox \savebox\interfacebox{%
\minipage{9cm}
\begin{plainjava}[morekeywords={[3]{DoublyLinkedList,SeekAndRemove}},aboveskip=0pt,belowskip=0pt]^^J
public interface SeekAndRemove {^^J
    // Entferne erstes Element mit Wert <v>^^J
    public void removeFirst(int v);^^J
    // Entferne letztes Element mit Wert <v>^^J
    public void removeLast(int v);^^J
    // Entferne alle Elemente mit Wert <v>^^J
    public void removeAll(int v);^^J
}^^J
\end{plainjava}
\endminipage}
\begin{frame}[c,fragile]{Präsenzaufgabe}
    \SetupLstHl\begin{aufgabe}{Ich binde mich gleich dreifach-doppelt an dich}
        \vspace*{-5mm}\par\footnotesize\onslide<2->{Gegeben sei die \bjava[morekeywords={[3]{DoublyLinkedList}}]{DoublyLinkedList}-Klasse. Implementieren Sie das Interface \bjava[morekeywords={[3]{SeekAndRemove}}]{SeekAndRemove}:
        }
\begin{onlyenv}<3|handout:0>
\begin{plainjava}[morekeywords={[3]{DoublyLinkedList,SeekAndRemove}}]
public class DoublyLinkedList implements SeekAndRemove {
    private class Element {
        public final int value;
        public Element prev = null, next = null;
        public Element(int value, Element prev, Element next) {
            this.value = value; this.prev = prev; this.next = next;
        }
    }

    private Element head = null;
    private Element tail = null;
    private int length = 0;

    public DoublyLinkedList() { }

    public void addFront(int value) {
        Element element = new Element(value, null, this.head);
        if(length == 0) this.tail = element;
        else this.head.setPrevElement(element);

        this.head = element;
        length++;
    }

    public void addBack(int value) {
        Element element = new Element(value, tail, null);
        if(length == 0) this.head = element;
        else this.tail.setNextElement(element);

        this.tail = element;
        length++;
    }
}
\end{plainjava}
\end{onlyenv}
\begin{onlyenv}<4->
\begin{plainjava}[morekeywords={[3]{DoublyLinkedList,SeekAndRemove}},aboveskip=3pt,belowskip=0pt]
public class DoublyLinkedList implements SeekAndRemove {
    |ihl|class Element { final int value; Element prev = null, next = null; }|ihl|

    private Element head, tail = null;
    private int length = 0;

    |ihl|public DoublyLinkedList() { }|ihl|
    |ihl|public void addFront(int value) { :ldots: }|ihl|
    |ihl|public void addBack(int value) { :ldots: } |ihl|
}
\end{plainjava}
\end{onlyenv}
    \onslide<5->{Hilfsmethoden sind erlaubt. Diese können hier auch\\helfen, redundanten Code zu vermeiden.}
        \onslide<1->
    \end{aufgabe}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<6->{\node[above left,draw=gray,very thick,fill=white,rounded corners=2pt,scale=.75,yshift=1.4cm,xshift=-.25cm] at(current page.south east) {\usebox\interfacebox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Wir schreiben eine Methode, die ein Element gegeben der Referenz entfernt:
\begin{plainjava}
!*\onslide<3->*!private void removeElement(Element element) {
!*\onslide<4->*!    if(element == null || length == 0) return; // Nichts zu tun
!*\onslide<3->*!
!*\onslide<5->*!    if(element == this.head) this.head = element.next; // Erstes
!*\onslide<5->*!    if(element == this.tail) this.tail = element.prev; // Letztes
!*\onslide<3->*!
!*\onslide<6->*!    if(element.prev != null) // überspringe prev
!*\onslide<6->*!        element.prev.next = element.next;
!*\onslide<7->*!    if(element.next != null) // überspringe next
!*\onslide<7->*!        element.next.prev = element.prev;
!*\onslide<8->*!    length--;
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe - Lösung\hfill removeFirst(int)}
    \begin{itemize}[<+(1)->]
        \item Jetzt ist die Erfüllung des Interfaces leicht (\only<2->{\textattachfile{\curpath SeekAndRemove.java}{SeekAndRemove.java}} und \only<2->{\textattachfile{\curpath DoublyLinkedList.java}{DoublyLinkedList.java}}):
\begin{plainjava}
!*\onslide<3->*!public void removeFirst(int value) {
!*\onslide<4->*!    Element current = head; // von vorne nach hinten:ldots:
!*\onslide<4->*!    while(current != null) {
!*\onslide<5->*!        if(current.value == value) {
!*\onslide<6->*!            removeElement(current);
!*\onslide<6->*!            break;
!*\onslide<5->*!        }
!*\onslide<4->*!        current = current.next;
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Präsenzaufgabe - Lösung\hfill removeLast(int)}
\begin{plainjava}
!*\onslide<2->*!public void removeLast(int value) {
!*\onslide<3->*!    Element current = tail; // von hinten nach vorne:ldots:
!*\onslide<3->*!    while(current != null) {
!*\onslide<4->*!        if(current.value == value) {
!*\onslide<5->*!            removeElement(current);
!*\onslide<5->*!            break;
!*\onslide<4->*!        }
!*\onslide<3->*!        current = current.prev;
!*\onslide<3->*!    }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Präsenzaufgabe - Lösung\hfill removeAll(int)}
\begin{plainjava}
!*\onslide<2->*!public void removeAll(int value) {
!*\onslide<3->*!    Element current = head; // von wo nach wo ist egal
!*\onslide<3->*!    while(current != null) {
!*\onslide<4->*!        if(current.value == value)
!*\onslide<4->*!            removeElement(current);
!*\onslide<2->*!
!*\onslide<3->*!        current = current.next;
!*\onslide<3->*!    }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\section{Übungsblatt 12}
\subsection{Aufgabe 1}
\iffull
\begin{frame}[c]{Übungsblatt 12 - Aufgabe 1}
    \scriptsize \onslide<2->{In dieser Aufgabe sollen Sie ihre eigenen binären Bäume aus Arrays wachsen lassen und diese anschließend in der Breite durchlaufen. Hierfür finden Sie im Moodle neben diesem Übungsblatt zwei weitere Java Files, die Sie für ihre Implementierung verwenden dürfen. Verwenden Sie ansonsten keine vorgefertigten dynamischen Datenstrukturen!}
    \begin{enumerate}
    \item<3-> Erstellen Sie eine Klasse \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{BinaryTree} mit einer Instanzvariable \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{private IntegerNode root}, welche die Wurzel des binären Baumes repräsentieren soll. Definieren Sie nun einen Konstruktor, welcher ein Array aus Integer Werten als Parameter übernimmt und daraus einen balancierten binären Baum erzeugt. Für die Speicherung der Knoten können Sie die vorgegeben Klasse \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{IntegerNode} verwenden, welche der einfach verketteten Version aus der Vorlesung von Folie X.68 entspricht. Bei der Vorlage sind die Instanzvariablen allerdings gekapselt, so dass Sie diese über die getter und setter Methoden ansprechen müssen.
    \item<3-> Nun sollen Sie die Methode \bjava{public void breadthFirstTraversal()} implementieren, welche den Baum in der Breite durchläuft und die Werte der einzelnen Knoten ausgibt. Hierfür werden Sie die vorgegebene Klasse \bjava{Queue} benötigen, welche \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{IntegerNode} Elemente einreihen kann.
    \end{enumerate}
    \onslide<4->{\textit{Hinweis:} Sollten Sie die erste Teilaufgabe nicht komplett lösen können, erzeugen Sie sich manuell einen binären Baum um ihre Implementierung der Breitensuche zu testen.}
    \vspace*{-2.33mm}
    \onslide<5->{\begin{center}
        \def\arraystretch{1.75}
        \scalebox{.875}{\begin{tabular}{|*6{>{\centering\arraybackslash}p{1.33em}|}}
            \hline
            9 & 1 & 7 & 3 & 6 & 5 \\
            \hline
        \end{tabular}\quad\(\longrightarrow\)\quad\raisebox{-.5\height}{\begin{forest}
            for tree={dot, l sep=.15ex}
            [9[1[3][6]][7[5][,phantom]]]
        \end{forest}}}
    \end{center}}
\end{frame}
\begin{frame}[c]{Exkurs: Ein wenig fantastische Heaps gefällig?}
\onslide<2->{\centering\heap{%
    [42,name=root[19,name=inner1[7,name=inner2[3,name=leaf1][-2,name=leaf2]][8,name=leaf3]][-5,name=inner3[-9,name=leaf4]]]%
    \onslide<3->{\fill[paletteA,rounded corners=.4pt] (root.north)++(-.75mm,2mm-.75mm) rectangle ++(1.5mm,1.5mm) [radius=2.15pt] node[left=1.65mm+.75mm,paletteA,font=\bfseries] (dr) {Wurzel};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (dr.south) {root};}
    \pgfinterruptboundingbox
    \onslide<4->{\fill[paletteB] (inner1.north)++(0,2mm) circle [radius=2.15pt] node[left=1.65mm,paletteB,font=\bfseries] (di) {Innerer Knoten};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (di.south) {inner node};
    \foreach\i in {2,3} {\fill[paletteB] (inner\i.north)++(0,2mm) circle [radius=2.15pt];}}
    \onslide<5->{\fill[paletteD] (leaf1.west)++(-2mm,0) circle [radius=2.15pt] node[left=1.65mm,paletteD,font=\bfseries] (dl) {Blatt};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (dl.south) {leaf};
    \foreach\i in {2,3,4} {\fill[paletteD] (leaf\i.west)++(-2mm,0) circle [radius=2.15pt];}}
    \endpgfinterruptboundingbox
    \onslide<6->{
        \node[right=1.25cm,gray] (niveau) at (dr-|inner3) {\textbf{Ebene}};
    }
    \pgfonlayer{background}
        \foreach[count=\i] \x in {root,inner1,leaf3,leaf1} {
            \onslide<\the\numexpr\i+6\relax->{
                \node[gray,font=\bfseries] (dn\i) at(\x-|niveau) {\the\numexpr\i-1\relax};
                \draw[lgray!90!white,densely dashed, very thick] (dn\i.west) -- (dl.west|-dn\i.west);
            }
        }
    \endpgfonlayer
}}
\end{frame}
\begin{frame}[c]{Exkurs: Heaps\ldots\ Bäume. Was hat eine Wurzel und zwei Beine?}
\begin{columns}[c]
\begin{column}{.55\linewidth}
\begin{itemize}
    \itemsep8pt
    \item<4-> Jede gefüllte Ebene \(i\) enthält \(2^i\) Elemente.
    \item<5-> Die Nummerierung nach Breitendurchlauf erlaubt Adressierung!
    \item<7-> Das linke Kind von \(n\) ist \(2 \cdot n + 1\), das rechte Kind \(2 \cdot n + 2\).
    \item<8-> Der Elternknoten von \(n\) ist \(\lfloor \frac{n - 1}{2}\rfloor\).
\end{itemize}
\end{column}
\begin{column}{.35\linewidth}
\onslide<2->{\heap[s sep=3em-level*.5em]{[18,name=a[7,name=b[3,name=c[3,name=d][2,name=e]][6,name=f]][-2,name=g[-1,name=h][-2,name=i]]]%
\pgfonlayer{background}
\onslide<3->{\foreach[count=\i] \x in {a,b,c,d} {
        \node[gray,font=\bfseries] (dn\i) at(\x-|4,0) {\the\numexpr\i-1\relax};
        \draw[lgray!90!white,densely dashed, very thick] (dn\i.west) -- (d.west|-dn\i.west) -- ++(-2.5mm,0);
}}
\onslide<6->{\foreach[count=\i] \x in {a, b, g, c, f, h, i, d, e} {
        \node[paletteA,font=\bfseries,left=.25mm] at (\x.west) {\the\numexpr\i-1\relax};
}}
\endpgfonlayer}}
\end{column}
\end{columns}
\begin{tikzpicture}[overlay,remember picture]
    \colorlet{qr@fancy@gradient@tl}{gray!14!paletteA}
    \colorlet{qr@fancy@gradient@br}{gray!90!paletteA}
    \onslide<9->{\node[above left,yshift=.5cm,xshift=-.15cm] at(current page.south east) {\fancyqr[height=1.75cm,level=H]{https://github.com/EagleoutIce/Episode-Heaps}};}
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item Ein Dateien Palast: \only<2->{\textattachfile{\curpath IntegerNode.java}{IntegerNode.java}}, \only<2->{\textattachfile{\curpath Queue.java}{Queue.java}} und \only<2->{\textattachfile{\curpath BinaryTree.java}{BinaryTree.java}}.
        \item Wir bauen einen binären Baum \info{ich glaub es kaum. Zauuuuun}:
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<4->*!public BinaryTree(int[] items) {
!*\onslide<5->*!    this.root = buildTree(items, 0);
!*\onslide<4->*!}
!*\onslide<6->*!private static IntegerNode buildTree(int[] items, int index) {
!*\onslide<7->*!    if (index >= items.length) return null;
!*\onslide<7->*!
!*\onslide<8->*!    IntegerNode node = new IntegerNode(items[index]);
!*\onslide<10->*!    node.setLeftChild(buildTree(items, 2 * index + 1)); // left
!*\onslide<10->*!    node.setRightChild(buildTree(items, 2 * index + 2)); // right
!*\onslide<9->*!    return node;
!*\onslide<6->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\iffull
\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 1a)\hfill Watcha doin?}
\SetupLstHl\lstfs{8}%
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<2->*!!*\md4*!public BinaryTree(int[] items) { !*\rBS<handout:1-3|4->{items=\{14,3,7,8,-2\}}*!
!*\onslide<2->*!    !*\md5*!this.root = build!*\mb6*!!*\mbg[1-2]{7-59}*!Tr!**!ee(items, 0);!*\ml[3]{60}*!
!*\onslide<2->*!}

!*\onslide<3->*!!*\md{7,12,17,22,29,38,51}*!private static IntegerNode buildTree(int[] items, int index) { !*\rBS<handout:1|7-11,47-50,57-59>{items=\{\mkb{14},3,7,8,-2\}}*!!*\rBS<handout:2|12-16,34-37,44-46>{items=\{14,\mkb{3},7,8,-2\}}*!!*\rBS<handout:0|17-21,25-28,32-33>{items=\{14,3,7,\mkb{8},-2\}}*!!*\rBS<handout:0|22-24,29-31>{items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<38-43|handout:0>{items=\{14,3,7,8,\mkb{-2}\}}*!!*\rBS<51-56|handout:0>{items=\{14,3,\mkb{7},8,-2\}}*!
!*\onslide<3->*!    !*\md{8,13,18,23,30,39,52}*!if (index >= items.length) return null;!*\ml{24,31}~*! !*\rBS<handout:1|8-11,47-50,57-59>{0>=5}*!!*\rBS<handout:2|13-16,34-37,44-46>{1>=5}*!!*\rBS<handout:0|18-21,25-28,32-33>{3>=5}*!!*\rBS<handout:0|23-24,30-31>{7>=5}*!!*\rBS<handout:0|39-43>{4>=5}*!!*\rBS<handout:0|52-56>{2>=5}*!
!*\onslide<3->*!
!*\onslide<3->*!    !*\md{9,14,19,40,53}*!IntegerNode node = new IntegerNode(items[index]); !*\rBS<handout:1|9-11,47-50,57-59>{IntegerNode(14)}*!!*\rBS<handout:2|14-16,34-37,44-46>{IntegerNode(3)}*!!*\rBS<handout:0|19-21,25-28,32-33>{IntegerNode(8)}*!!*\rBS<handout:0|40-43>{IntegerNode(-2)}*!!*\rBS<handout:0|53-56>{IntegerNode(7)}*!

!*\onslide<3->*!    !*\md[1]{10,15,20,41,54}*!node.setLeftChild(build!*\mb{11,16,21,25,34,47}\mbg[1,2]{12-15,17-20,22-24,26-33,35-46}*!Tre!**!e(items, 2 * index + 1));!*\ml{26,35,48}~*! !*\rBS<handout:1|10-11>{2*0+1, items=\{14,\mkb{3},7,8,-2\}}*!!*\rBS<handout:0|15-16>{2*1+1, items=\{14,3,7,\mkb{8},-2\}}*!!*\rBS<handout:0|20-21>{2*2+1, items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<handout:0|41-43,54-56>{skipping\ldots}*!

!*\onslide<3->*!    !*\md{27,36,42,49,55}*!node.setRightChild(build!*\mb{28,32,37,44,50,57}\mbg{29-31,38-43,51-56}*!Tr!**!ee(items, 2 * index + 2));!*\ml[2]{45,58}~*! !*\rBS<handout:0|27-28>{2*3+2, items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<handout:0|36-37>{2*1+2, items=\{14,3,7,8,\mkb{-2}\}}*!!*\rBS<handout:0|42-43,55-56>{skipping\ldots}*!!*\rBS<handout:0|49-50>{2*0+2, items=\{14,3,\mkb{7},8,-2\}}*!

!*\onslide<3->*!    !*\md{33,43,46,56,59}*!return node;
!*\onslide<3->*!}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture,scale=.65,every node/.append style={transform shape}]
    \scope[shift=(current page.south east),xshift=-.5cm-2cm,yshift=.5cm+3.5cm]
        \onslide<10->{\node[dot] (0) at (0,0) {14};}
        \onslide<handout:2-|14->{\node[dot] (1) at (-1,-1) {3};}
        \onslide<handout:2-|19->{\node[dot] (2) at (-1.75,-2) {8};}
        \onslide<handout:2-|25->{\draw (2) -- (1);}
        \onslide<handout:2-|40->{\node[dot] (3) at (-.25,-2) {-2};}
        \onslide<handout:2-|45->{\draw (3) -- (1);}
        \onslide<handout:3-|48->{\draw (1) -- (0);}
        \onslide<handout:3-|53->{\node[dot] (4) at (1,-1) {7};}
        \onslide<handout:3-|58->{\draw (4) -- (0);}
        \onslide<handout:3-|60->{\node[above=-1mm,align=center] at (0.north) {root\\[-1.8mm]\faCaretDown};}
    \endscope
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 1b)}
    \begin{itemize}[<+(1)->]
        \item Der Breitendurchlauf:\lstfs{10}
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<3->*!public void breadthFirstTraversal() {
!*\onslide<4->*!    Queue queue = new Queue();
!*\onslide<4->*!    queue.enqueue(root);
!*\onslide<3->*!
!*\onslide<5->*!    while (!queue.isEmpty()) {
!*\onslide<6->*!        IntegerNode node = queue.dequeue();
!*\onslide<6->*!        if(node == null) continue;
!*\onslide<3->*!
!*\onslide<7->*!        queue.enqueue(node.getLeftChild());
!*\onslide<7->*!        queue.enqueue(node.getRightChild());
!*\onslide<3->*!
!*\onslide<8->*!        System.out.print(node.getValue() + " ");
!*\onslide<3->*!    }
!*\onslide<5->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Aufgabe 2}
\iffull
\begin{frame}[c]{Übungsblatt 12 - Aufgabe 2}
\scriptsize\onslide<2->{In dieser Aufgabe sollen Sie eine Methode implementieren, welche einen \textit{Binary Expression Tree} auswerten kann. Dabei handelt es sich um eine spezielle Art von Baum, bei dem die Blätter Werte und die inneren Knoten arithmetische Operatoren speichern.
Gehen Sie dafür folgendermaßen vor.}
\begin{enumerate}
    \item<3-> Erstellen Sie eine Klasse \solGet{keywordC}{StringNode}, welche den Datentyp \bjava{String} verwendet um den Wert des Knotens zu speichern. Dies ist für diese Aufgabe notwendig, da Sie hier sowohl Integer Werte als auch arithmetische Operatoren speichern sollen. Hierbei können Sie die Eigenschaften der Klasse \solGet{keywordC}{IntegerNode} übernehmen.
    Fügen Sie nun noch die Methode \bjava{public boolean isLeaf()} hinzu, welche \texttt{true} zurückliefert falls es sich bei dem Knoten um ein Blatt im Baum handelt.
    \item<4-> Erstellen Sie nun eine Klasse \solGet{keywordC}{BinaryExpressionTree}, welche ähnlich zur Klasse \solGet{keywordC}{BinaryTree} einen Konstruktor besitzt der anhand eines übergebenen Arrays einen Baum erzeugen kann.
    Implementieren Sie nun die Methode \bjava{public double evaluate()}, welche den gespeicherten arithmetischen Ausdruck auswertet und das Ergebnis zurückliefert. Hierfür werden Sie sich eine rekursive Hilfsmethode implementieren müssen.
\end{enumerate}
\onslide<5->{Verwenden Sie auch bei dieser Aufgabe keine Arrays oder vorgefertigten dynamischen Datenstrukturen in ihrer Implementierung.
\onslide<6->{\textbf{Hinweise:}
\begin{itemize}
    \item Falls Sie die Erzeugung des Baumes in der vorherigen Aufgabe nicht lösen konnten, erzeugen Sie sich in dieser Aufgabe manuell einen entsprechenden Baum im Konstruktor um ihre Implementierung testen zu können.
    \item Ihr Baum sollte die Operationen \textit{Addition}, \textit{Subtraktion}, \textit{Multiplikation} und \textit{Division} unterstützen.
    \item Die Methode \bjava{public static double parseDouble(String s)} der Wrapper Klasse \bjava{Double} gibt ihnen den Fließkommawert zurück, welcher im übergebenen String \T{s} gespeichert ist.
\end{itemize}}}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.1)}
    \SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Zusätzliche Freu(n)de: \only<2->{\textattachfile{\curpath StringNode.java}{StringNode.java}} und \only<2->{\textattachfile{\curpath BinaryExpressionTree.java}{BinaryExpressionTreeStringNode.java}}
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{StringNode}}]
!*\onslide<3->*!public class StringNode {
!*\onslide<4->*!    private String item;
!*\onslide<4->*!    private StringNode left;
!*\onslide<4->*!    private StringNode right;
!*\onslide<3->*!
!*\onslide<5->*!    |ihl|public void setRightChild(StringNode right) { this.right = right; }|ihl|
!*\onslide<5->*!    |ihl|public StringNode getRightChild() { return this.right; }|ihl|
!*\onslide<5->*!    |ihl|public void setLeftChild(StringNode left) { this.left = left; }|ihl|
!*\onslide<5->*!    |ihl|public StringNode getLeftChild() { return this.left; }|ihl|
!*\onslide<5->*!    |ihl|public void setItem(String item) { this.item = item; }|ihl|
!*\onslide<5->*!    |ihl|public String getItem() { return this.item; }|ihl|
!*\onslide<3->*!
!*\onslide<7->*!    public boolean isLeaf() { return left == null && right == null; }
!*\onslide<3->*!
!*\onslide<6->*!    |ihl|public StringNode(String v) { this.item = v; this.right = this.left = null; }|ihl|
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.2)}
    \SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Die Grundlage des Baumes ist wie bekannt:
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{BinaryExpressionTree,StringNode}}]
!*\onslide<3->*!public class BinaryExpressionTree {
!*\onslide<4->*!    private StringNode root;
!*\onslide<5->*!    |ihl|public BinaryExpressionTree(|ihl|String[] |ihl|items) {|ihl|
!*\onslide<6->*!        |ihl|this.root = buildTree(items, 0);|ihl|
!*\onslide<5->*!    }
!*\onslide<7->*!    |ihl|private static|ihl| StringNode |ihl|buildTree(|ihl|String[] |ihl|items, int index) {|ihl|
!*\onslide<8->*!        |ihl|if (index >= items.length) return null;|ihl|
!*\onslide<3->*!
!*\onslide<9->*!        StringNode |ihl|node = new|ihl| StringNode(|ihl|items[index]|ihl|);
!*\onslide<10->*!        |ihl|node.setLeftChild(buildTree(items, 2 * index + 1));|ihl|
!*\onslide<10->*!        |ihl|node.setRightChild(buildTree(items, 2 * index + 2));|ihl|
!*\onslide<11->*!        |ihl|return node;|ihl|
!*\onslide<7->*!    }
!*\onslide<3->*!
!*\onslide<12->*!    // :ldots:
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.2)}
    \SetupLstHl\lstfs{8}\begin{itemize}[<+(1)->]
        \item Die Auswertung
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{BinaryExpressionTree,StringNode}}]
!*\onslide<3->*!|ihl|public class BinaryExpressionTree {|ihl|
!*\onslide<4->*!   |ihl|private StringNode root;|ihl|
!*\onslide<4->*!   // :ldots:
!*\onslide<5->*!   public double evaluate() { return evaluate(root); }
!*\onslide<6->*!   private double evaluate(StringNode node) {!*\onslide<13->*! // Postorder
!*\onslide<7->*!      |ihl|if (node == null) throw new IllegalStateException("Traversing empty");|ihl|
!*\onslide<8->*!      if (node.isLeaf())  return Double.parseDouble(node.getItem());
!*\onslide<9->*!      double valueLeft = evaluate(node.getLeftChild());
!*\onslide<9->*!      double valueRight = evaluate(node.getRightChild());
!*\onslide<5->*!
!*\onslide<10->*!      switch (node.getItem()) { // Get the Operator
!*\onslide<11->*!          case "+": return valueLeft + valueRight;
!*\onslide<11->*!          case "-": return valueLeft - valueRight;
!*\onslide<11->*!          case "*": return valueLeft * valueRight;
!*\onslide<11->*!          case "/": return valueLeft / valueRight;
!*\onslide<12->*!          default: throw new IllegalArgumentException(":ldots:");
!*\onslide<10->*!      }
!*\onslide<6->*!   }
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\subsection{Aufgabe 3}
\iffull
\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3}
\footnotesize\onslide<2->{In dieser Aufgabe sollen Sie noch ein letztes Mal etwas auf der Kommandozeile zeichnen. Dieses Mal sollen Sie die Array-Repräsentation eines balancierten Binärbaumes grafisch darstellen. Hierfür sollten Sie sich zuerst Gedanken über die Eigenschaften des resultierenden Baumes machen. Ihre Implementierung sollte Bäume beliebiger Größe mit Knoten mit ganzzahligen positiven Werte zwischen 1 und 99 korrekt eingerückt darstellen können.
Die Ausgabe ihres Programms sollte in etwa so aussehen:}
\begin{plainbash}
*\onslide<3->*Binärbaum-Darstellung von: [35, 5, 18, 19, 92, 85, 72, 84, 5]
*\onslide<3->*              35
*\onslide<3->*      +-------+-------+
*\onslide<3->*      5               18
*\onslide<3->*  +---+---+       +---+---+
*\onslide<3->*  19      92      85      72
*\onslide<3->*+-+-+
*\onslide<3->*84  5
\end{plainbash}
\end{frame}
\fi

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3}
    \begin{itemize}[<+(1)->]
        \item Man \textit{kann} das Zeichnen naiv implementieren (\only<2->{\textattachfile{\curpath DrawTreeNaive.java}{DrawTreeNaive.java}}).
        \item Das werden wir hier nicht tun.\pause\ Wir können Mathe.\pause\ Wir lieben Mathe (\only<2->{\textattachfile{\curpath DrawTree.java}{DrawTree.java}}).
        \item Zunächst die Formatierung einer Zahl:
\begin{plainjava}
!*\onslide<7->*!static String numberFormat(int[] arr, int i) {
!*\onslide<8->*!    if(i >= arr.length) return "  ";
!*\onslide<9->*!    return arr[i] > 9 ? Integer.toString(arr[i]) : " " + arr[i];
!*\onslide<7->*!}
\end{plainjava}
        \item<10-> Mit \bjava{String::format} geht auch: \bjava{String.format(\"}\solGet{literals}{\solGet{keywordB}{\%-2d}}\bjava{\"}\bjava{, arr[i]);}
        % \item Da es sich nur um balancierte Bäume handelt, können wir wieder die Zweierpotenzen ausnutzen!
        % \item Nicht vorhandene Knoten sind einfach leere Knoten.
        % \item Ein balancierter Binärbaum aus \(n\) Elementen hat eine Tiefe von \(\floor{\log_2(n)}\).
        % \item Für einen Knoten sind die Hälfte der Kinder auf der linken Seite \info{und potenziell leer}.
    \end{itemize}
    % TODO \textattachfile{\curpath DrawTree.java}{DrawTree.java}
\end{frame}

\MakeThePinguExplainIt[text width=6.33cm]{cap=!hide,glasses=!hide,halo,halo raise=2mm,lollipop left,left wing grab}{Ich werde nicht auf die Erweiterbarkeit eingehen. Warum? Manche 2er kommen von den Binärbaumen, manche von der Breite der Zahlen, manche vom Padding. Die Differenzierung ist nett.}
\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3}
    \lstfs{10}\begin{itemize}[<+(1)->]
        \item Oder der erweiterbare Weg \info{wie könnte man das erweitern}:
\begin{plainjava}
!*\onslide<3->*!public static String numberFormat(int[] array, int i) {
!*\onslide<4->*!    if(i >= array.length) return " ".repeat(2);
!*\onslide<5->*!    int number = array[i];
!*\onslide<5->*!    int size = (int) Math.log10(number) + 1;
!*\onslide<6->*!    return number + " ".repeat(Math.abs(2 - size));
!*\onslide<3->*!}
\end{plainjava}
        \item<7-> Hinweis: Allgemein werde ich \bjava{String::repeat} benutzen, anstelle von sowas:
\begin{plainjava}
!*\onslide<8->*!public String repeat(String str, int n) {
!*\onslide<9->*!    String ret = "";
!*\onslide<9->*!    for(int i = 0; i < n; i++) ret += str;
!*\onslide<9->*!    return str;
!*\onslide<8->*!}
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<10->{\node[left=-18mm,scale=.8] at(current page.{-26.25}) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3\hfill Baumkunde}
    \lstfs{10}\lstset{aboveskip=4pt,belowskip=4pt}\begin{itemize}[<+(1)->]
        \item Was wir brauchen: \begin{itemize}
            \item Die Größe des Baumes durch \(\log_2\) aus der Länge des Arrays:
{\color{black}\begin{plainjava}
int height = (int) (Math.log(array.length) / Math.log(2));
\end{plainjava}}
            \item Die maximale Breite des Baumes. Jeder Knoten braucht dabei \(2\) Zeichen und zwischen den Knoten gibt es zwei Zeichen Platz.
            \info{Wie ginge das mit Konstanten schöner, lesbarer und flexibler?}
{\color{black}\begin{plainjava}
int width = (2 + 2) * (int) Math.pow(2, height);
\end{plainjava}}
            \item Die Position des \(j\)-ten Knoten auf Ebene \(i\) \info{man kann auch einfach hochzählen}:
{\color{black}\begin{plainjava}
int index = (int) Math.pow(2, i) + j - 1;
\end{plainjava}}
        \end{itemize}
            \item Den Abstand links und den Zwischen-Abstand auf Ebene \(i\) \info{erstmal ohne Padding}:
\begin{plainjava}
int levelWidth = (int) Math.pow(2, i);
int padding = width / levelWidth;
int leftPad = width / (levelWidth * 2) - 2; // halb links, halb rechts
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3\hfill draw(int[])}
\SetupLstHl\begin{itemize}[<+(1)->]
    \item High-Level ist das Zeichnen leicht beschrieben:
\begin{plainjava}
!*\onslide<3->*!static void draw(int[] array) {
!*\onslide<4->*!    int height = |ihl|(int) (Math.log(array.length) / Math.log(2))|ihl|;
!*\onslide<4->*!    int width = |ihl|(2 + 2) * (int) Math.pow(2, height)|ihl|;
!*\onslide<3->*!
!*\onslide<5->*!    for (int i = 0; i <= height; i++) {
!*\onslide<6->*!        drawNumbers(array, width, i);
!*\onslide<7->*!        if (i < height) // Für die nächste Ebene:
!*\onslide<7->*!            drawLines(array, width, i + 1);
!*\onslide<5->*!    }
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3\hfill drawNumbers(int[], int, int)}
\SetupLstHl
\begin{plainjava}
!*\onslide<2->*!static void drawNumbers(int[] array, int width, int currentHeight) {
!*\onslide<3->*!    int levelSize = |ihl|(int) Math.pow(2, currentHeight)|ihl|;
!*\onslide<3->*!    int padding = |ihl|width / levelSize|ihl|;
!*\onslide<3->*!    int leftPadding = |ihl|width / (levelSize * 2) - 2|ihl|;
!*\onslide<4->*!    System.out.print(" ".repeat(leftPadding));
!*\onslide<5->*!    for (int j = 0; j < levelSize; j++) { // "Breitendurchlauf"
!*\onslide<6->*!        if (j > 0) // Abstand dazwischen
!*\onslide<6->*!            System.out.print(" ".repeat(padding - 2));
!*\onslide<7->*!        System.out.print(formatNumber(array, |ihl|levelSize + j - 1|ihl|));
!*\onslide<5->*!    }
!*\onslide<8->*!    System.out.println();
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3\hfill drawLines(int[], int, int)}
\SetupLstHl
\begin{plainjava}
!*\onslide<2->*!static void drawLines(int[] array, int width, int currentHeight) {
!*\onslide<3->*!    int levelSize = |ihl|(int) Math.pow(2, currentHeight)|ihl|;
!*\onslide<3->*!    int padding = |ihl|width / levelSize|ihl|;
!*\onslide<3->*!    int leftPadding = |ihl|width / (levelSize * 2) - 2|ihl|;
!*\onslide<4->*!    System.out.print(" ".repeat(leftPadding) + "+"); // Mind. eine
!*\onslide<5->*!    for (int j = 0; j < levelSize; j++) {
!*\onslide<6->*!        if (|ihl|levelSize + j - 1|ihl| >= array.length) break; // Zahlen vorbei?
!*\onslide<7->*!        if (j > 0 && j % 2 == 0) // Abstand dazwischen
!*\onslide<7->*!            System.out.print(" ".repeat(padding - 1) + "+");
!*\onslide<8->*!        System.out.print("-".repeat((padding - 2) / 2) + "+");
!*\onslide<5->*!    }
!*\onslide<9->*!    System.out.println();
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\subsection{Zusatzaufgabe 6/6}
\iffull
\begin{frame}[c]{}
    \downsize\linewidth{\SimulateTTTPlay{3, 5, 8, 6}{2}}
\end{frame}
\begin{frame}[c]{Übungsblatt 12 - Zusatzaufgabe 6/6\hfill I}
\columns[c,onlytextwidth]
\column{.7\linewidth}
    \onslide<2->{\tiny Auf einem der vorherigen Übungsblätter hatten Sie die Aufgabe das Spiel Tic Tac Toe mit zwei realen Spielern zu implementieren.
    In dieser Aufgabe soll es nun darum gehen einen der beiden Spieler durch eine KI zu ersetzen, welche immer den bestmöglichen Zug ausführt. Dabei handelt es sich un einen Zug, welcher im weiteren Spielverlauf entweder zu einem Sieg, oder zumindest zu einem Unentschieden führt falls der menschliche Spieler ebenfalls perfekt spielt.\bigskip

    Um dies zu erreichen, sollen Sie sich in dieser Aufgabe mit dem \textit{Minimax} Algorithmus auseinandersetzen. Hierbei handelt es sich um einen Algorithmus, welcher rekursiv alle möglichen Spielverläufe bis zu einer bestimmten Tiefe durchgeht und basierend auf der Chance auf einen Gewinn entsprechende Punktzahlen zurückliefert. Beim Spiel Tic Tac Toe ist es dank der stark begrenzten Anzahl von Spielverläufen möglich, alle Züge durchzuprobieren bis entweder ein Spieler gewonnen hat, oder ein Unentschieden erreicht wurde. Bei komplexeren Spielen wie Schach oder Go ist dies nicht möglich.
    Im Fall von Tic Tac Toe wird bei einem Sieg eine positive Zahl zurückgegeben, im Falle einer Niederlage eine negative Zahl und im Falle von einem Unentschieden eine Null.\bigskip

    Die entsprechenden Punktzahlen werden daraufhin durch das alternierende bilden von Minima und Maxima rekursiv ausgewertet. Dies lässt sich am Besten anhand eines Beispiels erläutern. In der Abbildung rechts  gehen wir davon aus, dass die KI aktuell am Zug ist und das Symbol \T{x} verwendet. Es stehen nun drei mögliche Züge zur Auswahl. Der Zug oberste würde direkt zu einem Sieg führen. Hier ist kein rekursiver Methodenaufruf nötig, stattdessen wird direkt eine \(+10\) zurückgegeben um zu signalisieren dass es sich hierbei um einen Zug handelt der zum Sieg führt.}
\column{.3\linewidth}
\null\hfill\downsizeHeight{6.5cm}{\begin{tikzpicture}[ampersand replacement=\&,align-half-base,every path/.append style={rounded corners=2pt}]
    \onslide<3->{\ttt{XOO --X O-X}\printtt*[right,at={(0,0)}]
    \coordinate (b) at (m.south);}

    \onslide<4->{\ttt{XOO -XX O-X}\printtt*[below right of=b,yshift=-1cm,xshift=1.5cm]
    \coordinate (i) at (m.west);
    \coordinate (ib) at (m.east);
    \draw[-Kite] (b) |- (i);
    \onslide<5->{\node[right=2mm,align=center] at(ib) {\large\paletteB{\textbf{\(+10\) Punkte}}\\[-1.33mm]\normalsize\info{to Harry Potter}};}

    \ttt{XOO X-X O-X}\printtt*[below right of=b,yshift=-4.66cm,xshift=1.5cm]
    \coordinate (ii) at (m.west);
    \coordinate (iib) at (m.east);
    \draw[-Kite] (b) |- (ii);
    \onslide<5->{\draw[-Kite] (iib) -- ++(.5,0) |- ++(.5,.5);
    \draw[-Kite] (iib) -- ++(.5,0) |- ++(.5,-.5);
    \node[right=7mm] at (iib) {II)};}

    \ttt{XOO --X OXX}\printtt*[below right of=b,yshift=-8cm,xshift=1.5cm]
    \coordinate (iii) at (m.west);
    \coordinate (iiib) at (m.east);
    \draw[-Kite] (b) |- (iii);
    \onslide<5->{\draw[-Kite] (iiib) -- ++(.5,0) |- ++(.5,.5);
    \draw[-Kite] (iiib) -- ++(.5,0) |- ++(.5,-.5);
    \node[right=7mm] at (iiib) {III)};}}
\end{tikzpicture}}
\endcolumns
\end{frame}
\begin{frame}[c]{Übungsblatt 12 - Zusatzaufgabe 6/6\hfill II}
    \onslide<2->{\tiny Im Falle der beiden anderen möglichen Zügen II) und III) müssen wir nun rekursiv weiter gehen bis wir in jeweils das Spielende erreichen.
    In der Abbildung rechts wechseln wir in die Sicht des menschlichen Spielers, und betrachten die jeweiligen Züge als neue Ausgangspositionen.
    Der menschliche Spieler hat in beiden Fällen selbst jeweils zwei mögliche Züge zur Auswahl.
    Wir betrachten im Folgenden nur noch den weiteren Ablauf von Zug II), da das Prinzip identisch auf Zug III) übertragbar ist.
    Der menschliche Spieler könnte nun in diesem Zug gewinnen, indem er sein Symbol \say{O} in die Mitte des Spielfeldes platziert.
    In diesem Fall würden wir bei dem rekursiven Methodenaufruf nun eine \(-10\) zurückgeben, um zu signalisieren dass die KI verloren hätte.
    Würde der menschliche Spieler jedoch das untere freie Feld belegen, wäre das Spiel nicht vorbei und wir würden einen weiteren rekursiven Methoden Aufruf ausführen.\bigskip

    Hier wechseln wir nun wieder in die Sicht der KI und stellen fest, dass nur noch ein Zug möglich ist, welcher zu einem Sieg führen würde.
    In diesem Fall geben wir wieder eine \(+10\) zurück um dies zu signalisieren.
    In jedem Rekursionsschritt müssen wir nun die zurückgegebenen Punktzahlen folgendermaßen auswerten:
    befinden wir uns in der Sicht des menschlichen Spielers, so bilden wir das Maximum der zurückgegebenen Werte. Befinden wir uns in einem Rekursionsschritt in der Sicht der KI, so bilden wir das Minimum der zurückgegebenen Werte.}
    \begin{center}
\onslide<7->{\downsizeHeight{3cm}{\begin{tikzpicture}[ampersand replacement=\&,align-half-base,every path/.append style={rounded corners=2pt}]
    \ttt{XOO X-X O-X}\printtt*[left,at={(0,0)}]
    \coordinate (b) at (m.east);
    \node[above] at (m.north) {II)};

    \ttt{XOO XOX O-X}\printtt*[above left of=b,yshift=.4cm,xshift=2.5cm]
    \coordinate (iia) at (m.west);
    \coordinate (iib) at (m.east);
    \node[right=2mm,align=center] at(iib) {\scriptsize\paletteD{\textbf{\(-10\) Punkte}}\\[-.1mm]\tiny\info{to love}};


    \ttt{XOO X-X OXX}\printtt*[below left of=b,yshift=-.4cm,xshift=2.5cm]
    \coordinate (iiia) at (m.west);
    \coordinate (iiib) at (m.east);

    \draw[-Kite] (b) -- ++(.5,0) |- (iia);
    \draw[-Kite] (b) -- ++(.5,0) |- (iiia);

    \ttt{XOO XXX OOX}\printtt*[right of=iiib,xshift=.5cm]
    \coordinate (iiic) at (m.west);
    \coordinate (iiid) at (m.east);
    \node[right=2mm,align=center] at(iiid) {\scriptsize\paletteB{\textbf{\(+10\) Punkte}}\\[-.1mm]\tiny\info{to future}};
    \draw[-Kite] (iiib) -- (iiic);

\end{tikzpicture}}}\qquad\onslide<8->{\downsizeHeight{3cm}{\begin{tikzpicture}[ampersand replacement=\&,align-half-base,every path/.append style={rounded corners=2pt}]
    \ttt{XOO --X OXX}\printtt*[left,at={(0,0)}]
    \coordinate (b) at (m.east);
    \node[above] at (m.north) {III)};

    \ttt{XOO -OX O-X}\printtt*[above left of=b,yshift=.4cm,xshift=2.5cm]
    \coordinate (iia) at (m.west);
    \coordinate (iib) at (m.east);
    \node[right=2mm,align=center] at(iib) {\scriptsize\paletteD{\textbf{\(-10\) Punkte}}\\[-.1mm]\tiny\info{to things}};


    \ttt{XOO O-X OOX}\printtt*[below left of=b,yshift=-.4cm,xshift=2.5cm]
    \coordinate (iiia) at (m.west);
    \coordinate (iiib) at (m.east);


    \draw[-Kite] (b) -- ++(.5,0) |- (iia);
    \draw[-Kite] (b) -- ++(.5,0) |- (iiia);

    \ttt{XOO OXX OXX}\printtt*[right of=iiib,xshift=.5cm]
    \coordinate (iiic) at (m.west);
    \coordinate (iiid) at (m.east);

    \node[right=2mm,align=center] at(iiid) {\scriptsize\paletteB{\textbf{\(+10\) Punkte}}\\[-.1mm]\tiny\info{to my past}};
    \draw[-Kite] (iiib) -- (iiic);
\end{tikzpicture}}}
    \end{center}
\end{frame}
\begin{frame}[c]{Übungsblatt 12 - Zusatzaufgabe\hfill III}
    \onslide<2->{\tiny In II) und III) haben wir in der Sicht des Gegners jeweils immer nur einen Zug zur Auswahl, und somit betrachten wir die zurückgegebene Punktzahl direkt als Maximum.
    In den jeweiligen Ausgangspositionen II) und III) haben wir aber zwei zurückgegebene Werte zur Auswahl.
    Bilden wir hier jeweils das Minimum, so liefert uns dies in beiden Fällen eine \(-10\).
    In diesem Fall wird das Minimum gebildet da wir davon ausgehen müssen, dass der Gegner selbst immer den optimalen Zug auswählt.
    Der menschliche Spieler würde also in beiden Fällen jeweils das Feld belegen, welches für ihn zum Sieg führen würde.
    Zurück in der Ausgangsposition bilden wir nun wieder das Maximum, aus den Minima die uns die rekursiven Methodenaufrufe zurückgegeben haben, was uns eine \(+10\) liefert.
    Somit stellt sich Zug I) als optimal heraus, da die anderen beiden Züge zu einer Niederlage führen würden.\smallskip

    Die Kernpunkte des Algorithmus lassen sich nun folgendermaßen zusammenfassen:
    \begin{itemize}
        \item[\textbullet] Der Algorithmus startet mit dem aktuellen Spielfeld, testet rekursiv die möglichen Spielzüge und bildet das Maximum der zurückgegebenen Werte für die jeweiligen Spielzüge.
        \item[\textbullet] In den Rekursionsschritten wird nun alternierend das Minimum und das Maximum gebildet.
        \item[\textbullet] Die Rekursion wird beendet wenn ein Spielende erreicht wird. In diesem Fall wird eine positive Zahl zurückgegeben falls die KI gewonnen hat, eine negative Zahl falls der menschliche Spieler gewonnen hat und eine Null im Falle eines Unentschieden.
        \item[\textbullet] Zusätzlich lässt sich auch noch die Spieltiefe mit einbeziehen um den Zug zu bestimmen, welcher am schnellsten zum Sieg führt. Dies ist für diese Übungsaufgabe aber optional.
    \end{itemize}\smallskip}

    \onslide<3->{\strut\cancel{Im Moodle} Hier finden Sie als Vorlage für diese Aufgabe die Datei \textattachfile{\curpath Minimax.java}{Minimax.java}, welche eine vorbereitete Implementierung von Tic Tac Toe beinhaltet. In dieser Vorlage sollen Sie nun die folgenden zwei Methoden vervollständigen:
    \begin{itemize}
        \item[\textbullet] Die Methode \bjava{public static char[][] computerMove(char[][] board, int numMoves)} übernimmt das Spielbrett und die Anzahl der unbelegten Felder als Parameter. In dieser Methode sollen Sie nun den bestmöglichen Zug bestimmen, diesen in einer Kopie des Spielbrettes setzen und dieses zurückgeben.
        Hierbei sollen Sie die folgende Methode \T{minimax} verwenden.
        \item[\textbullet] Die Methode \bjava{public static int minimax(char[][] board, boolean maximize)} soll rekursiv den Minimax Algorithmus ausführen. Sie dürfen die Methodensignatur dieser Methode erweitern, sollten Sie zusätzliche Parameter benötigen. Für diese Aufgabe genügt es einen Spielzug zu bestimmen, der sicher zu einem Sieg oder einem Unentschieden führt.
    \end{itemize}
    Bei dieser Aufgabe dürfen Sie die möglichen Spielzüge in einer \bjava{ArrayList} verwalten, um nicht in jedem Rekursionsschritt das gesamte Spielbrett durchsuchen zu müssen. Dies ist jedoch kein Muss.}
\end{frame}
\fi

\MakeThePinguExplainIt[text width=8.33cm]{cap=!hide,glasses=!hide,halo,halo raise=2mm,lollipop left,left wing grab}{%
\begin{plainjava}[aboveskip=-4pt,belowskip=0pt,deletekeywords={[4]{PLAYER_COMP,PLAYER_HUMAN,WIN_HUMAN,LOSE_HUMAN,DRAW,EMPTY}}]^^J
static final int LOSE_HUMAN = 10;^^J
static final int WIN_HUMAN = -10;^^J
static final int DRAW = 0;^^J
static final char PLAYER_COMP = 'X';^^J
static final char PLAYER_HUMAN = 'O';^^J
static final char EMPTY = 0;^^J
\end{plainjava}
}
\begin{frame}[c,fragile]{Übungsblatt 12 - Zusatzaufgabe\hfill III}
    \begin{itemize}[<+(1)->]
        \item Man muss nicht jedes mal neu prüfen (\only<2->{\textattachfile{\curpath EfficientMinimax.java}{EfficientMinimax.java}}), wir betrachten es hier aber nur mit (\only<2->{\textattachfile{\curpath Minimax.java}{Minimax.java}}).
        \item Zunächst, kann man überhaupt noch ziehen:
\begin{plainjava}[morekeywords={[4]{PLAYER_COMP,PLAYER_HUMAN,WIN_HUMAN,LOSE_HUMAN,DRAW,EMPTY}}]
!*\onslide<4->*!static boolean isFull(char[][] board) {
!*\onslide<5->*!    for (int y = 0; y < 3; y++) {
!*\onslide<6->*!        for (int x = 0; x < 3; x++) {
!*\onslide<7->*!            if (board[y][x] == EMPTY)
!*\onslide<7->*!                return false;
!*\onslide<6->*!        }
!*\onslide<5->*!    }
!*\onslide<8->*!    return true;
!*\onslide<4->*!}
\end{plainjava}
    \end{itemize}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<8->{\node[left=-18mm,scale=.8] at(current page.{-24.25}) {\usebox\pinguexplainbox};}
\end{tikzpicture}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Zusatzaufgabe\hfill Der Baum}
\vspace*{-1mm}\lstfs{9}\SetupLstHl\begin{plainjava}[morekeywords={[4]{PLAYER_COMP,PLAYER_HUMAN,WIN_HUMAN,LOSE_HUMAN,DRAW,EMPTY}}]
!*\onslide<2->*!static int minimax(char[][] board, char player) {
!*\onslide<3->*!    // Blatt? Ist es schon vorbei?
!*\onslide<4->*!    |ihl|if (winningMove(PLAYER_HUMAN, board)) return WIN_HUMAN;|ihl|
!*\onslide<4->*!    |ihl|else if (winningMove(PLAYER_COMP, board)) return LOSE_HUMAN;|ihl|
!*\onslide<4->*!    |ihl|else if (isFull(board)) return DRAW;|ihl|
!*\onslide<5->*!    int bestScore = player == PLAYER_HUMAN ? LOSE_HUMAN : WIN_HUMAN;
!*\onslide<7->*!    |ihl|for (int y = 0; y < 3; y++) {|ihl|
!*\onslide<8->*!        |ihl|for (int x = 0; x < 3; x++) {|ihl|
!*\onslide<9->*!            if (board[y][x] != EMPTY) continue; // Schon belegt
!*\onslide<10->*!            board[y][x] = player; // Abstieg: Simuliere Zug
!*\onslide<11->*!            int score = minimax(board, otherPlayer(player));
!*\onslide<12->*!            board[y][x] = EMPTY; // Aufstieg: Verarbeite Ergebnis
!*\onslide<13->*!            // Man verliert nur, wenn es keine andere Möglichkeit gibt:
!*\onslide<13->*!            if(player == PLAYER_HUMAN) bestScore = Math.min(score, bestScore);
!*\onslide<14->*!            else bestScore = Math.max(score, bestScore);
!*\onslide<8->*!        |ihl|}|ihl|
!*\onslide<7->*!    |ihl|}|ihl|
!*\onslide<6->*!    return bestScore;
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[c,fragile]{Übungsblatt 12 - Zusatzaufgabe\hfill Der Computer}
\begin{itemize}[<+(1)->]
    \item Wir probieren jeden Zug und wählen den besten:
\end{itemize}
\vspace*{-1mm}\lstfs{9}\SetupLstHl\begin{plainjava}[morekeywords={[4]{PLAYER_COMP,PLAYER_HUMAN,WIN_HUMAN,LOSE_HUMAN,DRAW,EMPTY}}]
!*\onslide<3->*!static char[][] computerMove(char[][] board) {
!*\onslide<4->*!    System.out.println("Computer ist am Zug:");
!*\onslide<5->*!    int bestScore = WIN_HUMAN;
!*\onslide<5->*!    int bestMove = 1;
!*\onslide<6->*!    for (int y = 0; y < 3; y++) {
!*\onslide<7->*!        for (int x = 0; x < 3; x++) {
!*\onslide<8->*!            if (board[y][x] != EMPTY) continue;
!*\onslide<9->*!            board[y][x] = PLAYER_COMP;
!*\onslide<10->*!            int score = minimax(board, PLAYER_HUMAN);
!*\onslide<11->*!            board[y][x] = EMPTY;
!*\onslide<12->*!            if (score > bestScore) {
!*\onslide<12->*!                bestScore = score; bestMove = y * 3 + x + 1; // => Nummerierung
!*\onslide<12->*!            }
!*\onslide<7->*!        }
!*\onslide<6->*!    }
!*\onslide<13->*!    return makeMove(board, bestMove, PLAYER_COMP);
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\section{Die End-Pingus}
\begin{frame}[c]
\pause
\begin{tikzpicture}[overlay,remember picture]
    \node[circle,fill=gray!90!pingu@white,inner sep=7mm] (c) at (current page.center) {\usebox\guidancepingu};

    \onslide<3->{\node[left=5mm] at(c.west) {\usebox\guidanceleft};}
    \onslide<3->{\node[right=5mm] at(c.east) {\usebox\guidanceright};}
\end{tikzpicture}
\end{frame}

\iffull\end{document}\fi