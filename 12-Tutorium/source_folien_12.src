\InputIfFileExists{../global.src}\relax\relax

\iffull
\def\smlll{\texorpdfstring{\def\RSsmallest{2pt}\smaller[2]}{}}
\title[Zwölftes Tutorium -- Übungsblatt 12]{Baum --- Traum --- Zauuuun --- Sieg\\\small Tutorium 12}
\date{\sffamily KW 6}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{12}
\fi
\iffalse
\section{Präsenzaufgabe}
\newsavebox\ActionCode \savebox\ActionCode{%
\begin{minipage}{5.5cm}
\lstfs{7}%
\begin{plainjava}[aboveskip=0pt,belowskip=0pt,morekeywords={[3]{PrimeSieve}}]^^J
PrimeSieve sieve = new PrimeSieve(m);^^J
/* A */ sieve.isPrime(1213);^^J
/* B */ sieve.isPrime(501);^^J
/* C */ sieve.isPrime(5011);^^J
\end{plainjava}
\end{minipage}
}
\begin{frame}[c,fragile]{Präsenzaufgabe}
    \begin{aufgabe}{Komplexes Sieben}
        \vspace*{-5mm}\par\onslide<2->{\footnotesize Geben Sie für den grau hinterlegten Code die Komplexität von \bjava[morekeywords={[3]{PrimeSieve}}]{PrimeSieve::isPrime} zu den drei Zeitpunkten \(A\), \(B\) und \(C\) in Abhängigkeit von \bjava{m} an. Erfassen Sie zudem die Worst- und Best-Case-Laufzeit von \bjava[morekeywords={[3]{PrimeSieve}}]{PrimeSieve::isPrime}. Begründen Sie Ihre Antwort (\bjava{m} ist sicher genügend groß).\par}\vspace*{-4mm}
{\lstfs{6}
\begin{plainjava}[multicols=2,morekeywords={[3]{PrimeSieve}},aboveskip=0pt,belowskip=0pt,lineskip=2.5pt]
!*\onslide<3->*!public class PrimeSieve {
!*\onslide<3->*!  private final boolean[] sieve;
!*\onslide<3->*!  private int next;
!*\onslide<3->*!
!*\onslide<3->*!  public PrimeSieve(int max) {
!*\onslide<3->*!    this.sieve = new boolean[max];
!*\onslide<3->*!    this.sieve[0] = this.sieve[1] = true;
!*\onslide<3->*!    this.next = 2;
!*\onslide<3->*!  }
!*\onslide<3->*!
!*\onslide<3->*!  public boolean isPrime(int n) {
!*\onslide<3->*!    if (n >= this.sieve.length)
!*\onslide<3->*!      throw new IndexOutOfBoundsException(n + "");
!*\onslide<3->*!    if (n > this.next) {
!*\onslide<3->*!      for (int i = this.next; i <= n; i++) {
!*\onslide<3->*!        if (!this.sieve[i]) {
!*\onslide<3->*!          for (int j = 2*i; j < this.sieve.length; j += i)
!*\onslide<3->*!            this.sieve[j] = true;
!*\onslide<3->*!        }
!*\onslide<3->*!      }
!*\onslide<3->*!      this.next = n;
!*\onslide<3->*!    }
!*\onslide<3->*!    return !this.sieve[n];
!*\onslide<3->*!  }
!*\onslide<3->*!}
\end{plainjava}
}
        \onslide<1->
    \end{aufgabe}
\onslide<4->{\begin{tikzpicture}[overlay,remember picture]
    \node[above left=7pt,yshift=11pt,fill=lightgray!35,draw=gray,thick,rounded corners=2pt,scale=.85] at (current page.south east) {%
    \usebox\ActionCode%
    };
\end{tikzpicture}}
\end{frame}

\def\O{\mathcal{O}}
\begin{frame}[t]{Präsenzaufgabe - Lösung}
    \begin{itemize}[<+(1)->]
        \item Erkenntnisse: \begin{itemize}
            \itemsep7pt
            \item Grundlegend hängt die Komplexität an \(m\) und \(n\) (verschachtelte Schleife): \(\O(m \cdot n)\).
            \item \(n\) ist bei jedem Aufruf \emph{konstant}. So wird (z.B.) aus \(\O(1213 \cdot m) = \O(m)\).\par \(\Longrightarrow\) Die äußere \bjava{for}-Schleife läuft für jeden Aufruf konstant!
            \item Ist \(i\) in einer Schleife prim, so genügen zwar \(\frac{m}{i}\) Iterationen in der inneren Schleife, die Konstante \(i\) in der Schleife spielt für \(\O\) aber keine Bedeutung.
            \item Bisherige Berechnungen werden gespeichert!\par \(\Longrightarrow\) Alle Aufrufe, die kleiner als das bisherige Maximum sind, treten mit \(\O(1)\) gar nicht in die Schleife ein!
        \end{itemize}
        \item Damit erhalten wir die folgenden Komplexitäten: \begin{description}[A:]
            \item[A:] Hier haben wir ein neues Maximum: \(\O(m)\).
            \item[B:] Mit \(501 \leq 1213\) gibt es nichts neues zu berechnen: \(\O(1)\).
            \item[C:] Ein neues Maximum: \(\O(m)\).
        \end{description}
        \item Allgemein ist die Worst-Case-Laufzeit damit \(\O(m \cdot n)\) und die Best-Case-Laufzeit \(\O(1)\).
    \end{itemize}
\end{frame}
\fi

\section{Übungsblatt 12}
\subsection{Aufgabe 1}
\iffull
\begin{frame}[c]{Übungsblatt 12 - Aufgabe 1}
    \scriptsize \onslide<2->{In dieser Aufgabe sollen Sie ihre eigenen binären Bäume aus Arrays wachsen lassen und diese anschließend in der Breite durchlaufen. Hierfür finden Sie im Moodle neben diesem Übungsblatt zwei weitere Java Files, die Sie für ihre Implementierung verwenden dürfen. Verwenden Sie ansonsten keine vorgefertigten dynamischen Datenstrukturen!}
    \begin{enumerate}
    \item<3-> Erstellen Sie eine Klasse \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{BinaryTree} mit einer Instanzvariable \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{private IntegerNode root}, welche die Wurzel des binären Baumes repräsentieren soll. Definieren Sie nun einen Konstruktor, welcher ein Array aus Integer Werten als Parameter übernimmt und daraus einen balancierten binären Baum erzeugt. Für die Speicherung der Knoten können Sie die vorgegeben Klasse \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{IntegerNode} verwenden, welche der einfach verketteten Version aus der Vorlesung von Folie X.68 entspricht. Bei der Vorlage sind die Instanzvariablen allerdings gekapselt, so dass Sie diese über die getter und setter Methoden ansprechen müssen.
    \item<3-> Nun sollen Sie die Methode \bjava{public void breadthFirstTraversal()} implementieren, welche den Baum in der Breite durchläuft und die Werte der einzelnen Knoten ausgibt. Hierfür werden Sie die vorgegebene Klasse \bjava{Queue} benötigen, welche \bjava[morekeywords={[3]{BinaryTree,IntegerNode}}]{IntegerNode} Elemente einreihen kann.
    \end{enumerate}
    \onslide<4->{\textit{Hinweis:} Sollten Sie die erste Teilaufgabe nicht komplett lösen können, erzeugen Sie sich manuell einen binären Baum um ihre Implementierung der Breitensuche zu testen.}
    \vspace*{-2.33mm}
    \onslide<5->{\begin{center}
        \def\arraystretch{1.75}
        \scalebox{.875}{\begin{tabular}{|*6{>{\centering\arraybackslash}p{1.33em}|}}
            \hline
            9 & 1 & 7 & 3 & 6 & 5 \\
            \hline
        \end{tabular}\quad\(\longrightarrow\)\quad\raisebox{-.5\height}{\begin{forest}
            for tree={dot, l sep=.15ex}
            [9[1[3][6]][7[5][,phantom]]]
        \end{forest}}}
    \end{center}}
\end{frame}
\begin{frame}[c]{Exkurs: Ein wenig fantastische Heaps gefällig?}
\onslide<2->{\centering\heap{%
    [42,name=root[19,name=inner1[7,name=inner2[3,name=leaf1][-2,name=leaf2]][8,name=leaf3]][-5,name=inner3[-9,name=leaf4]]]%
    \onslide<3->{\fill[paletteA,rounded corners=.4pt] (root.north)++(-.75mm,2mm-.75mm) rectangle ++(1.5mm,1.5mm) [radius=2.15pt] node[left=1.65mm+.75mm,paletteA,font=\bfseries] (dr) {Wurzel};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (dr.south) {root};}
    \pgfinterruptboundingbox
    \onslide<4->{\fill[paletteB] (inner1.north)++(0,2mm) circle [radius=2.15pt] node[left=1.65mm,paletteB,font=\bfseries] (di) {Innerer Knoten};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (di.south) {inner node};
    \foreach\i in {2,3} {\fill[paletteB] (inner\i.north)++(0,2mm) circle [radius=2.15pt];}}
    \onslide<5->{\fill[paletteD] (leaf1.west)++(-2mm,0) circle [radius=2.15pt] node[left=1.65mm,paletteD,font=\bfseries] (dl) {Blatt};
    \node[below=-4pt,gray,font=\scriptsize\itshape] at (dl.south) {leaf};
    \foreach\i in {2,3,4} {\fill[paletteD] (leaf\i.west)++(-2mm,0) circle [radius=2.15pt];}}
    \endpgfinterruptboundingbox
    \onslide<6->{
        \node[right=1.25cm,gray] (niveau) at (dr-|inner3) {\textbf{Ebene}};
    }
    \pgfonlayer{background}
        \foreach[count=\i] \x in {root,inner1,leaf3,leaf1} {
            \onslide<\the\numexpr\i+6\relax->{
                \node[gray,font=\bfseries] (dn\i) at(\x-|niveau) {\the\numexpr\i-1\relax};
                \draw[lgray!90!white,densely dashed, very thick] (dn\i.west) -- (dl.west|-dn\i.west);
            }
        }
    \endpgfonlayer
}}
\end{frame}
\begin{frame}[c]{Exkurs: Heaps\ldots\ Bäume. Was hat eine Wurzel und zwei Beine?}
\begin{columns}[c]
\begin{column}{.55\linewidth}
\begin{itemize}
    \itemsep8pt
    \item<4-> Jede gefüllte Ebene \(i\) enthält \(2^i\) Elemente.
    \item<5-> Die Nummerierung nach Breitendurchlauf erlaubt Adressierung!
    \item<7-> Das linke Kind von \(n\) ist \(2 \cdot n + 1\), das rechte Kind \(2 \cdot n + 2\).
    \item<8-> Der Elternknoten von \(n\) ist \(\lfloor \frac{n - 1}{2}\rfloor\).
\end{itemize}
\end{column}
\begin{column}{.35\linewidth}
\onslide<2->{\heap[s sep=3em-level*.5em]{[18,name=a[7,name=b[3,name=c[3,name=d][2,name=e]][6,name=f]][-2,name=g[-1,name=h][-2,name=i]]]%
\pgfonlayer{background}
\onslide<3->{\foreach[count=\i] \x in {a,b,c,d} {
        \node[gray,font=\bfseries] (dn\i) at(\x-|4,0) {\the\numexpr\i-1\relax};
        \draw[lgray!90!white,densely dashed, very thick] (dn\i.west) -- (d.west|-dn\i.west) -- ++(-2.5mm,0);
}}
\onslide<6->{\foreach[count=\i] \x in {a, b, g, c, f, h, i, d, e} {
        \node[paletteA,font=\bfseries,left=.25mm] at (\x.west) {\the\numexpr\i-1\relax};
}}
\endpgfonlayer}}
\end{column}
\end{columns}
\begin{tikzpicture}[overlay,remember picture]
    \colorlet{qr@fancy@gradient@tl}{gray!14!paletteA}
    \colorlet{qr@fancy@gradient@br}{gray!90!paletteA}
    \onslide<9->{\node[above left,yshift=.5cm,xshift=-.15cm] at(current page.south east) {\fancyqr[height=1.75cm,level=H]{https://github.com/EagleoutIce/Episode-Heaps}};}
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 1a)}
    \begin{itemize}[<+(1)->]
        \item Ein Dateien Palast: \only<2->{\textattachfile{\curpath IntegerNode.java}{IntegerNode.java}}, \only<2->{\textattachfile{\curpath Queue.java}{Queue.java}} und \only<2->{\textattachfile{\curpath BinaryTree.java}{BinaryTree.java}}.
        \item Wir bauen einen binären Baum \info{ich glaub es kaum. Zauuuuun}:
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<4->*!public BinaryTree(int[] items) {
!*\onslide<5->*!    this.root = buildTree(items, 0);
!*\onslide<4->*!}
!*\onslide<6->*!private static IntegerNode buildTree(int[] items, int index) {
!*\onslide<7->*!    if (index >= items.length) return null;
!*\onslide<7->*!
!*\onslide<8->*!    IntegerNode node = new IntegerNode(items[index]);
!*\onslide<10->*!    node.setLeftChild(buildTree(items, 2 * index + 1)); // left
!*\onslide<10->*!    node.setRightChild(buildTree(items, 2 * index + 2)); // right
!*\onslide<9->*!    return node;
!*\onslide<6->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\iffull
\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 1a)\hfill Watcha doin?}
\SetupLstHl\lstfs{8}%
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<2->*!!*\md4*!public BinaryTree(int[] items) { !*\rBS<handout:1-3|4->{items=\{14,3,7,8,-2\}}*!
!*\onslide<2->*!    !*\md5*!this.root = build!*\mb6*!!*\mbg[1-2]{7-59}*!Tr!**!ee(items, 0);!*\ml[3]{60}*!
!*\onslide<2->*!}

!*\onslide<3->*!!*\md{7,12,17,22,29,38,51}*!private static IntegerNode buildTree(int[] items, int index) { !*\rBS<handout:1|7-11,47-50,57-59>{items=\{\mkb{14},3,7,8,-2\}}*!!*\rBS<handout:2|12-16,34-37,44-46>{items=\{14,\mkb{3},7,8,-2\}}*!!*\rBS<handout:0|17-21,25-28,32-33>{items=\{14,3,7,\mkb{8},-2\}}*!!*\rBS<handout:0|22-24,29-31>{items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<38-43|handout:0>{items=\{14,3,7,8,\mkb{-2}\}}*!!*\rBS<51-56|handout:0>{items=\{14,3,\mkb{7},8,-2\}}*!
!*\onslide<3->*!    !*\md{8,13,18,23,30,39,52}*!if (index >= items.length) return null;!*\ml{24,31}~*! !*\rBS<handout:1|8-11,47-50,57-59>{0>=5}*!!*\rBS<handout:2|13-16,34-37,44-46>{1>=5}*!!*\rBS<handout:0|18-21,25-28,32-33>{3>=5}*!!*\rBS<handout:0|23-24,30-31>{7>=5}*!!*\rBS<handout:0|39-43>{4>=5}*!!*\rBS<handout:0|52-56>{2>=5}*!
!*\onslide<3->*!
!*\onslide<3->*!    !*\md{9,14,19,40,53}*!IntegerNode node = new IntegerNode(items[index]); !*\rBS<handout:1|9-11,47-50,57-59>{IntegerNode(14)}*!!*\rBS<handout:2|14-16,34-37,44-46>{IntegerNode(3)}*!!*\rBS<handout:0|19-21,25-28,32-33>{IntegerNode(8)}*!!*\rBS<handout:0|40-43>{IntegerNode(-2)}*!!*\rBS<handout:0|53-56>{IntegerNode(7)}*!

!*\onslide<3->*!    !*\md[1]{10,15,20,41,54}*!node.setLeftChild(build!*\mb{11,16,21,25,34,47}\mbg[1,2]{12-15,17-20,22-24,26-33,35-46}*!Tre!**!e(items, 2 * index + 1));!*\ml{26,35,48}~*! !*\rBS<handout:1|10-11>{2*0+1, items=\{14,\mkb{3},7,8,-2\}}*!!*\rBS<handout:0|15-16>{2*1+1, items=\{14,3,7,\mkb{8},-2\}}*!!*\rBS<handout:0|20-21>{2*2+1, items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<handout:0|41-43,54-56>{skipping\ldots}*!

!*\onslide<3->*!    !*\md{27,36,42,49,55}*!node.setRightChild(build!*\mb{28,32,37,44,50,57}\mbg{29-31,38-43,51-56}*!Tr!**!ee(items, 2 * index + 2));!*\ml[2]{45,58}~*! !*\rBS<handout:0|27-28>{2*3+2, items=\{14,3,7,8,-2\}~\mkb{~}}*!!*\rBS<handout:0|36-37>{2*1+2, items=\{14,3,7,8,\mkb{-2}\}}*!!*\rBS<handout:0|42-43,55-56>{skipping\ldots}*!!*\rBS<handout:0|49-50>{2*0+2, items=\{14,3,\mkb{7},8,-2\}}*!

!*\onslide<3->*!    !*\md{33,43,46,56,59}*!return node;
!*\onslide<3->*!}
\end{plainjava}
\begin{tikzpicture}[overlay,remember picture,scale=.65,every node/.append style={transform shape}]
    \scope[shift=(current page.south east),xshift=-.5cm-2cm,yshift=.5cm+3.5cm]
        \onslide<10->{\node[dot] (0) at (0,0) {14};}
        \onslide<handout:2-|14->{\node[dot] (1) at (-1,-1) {3};}
        \onslide<handout:2-|19->{\node[dot] (2) at (-1.75,-2) {8};}
        \onslide<handout:2-|25->{\draw (2) -- (1);}
        \onslide<handout:2-|40->{\node[dot] (3) at (-.25,-2) {-2};}
        \onslide<handout:2-|45->{\draw (3) -- (1);}
        \onslide<handout:3-|48->{\draw (1) -- (0);}
        \onslide<handout:3-|53->{\node[dot] (4) at (1,-1) {7};}
        \onslide<handout:3-|58->{\draw (4) -- (0);}
        \onslide<handout:3-|60->{\node[above=-1mm,align=center] at (0.north) {root\\[-1.8mm]\faCaretDown};}
    \endscope
\end{tikzpicture}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 1b)}
    \begin{itemize}[<+(1)->]
        \item Der Breitendurchlauf:\lstfs{10}
\begin{plainjava}[morekeywords={[3]{BinaryTree,IntegerNode}}]
!*\onslide<3->*!public void breadthFirstTraversal() {
!*\onslide<4->*!    Queue queue = new Queue();
!*\onslide<4->*!    queue.enqueue(root);
!*\onslide<3->*!
!*\onslide<5->*!    while (!queue.isEmpty()) {
!*\onslide<6->*!        IntegerNode node = queue.dequeue();
!*\onslide<6->*!        if(node == null) continue;
!*\onslide<3->*!
!*\onslide<7->*!        queue.enqueue(node.getLeftChild());
!*\onslide<7->*!        queue.enqueue(node.getRightChild());
!*\onslide<3->*!
!*\onslide<8->*!        System.out.print(node.getValue() + " ");
!*\onslide<3->*!    }
!*\onslide<5->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Aufgabe 2}
\iffull
\begin{frame}[c]{Übungsblatt 12 - Aufgabe 2}
\scriptsize\onslide<2->{In dieser Aufgabe sollen Sie eine Methode implementieren, welche einen \textit{Binary Expression Tree} auswerten kann. Dabei handelt es sich um eine spezielle Art von Baum, bei dem die Blätter Werte und die inneren Knoten arithmetische Operatoren speichern.
Gehen Sie dafür folgendermaßen vor.}
\begin{enumerate}
    \item<3-> Erstellen Sie eine Klasse \solGet{keywordC}{StringNode}, welche den Datentyp \bjava{String} verwendet um den Wert des Knotens zu speichern. Dies ist für diese Aufgabe notwendig, da Sie hier sowohl Integer Werte als auch arithmetische Operatoren speichern sollen. Hierbei können Sie die Eigenschaften der Klasse \solGet{keywordC}{IntegerNode} übernehmen.
    Fügen Sie nun noch die Methode \bjava{public boolean isLeaf()} hinzu, welche \texttt{true} zurückliefert falls es sich bei dem Knoten um ein Blatt im Baum handelt.
    \item<4-> Erstellen Sie nun eine Klasse \solGet{keywordC}{BinaryExpressionTree}, welche ähnlich zur Klasse \solGet{keywordC}{BinaryTree} einen Konstruktor besitzt der anhand eines übergebenen Arrays einen Baum erzeugen kann.
    Implementieren Sie nun die Methode \bjava{public double evaluate()}, welche den gespeicherten arithmetischen Ausdruck auswertet und das Ergebnis zurückliefert. Hierfür werden Sie sich eine rekursive Hilfsmethode implementieren müssen.
\end{enumerate}
\onslide<5->{Verwenden Sie auch bei dieser Aufgabe keine Arrays oder vorgefertigten dynamischen Datenstrukturen in ihrer Implementierung.
\onslide<6->{\textbf{Hinweise:}
\begin{itemize}
    \item Falls Sie die Erzeugung des Baumes in der vorherigen Aufgabe nicht lösen konnten, erzeugen Sie sich in dieser Aufgabe manuell einen entsprechenden Baum im Konstruktor um ihre Implementierung testen zu können.
    \item Ihr Baum sollte die Operationen \textit{Addition}, \textit{Subtraktion}, \textit{Multiplikation} und \textit{Division} unterstützen.
    \item Die Methode \bjava{public static double parseDouble(String s)} der Wrapper Klasse \bjava{Double} gibt ihnen den Fließkommawert zurück, welcher im übergebenen String \T{s} gespeichert ist.
\end{itemize}}
\end{frame}
\fi

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.1)}
    \SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Zusätzliche Freu(n)de: \only<2->{\textattachfile{\curpath StringNode.java}{StringNode.java}} und \only<2->{\textattachfile{\curpath BinaryExpressionTree.java}{BinaryExpressionTreeStringNode.java}}
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{StringNode}}]
!*\onslide<3->*!public class StringNode {
!*\onslide<4->*!    private String item;
!*\onslide<4->*!    private StringNode left;
!*\onslide<4->*!    private StringNode right;
!*\onslide<3->*!
!*\onslide<5->*!    |ihl|public void setRightChild(StringNode right) { this.right = right; }|ihl|
!*\onslide<5->*!    |ihl|public StringNode getRightChild() { return this.right; }|ihl|
!*\onslide<5->*!    |ihl|public void setLeftChild(StringNode left) { this.left = left; }|ihl|
!*\onslide<5->*!    |ihl|public StringNode getLeftChild() { return this.left; }|ihl|
!*\onslide<5->*!    |ihl|public void setItem(String item) { this.item = item; }|ihl|
!*\onslide<5->*!    |ihl|public String getItem() { return this.item; }|ihl|
!*\onslide<3->*!
!*\onslide<7->*!    public boolean isLeaf() { return left == null && right == null; }
!*\onslide<3->*!
!*\onslide<6->*!    |ihl|public StringNode(String v) { this.item = v; this.right = this.left = null; }|ihl|
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.2)}
    \SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Die Grundlage des Baumes ist wie bekannt:
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{BinaryExpressionTree,StringNode}}]
!*\onslide<3->*!public class BinaryExpressionTree {
!*\onslide<4->*!    private StringNode root;
!*\onslide<5->*!    |ihl|public BinaryExpressionTree(|ihl|String[] |ihl|items) {|ihl|
!*\onslide<6->*!        |ihl|this.root = buildTree(items, 0);|ihl|
!*\onslide<5->*!    }
!*\onslide<7->*!    |ihl|private static|ihl| StringNode |ihl|buildTree(|ihl|String[] |ihl|items, int index) {|ihl|
!*\onslide<8->*!        |ihl|if (index >= items.length) return null;|ihl|
!*\onslide<3->*!
!*\onslide<9->*!        StringNode |ihl|node = new|ihl| StringNode(|ihl|items[index]|ihl|);
!*\onslide<10->*!        |ihl|node.setLeftChild(buildTree(items, 2 * index + 1));|ihl|
!*\onslide<10->*!        |ihl|node.setRightChild(buildTree(items, 2 * index + 2));|ihl|
!*\onslide<11->*!        |ihl|return node;|ihl|
!*\onslide<7->*!    }
!*\onslide<3->*!
!*\onslide<12->*!    // :ldots:
!*\onslide<3->*!}
\end{plainjava}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 12 - Aufgabe 2.2)}
    \SetupLstHl\lstfs{8}\begin{itemize}[<+(1)->]
        \item Die Auswertung
    \end{itemize}
\begin{plainjava}[morekeywords={[3]{BinaryExpressionTree,StringNode}}]
!*\onslide<3->*!|ihl|public class BinaryExpressionTree {|ihl|
!*\onslide<4->*!   |ihl|private StringNode root;|ihl|
!*\onslide<4->*!   // :ldots:
!*\onslide<5->*!   public double evaluate() { return traverse(root); }
!*\onslide<6->*!   public double traverse(StringNode node) {!*\onslide<13->*! // Postorder
!*\onslide<7->*!      |ihl|if (node == null) throw new IllegalStateException("Traversing empty");|ihl|
!*\onslide<8->*!      if (node.isLeaf())  return Double.parseDouble(node.getItem());
!*\onslide<9->*!      double valueLeft = traverse(node.getLeftChild());
!*\onslide<9->*!      double valueRight = traverse(node.getRightChild());
!*\onslide<5->*!
!*\onslide<10->*!      switch (node.getItem()) { // Get the Operator
!*\onslide<11->*!          case "+": return valueLeft + valueRight;
!*\onslide<11->*!          case "-": return valueLeft - valueRight;
!*\onslide<11->*!          case "*": return valueLeft * valueRight;
!*\onslide<11->*!          case "/": return valueLeft / valueRight;
!*\onslide<12->*!          default: throw new IllegalArgumentException(":ldots:");
!*\onslide<10->*!      }
!*\onslide<6->*!   }
!*\onslide<3->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\subsection{Aufgabe 3}
\iffull
\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3}
\footnotesize\onslide<2->{In dieser Aufgabe sollen Sie noch ein letztes Mal etwas auf der Kommandozeile zeichnen. Dieses Mal sollen Sie die Array-Repräsentation eines balancierten Binärbaumes grafisch darstellen. Hierfür sollten Sie sich zuerst Gedanken über die Eigenschaften des resultierenden Baumes machen. Ihre Implementierung sollte Bäume beliebiger Größe mit Knoten mit ganzzahligen positiven Werte zwischen 1 und 99 korrekt eingerückt darstellen können.
Die Ausgabe ihres Programms sollte in etwa so aussehen:}
\begin{plainbash}
*\onslide<3->*Binärbaum-Darstellung von: [35, 5, 18, 19, 92, 85, 72, 84, 5]
*\onslide<3->*              35
*\onslide<3->*      +-------+-------+
*\onslide<3->*      5               18
*\onslide<3->*  +---+---+       +---+---+
*\onslide<3->*  19      92      85      72
*\onslide<3->*+-+-+
*\onslide<3->*84  5
\end{plainbash}
\end{frame}
\fi

\begin{frame}[c,fragile]{Übungsblatt 12 - Aufgabe 3}
    TODO \textattachfile{\curpath DrawTree.java}{DrawTree.java}
\end{frame}

\subsection{Zusatzaufgabe 6/6}
\begin{frame}[c]{Übungsblatt 12 - Zusatzaufgabe}
    \begin{itemize}[<+(1)->]
        \item Die \textit{Polymorphie} der Methoden der \solGet{keywordC}{Memory} Unterklassen und damit dynamisches Binden.\pause{} Je nach
        konkreter Unterklasse der jeweiligen Instanz werden entweder die Methoden von Stack oder die
        von Queue aufgerufen. Zur Übersetzerzeit (statisch) ist durch die Verwendung der Klasse Memory nur
        sichergestellt, dass es die benötigten Methoden \bjava[morekeywords={[3]{Memory}}]{Memory::write}, \bjava[morekeywords={[3]{Memory}}]{Memory::read} und \bjava[morekeywords={[3]{Memory}}]{Memory::isEmpty}
        gibt, ohne (abgesehen von \bjava[morekeywords={[3]{Memory}}]{Memory::isEmpty}) zu wissen, wie diese genau implementiert sind.\pause{} Zur Laufzeit
        (dynamisch) wir abhängig von der jeweiligen Instanz der entsprechende Code ausgeführt.
        \item \bjava[morekeywords={[3]{BinaryTree}}]{BinaryTree::traverseQ} implementiert eine Level-Order-Traversierung, wobei die Kindknoten von
        rechts nach links besucht werden.
        \bjava[morekeywords={[3]{BinaryTree}}]{BinaryTree::traverseS} implementiert eine Pre-Order-Traversierung.
    \end{itemize}
\end{frame}

\begin{frame}[fragile,t]{Übungsblatt 12 - Zusatzaufgabe}
    \begin{itemize}[<+(1)->]
        \item Die beiden Aufrufe liefern:
\begin{plainjava}
!*\onslide<3->*!tree.traverseQ();
!*\onslide<3->*!  //:yields: new int[]{59, 82, 21, 65, 49, 12, 50, 38, 20, 16}

!*\onslide<4->*!tree.traverseS();
!*\onslide<4->*!  //:yields: new int[]{59, 21, 12, 20, 16, 49, 38, 50, 82, 65}
\end{plainjava}
    \end{itemize}
\end{frame}

\section{Die End-Pingus}

\begin{frame}[c]
\pause{}\begin{center}
    % \resizebox{.95\linewidth}!{%
    % \tikz{\pingu[left wing grab, sunglasses, cup straw = !hide, cup* = teal, cup shift=0, cup cover = brown!87!black, cup drops = !hide,name=lenni]}
    % \quad
    % \tikz{\pingu[left wing wave, right eye=!hide, name=steini,sign post={\raisebox{10pt}{\scalebox{0.65}{\parbox{1.25cm}{\centering\small I \textcolor{purple}{\faHeart}\\\color{cwhite}M4g1c\\[-.65cm]}}}}]; \fill (steini-right-eye) circle [radius=0.082cm];\draw[line width=0.245pt,fill=pingu@blue,fill opacity=0.035] (steini-right-eye) circle [radius=0.15cm];\draw[very thin] ($(steini-right-eye)+(0.15,0)$) to[bend left,looseness=0.2] ++(-0.01,-0.375) coordinate (dt); \fill (dt) circle (0.65pt);}
    % \quad
    % \tikz{\pingu[left eye wink, right eye wink,santa,heart=pingu@red!24!white,name=tolgo,eyes wink];}
    % \quad
    % \tikz{\pingu[left patch,halo,right hair=teal,torch,name=flo]}}
\end{center}
\end{frame}

\iffull\end{document}\fi