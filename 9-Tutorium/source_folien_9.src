% #region preamble
\InputIfFileExists{../global.src}\relax\relax

\iffull
\title[Neuntes Tutorium -- Übungsblatt 9]{Das Ende Naht aht ht t\\\small Ohren hab ich gesagt 9}
\date{\sffamily KW 3}

\tikzset{
    dot/.style={circle,draw,align=center,text width=1em,execute at begin node={\strut}}
}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{9}
\fi

\section{Präsenzaufgabe}
\subsection{Freude mit Sortierverfahren}
\begin{frame}{Präsenzaufgabe}
    \begin{aufgabe}{Wenn du dein Kinderzimmer nicht aufräumst, \ldots}
        \pause{}\small Sie sollen die \textit{Binäre Suche} implementieren, welche nützlich ist, um ein sortiertes Array effizient zu durchsuchen. Schreiben Sie die Methode \bjava{int find(int[] array, int element)} als Wrapper für die Suche.\pause{} Diese Methode soll ein (aufsteigend) sortiertes Array und das gesuchte Element als Parameter übernehmen, und daraufhin den Index des Elements im Array zurückgeben, sofern dieses vorhanden ist. Sollte das Elemente mehrfach vorhanden sein, soll der kleinste Index zurückgegeben werden. Falls das Element nicht im Array vorhanden ist, soll \bjava{-1} zurückgegeben werden.
        Implementieren Sie die Binäre Suche \textit{rekursiv}. (Rekursive) Hilfsmethoden sind gestattet.\pause{}
        Die Suche nach der \bjava{68}:\vspace*{-.8\baselineskip}
\begin{center}
    \begin{tikzpicture}
        \foreach[count=\i] \a in {4, 13, 21, 29, 33, 34, 56, 68, 71, 74, 78} {
            \node (\a) at (\i, 0) {\expandafter\bjava\expandafter{\a}};
        }
        \onslide<5->{\draw[Kite-] (34) -- ++(0,.55);}
        \onslide<6->{\draw[-Kite] (34.south) to[bend right=25] (71.south);}
        \onslide<7->{\draw[-Kite] (71.north) to[bend right=25] (56.north);}
        \onslide<8->{\draw[-Kite] (56.south) to[bend right=15] (68.south);}
    \end{tikzpicture}\vspace*{-.25\baselineskip}
\end{center}
        \onslide<1->
    \end{aufgabe}
\end{frame}
\MakeThePinguExplainIt[text width=5.25cm]{cap=!hide,glasses=!hide,cup=cprimary,right item angle=10}{1.~Basisfall: keine Elemente mehr.\\ 2.~Basisfall: Element gefunden.\\Sonst: Suche links/rechts.}
\begin{frame}[c]{Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \itemsep15.5pt
    \item Wir erschaffen eine Suche: \only<2->{\textattachfile{\curpath BinarySearch.java}{BinarySearch.java}}.
    \item Die Idee: \begin{itemize}
        \item Wir markieren das zu durchsuchende Fenster mit \bjava{left} und \bjava{right}.\hfill \raisebox{-.15\height}{\tikz{\foreach[count=\i] \a in {lightgray, lightgray, shadeA, shadeA, shadeA, shadeA, lightgray} {\node[circle,fill=\a] (\i) at (\i/2,0) {};}\pgfinterruptboundingbox\node[above=-.6mm] at(3.north) {\scriptsize\strut\T{left}}; \node[above=-.6mm] at(6.north) {\scriptsize\strut\T{right}};\endpgfinterruptboundingbox}}
        \item Ist das Fenster leer, haben wir das Element nicht gefunden.\hfill \T{right < left}
        \item Sonst prüfen wir: Ist das mittlere Element das Gesuchte?
        \item Ist es kleiner, suchen wir links, ist es größer, rechts weiter.
    \end{itemize}
    \item Dafür nutzen wir die Hilfsmethode: \bjava{binarySearch(int[] array, int left, int right, int element)}.
    \item Wir beginnen mit der Suche im gesamten Array: \bjava{binarySearch(array, 0, array.length - 1, element);}
\end{itemize}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<10->{\node[left=-9.5mm,scale=.8] at(current page.-12) {\usebox\pinguexplainbox};}
\end{tikzpicture}%
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
\SetupLstHl\lstfs{10}
\begin{plainjava}
!*\onslide<2->*!|ihl|int binarySearch(int[] array, int left, int right, int element) {|ihl|
!*\onslide<3->*!    // !*\textbf{\solGet{comments}{1)}}*! Fenster ist leer
!*\onslide<4->*!    if (right < left)
!*\onslide<4->*!        return -1;
!*\onslide<2->*!
!*\onslide<5->*!    int middle = left + (right - left) / 2;
!*\onslide<3->*!    // !*\textbf{\solGet{comments}{2)}}*! Ist das Mittlere das Gesuchte?
!*\onslide<6->*!    if (array[middle] == element)
!*\onslide<6->*!        return middle;
!*\onslide<3->*!    // !*\textbf{\solGet{comments}{3)}}*! Kleiner: suche links weiter
!*\onslide<7->*!    else if (array[middle] > element)
!*\onslide<7->*!        return binarySearch(array, left, middle - 1, element);
!*\onslide<3->*!    // !*\textbf{\solGet{comments}{4)}}*! Größer: suche rechts weiter
!*\onslide<8->*!    else
!*\onslide<8->*!        return binarySearch(array, middle + 1, right, element);
!*\onslide<2->*!|ihl|}|ihl|
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \itemsep6.5pt
    \item Einen Teil haben wir noch nicht gemacht:\pause \begin{center}
        \parbox{.715\linewidth}{\textcolor{gray}{Sollte das Elemente mehrfach vorhanden sein, soll der kleinste Index zurückgegeben werden}}
    \end{center}
    \item Idee: Wir verringern den Index, solange das Element immer noch das Gesuchte ist:
\SetupLstHl\lstfs{10}\begin{plainjava}
public static int find(int[] array, int element) {
    int index = binarySearch(array, 0, array.length - 1, element);
    if (index == -1) return -1;

    for (int i = 1; i <= index; i++) {
        if (array[index - i] != element)
            return index - i + 1;
    }
    return 0;
}
\end{plainjava}
\end{itemize}
\end{frame}

\section{Übungsblatt 9}
\subsection{Aufgabe 1}
\begin{frame}[t,fragile]{Übungsblatt 9 - Aufgabe 1}
    \begin{itemize}[<+(1)->]
        \item Die Datei befindet sich hier: \only<2->{\textattachfile{\curpath CompoundInterest.java}{CompoundInterest.java}}
    \end{itemize}\vfill
\SetupLstHl\lstfs{10}%
\begin{plainjava}
!*\onslide<3->*!|ihl|public static|ihl|
!*\onslide<3->*!double compoundInterest(double capital, double interestRate, int years) {
!*\onslide<4->*!    if(years == 0)
!*\onslide<5->*!        return capital;
!*\onslide<4->*!    else
!*\onslide<6->*!        return compoundInterest(capital * (1 + interestRate), interestRate,
!*\onslide<6->*!            years - 1);
!*\onslide<3->*!}
\end{plainjava}
\vfill\null
\end{frame}

\subsection{Aufgabe 2}
\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 2}
    \begin{itemize}[<+(1)->]
        \item Die Datei befindet sich hier: \only<2->{\textattachfile{\curpath Palindrome.java}{Palindrome.java}}
    \end{itemize}\vfill
\SetupLstHl\lstfs{10}%
\begin{plainjava}
!*\onslide<3->*!private static boolean isPalindrome(String s) {
!*\onslide<4->*!    return isPalindromeRecursive(s.toLowerCase());
!*\onslide<3->*!}


!*\onslide<5->*!private static boolean isPalindromeRecursive(String s) {
!*\onslide<6->*!    if(s.length() < 2)
!*\onslide<6->*!        return true;
!*\onslide<7->*!    else if(s.charAt(0) != s.charAt(s.length() - 1))
!*\onslide<7->*!        return false;
!*\onslide<8->*!    else
!*\onslide<8->*!        return isPalindromeRecursive(s.substring(1, s.length() - 1));
!*\onslide<5->*!}
\end{plainjava}
\vfill\null
\end{frame}


\subsection{Aufgabe 3}
\MakeThePinguExplainIt[text width=9cm]{cap=!hide,glasses=!hide,cloak=pingu@black,eyes shiny,right item angle=33,rotate=10}{Da wir die Maximalgröße der Ausgabekombinationen kennen, wird das Hinzufügen eher in der Form \bjava{[0,0,0]}~$\to$ \bjava{[1,0,0]}~$\to$ \bjava{[1,2,0]}~$\to$ \bjava{[1,2,3]} erfolgen.}
\begin{frame}[b,fragile]{Übungsblatt 9 - Aufgabe 3}
    \null\vfill\begin{itemize}[<+(1)->]
        \item Zuerst die Idee: \begin{itemize}
            \item Wir verwenden ein Array um die Ausgabekombination zu halten.
            \item Basisfall: das Array hat die gewünschte Länge, dann geben wir es aus.
            \item Sonst: erweitern wir das Array für jedes Symbol einmal und erzeugen so eine baumartige Rekursion.
        \end{itemize}
        \item Ein Beispiel mit \([4, 9, 2]\) und \(n = 3\), mit Wiederholung:\vspace*{-.5\baselineskip}
    \end{itemize}
    \begin{center}
        \downsize{.85\linewidth}{\begin{tikzpicture}[yscale=.85]
            \onslide<8->{\node (1) at(0,0) {\bjava{[]}};}

            \onslide<9->{\node (11) at(-5,-1) {\bjava{[4]}};
            \node (12) at( 0,-1) {\bjava{[9]}};
            \node (13) at( 5,-1) {\bjava{[2]}};
            \draw[-Kite] (1) -- (11);
            \draw[-Kite] (1) -- (12);
            \draw[-Kite] (1) -- (13);}

            \onslide<10->{
            \node (111) at(-6.5,-2) {\bjava{[4, 4]}};
            \node (112) at(-5,-2) {\bjava{[4, 9]}};
            \node (113) at(-3.5,-2) {\bjava{[4, 2]}};

            \draw[-Kite] (11) -- (111);
            \draw[-Kite] (11) -- (112);
            \draw[-Kite] (11) -- (113);
            }

            \onslide<11->{
            \node (121) at(-1.5,-2) {\bjava{[9, 4]}};
            \node (122) at( 0,-2) {\bjava{[9, 9]}};
            \node (123) at( 1.5,-2) {\bjava{[9, 2]}};

            \draw[-Kite] (12) -- (121);
            \draw[-Kite] (12) -- (122);
            \draw[-Kite] (12) -- (123);
            }

            \onslide<12->{%
                \node (131) at( 3.5,-2) {\bjava{[2, 9]}};
                \node (132) at( 5,-2) {\bjava{[2, 4]}};
                \node (133) at( 6.5,-2) {\bjava{[2, 2]}};
            \draw[-Kite] (13) -- (131);
            \draw[-Kite] (13) -- (132);
            \draw[-Kite] (13) -- (133);
            }

            \onslide<13->{
            \node (1111) at(-7.5,-3) {\bjava{[4, 4, 4]}};
            \node (1112) at(-6.5,-3.75) {\bjava{[4, 4, 9]}};
            \node (1113) at(-5.5,-3) {\bjava{[4, 4, 2]}};

            \draw[-Kite] (111) -- (1111);
            \draw[-Kite] (111) -- (1112);
            \draw[-Kite] (111) -- (1113);

            \draw[lightgray,-Kite] (112) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (112) -- ++(0,-.6);
            \draw[lightgray,-Kite] (112) -- ++(.5,-.6);

            \draw[lightgray,-Kite] (113) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (113) -- ++(0,-.6);
            \draw[lightgray,-Kite] (113) -- ++(.5,-.6);

            \node (1221) at(-1,-3) {\bjava{[9, 9, 4]}};
            \node (1222) at( 0,-3.75) {\bjava{[9, 9, 9]}};
            \node (1223) at( 1,-3) {\bjava{[9, 9, 2]}};

            \draw[-Kite] (122) -- (1221);
            \draw[-Kite] (122) -- (1222);
            \draw[-Kite] (122) -- (1223);

            \draw[lightgray,-Kite] (121) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (121) -- ++(0,-.6);
            \draw[lightgray,-Kite] (121) -- ++(.5,-.6);

            \draw[lightgray,-Kite] (123) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (123) -- ++(0,-.6);
            \draw[lightgray,-Kite] (123) -- ++(.5,-.6);

            \node (1331) at(5.5,-3) {\bjava{[2, 9, 4]}};
            \node (1332) at(6.5,-3.75) {\bjava{[2, 4, 9]}};
            \node (1333) at(7.5,-3) {\bjava{[2, 2, 2]}};

            \draw[-Kite] (133) -- (1331);
            \draw[-Kite] (133) -- (1332);
            \draw[-Kite] (133) -- (1333);

            \draw[lightgray,-Kite] (131) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (131) -- ++(0,-.6);
            \draw[lightgray,-Kite] (131) -- ++(.5,-.6);

            \draw[lightgray,-Kite] (132) -- ++(-.5,-.6);
            \draw[lightgray,-Kite] (132) -- ++(0,-.6);
            \draw[lightgray,-Kite] (132) -- ++(.5,-.6);
            }
        \end{tikzpicture}}\vspace*{-\baselineskip}
    \end{center}
\begin{tikzpicture}[overlay, remember picture]
    \onslide<14->{\node[left=-11mm,scale=.8] at(current page.7) {\usebox\pinguexplainbox};}
\end{tikzpicture}%
\end{frame}

\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 3}
    \begin{itemize}[<+(1)->]
        \itemsep6pt
        \item Die Datei befindet sich hier: \only<2->{\textattachfile{\curpath Combinations.java}{Combinations.java} und \textattachfile{\curpath Combinations.java}{Combinations.java}}.
        \item Zunächst das rekursive Ausgeben eines Arrays.
        \item Idee: wir inkrementieren rekursiv einen Zähler anstelle der for-Schleife.\vfill
\begin{plainjava}
!*\onslide<5->*!public static void printArray(int[] combination, int i) {
!*\onslide<6->*!    if(i >= combination.length) { // Basisfall
!*\onslide<7->*!        System.out.println();
!*\onslide<6->*!    } else { // Rekursionsfall: ausgeben und nächstes
!*\onslide<8->*!        System.out.print(combination[i] + " ");
!*\onslide<9->*!        printArray(combination, i + 1);
!*\onslide<6->*!    }
!*\onslide<5->*!}
\end{plainjava}
\vfill\null
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 3}
    \begin{itemize}[<+(1)->]
        \itemsep6pt
        \item Für das baumartige Antackern bauen wir uns eine Hilfe (zuerst mit Wiederholung):\pause
\begin{plainjava}
static void helper(int[] array, int n, int[] combs, int index)
\end{plainjava}
        \item Dabei sind \bjava{array} und \bjava{n} die Eingabe.
        \item \bjava{combs} ist das zu konstruierende Array.
        \item \bjava{index} ist das aktuell in \bjava{combs} zu füllende Feld.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 3}
    \begin{itemize}[<+(1)->]
        \itemsep6pt
        \item Die Baumrekursion gestaltet sich wie folgt:\pause
\begin{plainjava}
!*\onslide<3->*!static void helper(int[] array, int n, int[] combs, int index) {
!*\onslide<4->*!    if (index == n) { // Basisfall
!*\onslide<5->*!        printArray(combs, 0);
!*\onslide<4->*!    } else { !*\onslide<6->*!// Sonst: Für jedes Symbol:ldots:
!*\onslide<7->*!        for (int i = 0; i < array.length; i++) {
!*\onslide<8->*!            combs[index] = array[i];
!*\onslide<8->*!            helper(array, n, combs, index + 1);
!*\onslide<7->*!        }
!*\onslide<3->*!    }
!*\onslide<4->*!}
\end{plainjava}
        \item Aber halt\ldots\ Arrays sind komplexe Datentypen. Warum geht das? \info{Tipp: simulieren.}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 3}
    \begin{itemize}[<+(1)->]
        \item Der Start der Rekursion ist nun recht einfach:
\begin{plainjava}
!*\onslide<3->*!public static void printCombinations(int[] array, int n) {
!*\onslide<4->*!    int[] combination = new int[n]; // initialisiert mit 0
!*\onslide<5->*!    helper(array, n, combination, 0);
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Übungsblatt 9 - Aufgabe 3\hfill Wiederholungen vermeiden}
\SetupLstHl\lstfs{9}\begin{itemize}[<+(1)->]
        \item Wir nutzen eine weiter Variable: \bjava{start} um das Fenster zu begrenzen:
    \end{itemize}
\begin{plainjava}
|ihl|static void helper(int[] array, int n, int[] combs,|ihl| int start,|ihl| int index) {|ihl|
    |ihl|if (index == n) {|ihl|
    |ihl|    printArray(combs, 0);|ihl|
    |ihl|} else {|ihl|
        for (int i = start; i < array.length && array.length - i >= n - index; i++) {
            |ihl|combs[index] = array[i];|ihl|
            |ihl|helper(array, n, combs,|ihl| i + 1,|ihl| index + 1);|ihl|
        }
    |ihl|}|ihl|
|ihl|}|ihl|
\end{plainjava}
\begin{itemize}
    \item Wir begrenzen mit \bjava{i < array.length} die Iteration gewohnt nach oben.
    \item \bjava{start} von unten: nach der Wahl eines \(i\)-ten Elements nur noch nach \bjava{i} wählen.
    \item \bjava{array.length - i >= n - index} sichert zu, dass noch mindestens \bjava{n - index} größere Elemente im Array wählbar bleiben.
\end{itemize}
\end{frame}


\section{Die End-End-End-End-End-End-Pinguuuuuu}

\begin{frame}[c]
    \begin{center}
       \begin{tikzpicture}
            \node at (0,0) {TODO};
       \end{tikzpicture}
    \end{center}
\end{frame}
\iffull\end{document}\fi
