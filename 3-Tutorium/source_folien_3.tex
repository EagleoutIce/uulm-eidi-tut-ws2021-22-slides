
\RequirePackage[cmintegrals,cmbraces,ebgaramond]{newtxmath}
\InputIfFileExists{../global.src}\relax\relax
\iffull
\title[Drittes Tutorium -- Übungsblatt 3]{Lassen wir die Schleifen fließen\\\small Tutorium 3}
\date{\sffamily KW 46}

\begin{document}
\Titlepage{3}
\def\AlphaSlab{\def\rmdefault{AlphaSlabOne-TLF}\rmfamily}
\def\SayHate{\begingroup\AlphaSlab Hate\endgroup}
\newcommand\Hate[4][1]{\onslide<#2->{\pgfmathsetmacro\gs{int(100-(\insertslidenumber-#2)*7)}\path[gray!\gs!white] (current page.center) ++(#3) node[scale=#1] {#4\SayHate};}}
\begin{frame}[plain]
\tikzpicture[overlay,remember picture]
\onslide<2-16|handout:0>{
    \node[scale=-\insertslidenumber/12 + 3] at(current page.center) {\faQuoteRight};
}
\Hate{3}{-40:3cm}{\large}
\Hate{4}{70:3.6cm}{\small}
\Hate{5}{170:2cm}{\huge}
\Hate{6}{-60:3.33cm}{\huge}
\Hate[1.5]{7}{30:4.2cm}{\huge}
\Hate[1.66]{8}{254:4cm}{\huge}
\Hate[1.2]{9}{-10:4.1cm}{\Large}
\Hate[1.33]{10}{210:5.1cm}{\huge}
\Hate[2]{11}{150:5.33cm}{\huge}
\Hate[2]{12}{-30:6cm}{\huge}
\Hate{13}{270:2cm}{\large}
\Hate{14}{195:4cm}{}
\Hate{15}{22:1.33cm}{}
\onslide<17>{
    \node[scale=5] at(current page.center) {\faQuoteRight};
}
\onslide<16->{\path[gray] (current page.center) ++(-15:2cm) node {\AlphaSlab Love};}
\endtikzpicture
\end{frame}

{\setbeamercolor{background canvas}{bg=black}
\newsavebox\pinguA
\savebox\pinguA{\tikz\pingu[cape=darkgray!90!black,eyes angry,bill=angry];}
\newsavebox\pinguB
\savebox\pinguB{\tikz\pingu[cape=darkgray!90!black,eyes angry,bill=angry,right wing raise];}
\begin{frame}[plain]
\tikzpicture[overlay,remember picture]
\onslide<3|handout:0>{\node at(current page.center) {\usebox\pinguA};}
\onslide<4|handout:1>{\node (main) at(current page.center) {\usebox\pinguB};}
\onslide<3|handout:0>{\fill[black,fill opacity=.94] (current page.south east) rectangle (current page.north west);}
\onslide<4|handout:1>{\fill[black,fill opacity=.85] (current page.south east) rectangle (current page.north west);}
\node[below right=.33cm,white] at(current page.north west) {\large\AlphaSlab Did they\ldots\ \only<2->{hurt you?}};
\onslide<3->{
    \node[above left=.33cm,white] at(current page.south east) {\large\AlphaSlab My precious \faQuoteRight};
}
\onslide<4->{
    \coordinate[xshift=1mm,yshift=-3.33mm] (cast) at (main.north west);
    \foreach \i in {1,...,30} {
        \fill[fill opacity=.05,pingu@yellow] (cast) circle [radius=10mm-\i*.29mm];
    }
    \foreach \i in {1,...,7} {
        \fill[fill opacity=.05,pingu@yellow] (cast) circle [radius=33mm-\i*4.3mm];
    }
    \fill[white] (cast) circle [radius=.45mm];
    \foreach \i in {1,2,3} {
        \fill[fill opacity=.05,pingu@yellow] (cast) circle [radius=60mm-\i*13.3mm];
    }
    \node[white,scale=.2] at(cast) {\faQuoteRight};
}
\endtikzpicture
\end{frame}}

\section{Allgemeines}
\begin{frame}[t,fragile]{Allgemeines}
    \begin{itemize}[<+(1)->]
        % \item Ihr könnt Altklausuren drucken:\pause{} \url{https://stuve.uni-ulm.de/fin/services/pruefungsprotokolle}
        \item Übt Java. Beispielprojekte (nach Schwierigkeit):\smallskip \begin{itemize}
            \itemsep6pt
            \item Taschenrechner:\pause{} Programmiere einen Taschenrechner für die Kommandozeile der die grundlegenden Rechenoperationen wie +, -, * und / beherrscht.
            \item TicTacToe:\pause{} Tic-Tac-Toe mit netter ASCII-Art im Terminal.\pause{} Kleine Herausforderung: Der andere oder auch beide Spieler sollen von einem Computer übernommen werden können.
            \item Wer wird Millionär?\pause{} Fragen sollen aus den jeweiligen Schwierigkeitsgraden zufällige gewählt werden, sonst normales Wer-Wird Millionär, die Joker arbeiten natürlich mit den korrekten Antworten.
            \item Sudoku:\pause{} Schreibe eine Terminal-Anwendung die Sudokus einliest und dann gelöst wieder ausgibt. (Bonus: ANSI-Escape Codes)
            \item Conway's Game of Life:\pause{} Programmiere Conway's Game of Life im Terminal oder mittels einer Grafik-Bibliothek deiner Wahl.
            \item \ldots
        \end{itemize}
    \end{itemize}
\end{frame}

\section{Süße!!!! Plagiatsente}
\begin{frame}[c]
\pause\centering\begin{tikzpicture}[scale=2.25,every node/.style={transform shape}]
    \duck[grumpy,recedinghair=gray!50!white,tshirt=white!93!black,jacket=red!50!black,book={\scalebox{0.35}{\LaTeX}},bookcolour=black!20!brown,glasses=brown!70!lightgray]
        \node[gray!50!white,rounded corners=1,scale=0.72] at (0.59,1.76) {\rotatebox{-28}{\faMinus}};
        \node[gray!50!white,rounded corners=1,scale=0.75] at (0.86,1.70) {\rotatebox{-2}{\faMinus}};
        \node[align=center,left,text width=3cm] at(-0.25,1.25){Keine Plagiate!};
    \end{tikzpicture}
\end{frame}

\begin{frame}[c]
\centering\begin{tikzpicture}[scale=2.25,every node/.style={transform shape}]
    \duck[eyebrow,recedinghair=gray!50!white,tshirt=white!93!black,jacket=red!50!black,book={\scalebox{0.35}{\LaTeX}},bookcolour=black!20!brown,glasses=brown!70!lightgray]
    \node[align=center,left,text width=3cm] (dnk) at(-0.25,1.25){Danke};
    \onslide<2->{\node[align=center,scale=0.35,below,text width=5.65cm] at(dnk.south) {Das ist besonders lustig, da ich die Ente aus den letzten Semestern übernommen habe \Laughey.};}
    % 28°
    %\fill[red,rounded corners=1] (0.60,1.92) -- ++(0.135,-0.125) -- ++ (0.125,-0.135);
    \end{tikzpicture}
\end{frame}
\fi

\def\encap#1{\makebox[1.25ex]{#1}}
\def\Pyramid#1{%
    \def\pyram{}%
    \foreach \i in {1, ..., #1}{%
        \edef\last{\the\numexpr#1-\i}%
        \ifnum\last>0 \foreach \j in {1, ..., \last}{\gappto\pyram{\encap{~}}}\fi
        \foreach \j in {1, ..., \i}{\ifnum\j=\i \gappto\pyram{\encap{*}}\else\gappto\pyram{\encap{*}\encap{~}}\fi}%
        \gappto\pyram{\\}\relax
    }%
    \pyram
}
% could have centered them but that would defeat the purpose :C
\def\PyramidFromTo#1#2{%
\downsize{.75\linewidth}{\foreach\step in {#1,...,#2}{%
~~\tikzpicture
\fill[gray,opacity=.15,rounded corners=4pt] (-1.5cm,.25cm) rectangle (1.5cm,-2.35cm);
% shift for the last space ;)
\node[black,below,align=left] (p) at (0,0) {\Pyramid{\step}};
\node[below=.4mm] at (0,-2.35cm) {\(N = \step\)};
\endtikzpicture~~\pause
}}}

\section{Präsenzaufgabe}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Starring Mr. Pyramid}
        \small\pause Schreiben Sie ein Java-Programm, welches als Eingabe eine positive ganze Zahl \(N\) erwartet und daraufhin ein gleichseitiges Dreieck mit Hilfe von \(*\)- und Leerfeld-Charakteren in der Kommandozeile ausgibt.\pause\ Die Ausgaben für \(1 \leq N \leq 5\) sollten folgendermaßen aussehen:\pause
        \begin{center}
            \PyramidFromTo{1}{5}
        \end{center}
        \pause\textit{Hinweis:} Überlegen Sie sich eine allgemeine Formel für die Zeileneinrückung. Fügen Sie außerdem Leerzeichen zwischen \(*\)-en für die alternierenden Positionen in den Reihen ein.
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe}
\begin{itemize}[<+(1)->]
    \item Die \(i\)te Zeile ist immer um \(N - i\) Positionen eingerückt.
    \item Wir erschaffen ein Grundgerüst:
\begin{plainjava}
!*\onslide<4->*!public class Pyramid {
!*\onslide<5->*!    public static void main(String[] args) {
!*\onslide<6->*!        if(args.length != 1)
!*\onslide<6->*!            System.exit(1);
!*\onslide<7->*!        int N = Integer.parseInt(args[0]);
!*\onslide<7->*!        // Oder auch gerne 'n'
!*\onslide<4->*!
!*\onslide<8->*!        // Pyramide Erschaffen +2
!*\onslide<5->*!    }
!*\onslide<4->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe}
\begin{itemize}[<+(1)->]
    \item Nun basteln wir uns eine Pyramide:
\begin{plainjava}
!*\onslide<4->*!for (int i = 1; i <= N; i++) {
!*\onslide<5->*!    for (int j = 1; j <= N - i; j++) {
!*\onslide<5->*!        System.out.print(" ");
!*\onslide<5->*!    }
!*\onslide<6->*!    for (int j = 1; j <= i; j++) {
!*\onslide<7->*!        System.out.print("* "); // zusätzliche Leerzeichen
!*\onslide<6->*!    }
!*\onslide<8->*!    System.out.println(); // Zeilenumbruch
!*\onslide<4->*!}
\end{plainjava}
    \iffull\else\item Damit ist alles komplett (\only<2->{\textattachfile{\curpath Pyramid.java}{Pyramid.java}}).\fi
\end{itemize}
\end{frame}

\iffull
\rExecute{javac Pyramid.java}
\begin{frame}[t,fragile]{Präsenzaufgabe}
\begin{itemize}[<+(1)->]
    \item Damit ist alles komplett (\only<2->{\textattachfile{\curpath Pyramid.java}{Pyramid.java}}).
    \item Somit ergibt sich \rbash[:\pause{}]{java Pyramid 8}
\end{itemize}
\end{frame}
\fi

\section{Eine zweite Präsenzaufgabe}

\begin{frame}[fragile]{Präsenzaufgabe die Zweite}
    \setcounter{algocf}{0}
    \begin{aufgabe}{Code! Code! Code! Repeat.}
        \pause{}Drücken Sie die folgenden Anweisungen durch äquivalente Schleifen der angegeben Art aus!\pause{} Die Variable \bjava{int k} sei jeweils mit einem (beliebigen) Wert initialisiert.\vspace*{-\smallskipamount}
        \begin{multicols}{2}\lstfs{8}
            \begin{enumerate}[<+(1)->]
                \item[a)] Do-While:
                \begin{plainjava}
for (int i = 1; i < k; ++i) {
    System.out.println(i * i);
}
                \end{plainjava}
                \item[b)] For-Schleife:
                \begin{plainjava}
int x = 0, i = 0;
while(i < k) { x += k * ++i; }
System.out.println("x: " + x);
                \end{plainjava}
                \item[c)] For-Schleife:
            \begin{plainjava}
if(k > 0){
    int i = 1, m = 0;
    while(i < k){
        if(k*i > m) m = k+i;
        ++i;
    }
    System.out.println("m: " + m);
}
\end{plainjava}
            \end{enumerate}
        \end{multicols}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begin{frame}[t,fragile]{Präsenzaufgabe 2 - Lösung}
\begin{enumerate}[<+(1)->]\lstfs{9}
    \item[a)] Wir erhalten (rechts):\\
    \begin{minipage}{0.5\linewidth}
\begin{plainjava}
!*\onslide<3->*!for (int i = 1; i < k; ++i) {
!*\onslide<3->*!    System.out.println(i * i);
!*\onslide<3->*!}
\end{plainjava}
    \end{minipage}\hfill\begin{minipage}{0.45\linewidth}
\begin{plainjava}
!*\onslide<4->*!if(k > 1) {
!*\onslide<5->*!    int i = 1;
!*\onslide<6->*!    do {
!*\onslide<7->*!        System.out.println(i * i);
!*\onslide<7->*!        ++i;
!*\onslide<6->*!    } while (i < k);
!*\onslide<4->*!}
        \end{plainjava}
    \end{minipage}
    \item<8->[b)] Wir erhalten (rechts):\\
        \begin{minipage}{0.5\linewidth}
\begin{plainjava}
!*\onslide<9->*!int x = 0, i = 0;
!*\onslide<9->*!while(i < k) { x += k * ++i; }
!*\onslide<9->*!System.out.println("x: " + x);
\end{plainjava}
    \end{minipage}\hfill\begin{minipage}{0.45\linewidth}
\begin{plainjava}
!*\onslide<10->*!int x = 0;
!*\onslide<11->*!for(int i = 0; i < k; i++)
!*\onslide<12->*!    x += k * (i + 1);
!*\onslide<13->*!System.out.println("x: " + x);
        \end{plainjava}
    \end{minipage}
\end{enumerate}
\end{frame}


\begin{frame}[t,fragile]{Präsenzaufgabe 2 - Lösung}
\begin{enumerate}[<+(1)->]\lstfs{9}
    \item[c)] Wir erhalten (rechts):\\
\begin{minipage}{0.5\linewidth}
    \begin{plainjava}
!*\onslide<3->*!if(k > 0){
!*\onslide<3->*!    int i = 1, m = 0;
!*\onslide<3->*!    while(i < k){
!*\onslide<3->*!        if(k*i > m) m = k+i;
!*\onslide<3->*!        ++i;
!*\onslide<3->*!    }
!*\onslide<3->*!    System.out.println("m: " + m);
!*\onslide<3->*!}
\end{plainjava}
    \end{minipage}\hfill\begin{minipage}{0.45\linewidth}
\begin{plainjava}
!*\onslide<4->*!if(k > 0){
!*\onslide<5->*!    int m = 0;
!*\onslide<6->*!    for(int i = 1; i < k; ++i)
!*\onslide<7->*!        if(k*i > m) !*\onslide<8->*!m = k+i;
!*\onslide<9->*!    System.out.println("m: " + m);
!*\onslide<4->*!}
        \end{plainjava}
    \end{minipage}
\end{enumerate}
\end{frame}


\section{Übungsblatt 3}
\subsection{Aufgabe 1}
\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 1 a)}
    \begin{itemize}[<+(1)->]
        \item Uns reicht es, wenn dies nur für den zweiten \bjava{if}-\bjava{else}-Block geschieht.
        \item Damit wird dieser zu:
\begin{plainjava}
!*\onslide<4->*!switch (x) {
!*\onslide<5->*!    case 1:  System.out.println("A");
!*\onslide<5->*!        break;
!*\onslide<6->*!    case 2:  System.out.println("B");
!*\onslide<6->*!        break;
!*\onslide<7->*!    case 3:  System.out.println("C");
!*\onslide<7->*!        break;
!*\onslide<8->*!    default: System.out.println("D");
!*\onslide<8->*!        break;
!*\onslide<4->*!}
\end{plainjava}
    \end{itemize}
\end{frame}


\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 1 a)}
    \begin{itemize}[<+(1)->]
        \item Fanatiker dürfen aber auch die Kommandozeilenargumente auf diese Weise überprüfen~(\only<2->{\textattachfile{\curpath SwitchCaseControlled.java}{SwitchCaseControlled.java}}):\lstfs{10}
\begin{plainjava}
!*\onslide<3->*!switch(args.length) {
!*\onslide<4->*!    case 1: x = Integer.parseInt(args[0]); break;
!*\onslide<5->*!    default: System.exit(1); return;
!*\onslide<3->*!}
\end{plainjava}
        \item Ist das \bjava{switch} hier sinnvoll?\pause\
        \info{Nicht wirklich. Mindestens drei Fälle sollten es schon sein, damit sich der Schreibaufwand auch reduziert beziehungsweise die Lesbarkeit verbessert.}
        \item Ist das \bjava{return} hier notwendig?\pause\ \info{Nein, die JVM bricht durch das \bjava{exit} ab.}
        \item Warum könnte man \bjava{return} eventuell doch brauchen?\pause\ \info{Theoretisch muss sie da nicht enden und auch wenn der Code danach nicht mehr ausgeführt wird, der Java Compiler weiß in der Regel noch nicht, dass es bei \bjava{System.exit} wirklich vorbei ist.}
    \end{itemize}
\end{frame}


\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 1 b)}
    \begin{itemize}[<+(1)->]
        \item Die Bedingung \bjava{(x < 0) || (x >= 3)} invertiert den Default-Fall!
        \item Damit genügt~(\only<3->{\textattachfile{\curpath SwitchCaseControlledAlternate.java}{SwitchCaseControlledAlternate.java}})
\begin{plainjava}
switch (x) {
    case 0: System.out.println("D"); break;
    case 1: System.out.println("A"); break;
    case 2: System.out.println("B"); break;
    default:
        System.out.println("C");
}
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Aufgabe 2}

\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 2 a)\hfill While}
    \begin{itemize}[<+(1)->]
        \item Zunächst mit While~(\only<3->{\textattachfile{\curpath FacultyWhileLoop.java}{FacultyWhileLoop.java}}):
\begin{plainjava}
!*\onslide<3->*!int faculty = 1;
!*\onslide<3->*!int i = 0;
!*\onslide<4->*!while (i <= n) {
!*\onslide<5->*!    if (i != 0) {
!*\onslide<6->*!        faculty *= i;
!*\onslide<5->*!    }
!*\onslide<7->*!    System.out.println(i + "! = " + faculty);
!*\onslide<7->*!    i++;
!*\onslide<5->*!}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 2 a)\hfill Do-While}
    \begin{itemize}[<+(1)->]
        \item Non mit Do-While~(\only<3->{\textattachfile{\curpath FacultyDoWhileLoop.java}{FacultyDoWhileLoop.java}}):
\begin{plainjava}
!*\onslide<3->*!int faculty = 1;
!*\onslide<3->*!int i = 0;
!*\onslide<4->*!do {
!*\onslide<5->*!    if (i != 0) {
!*\onslide<6->*!        faculty *= i;
!*\onslide<5->*!    }
!*\onslide<7->*!    System.out.println(i + "! = " + faculty);
!*\onslide<7->*!    i++;
!*\onslide<4->*!} while (i <= n);
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 3 - Aufgabe 2 b)}
    \begin{itemize}[<+(1)->]
        \itemsep9pt
        \item \say{Sie möchten alle \(n\) Elemente einer Liste ausgeben.}\smallskip\pause\par
        Da wir hier das Maximum kennen und nacheinander auf alle Elemente zugreifen, empfiehlt sich eine \bjava{for}-Schleife.
        \item \say{Sie möchten solange einzelne Zeichen einlesen, bis ein \say{x} eingelesen wird.}\smallskip\pause\par
        Hier kennen wir nicht das Maximum. Da wir aber mindestens einmal einlesen müssen um auf \say{x} zu prüfen, empfiehlt sich \bjava{do}-\bjava{while}.\pause\ An sich ginge aber auch \bjava{while} wenn wir im Schleifenkopf einlesen.
    \end{itemize}
\end{frame}

\subsection{Zusatzaufgabe 1/6}
\begin{frame}[t,fragile]{Übungsblatt 3 - Zusatzaufgabe a)}
    \begin{itemize}[<+(1)->]
        \item Jetzt können wir auch alles über Bord werfen.
        \item Da der Argumenttest nicht ternär gemacht werden kann, sind wir mal nicht fanatisch \Laughey\ (\only<3->{\textattachfile{\curpath EvenOddTernary.java}{EvenOddTernary.java}}):
\begin{plainjava}
System.out.println(x + ((x % 2) == 0 ? " ist gerade" :
                    " ist ungerade"));
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 3 - Zusatzaufgabe b)}
    \begin{itemize}[<+(1)->]
        \item So schlimm es auch ist, wir können die ternären Operationen verschachteln.
        \item Der Argumenttest geht aber immer noch nicht (\only<3->{\textattachfile{\curpath DivisibleTernary.java}{DivisibleTernary.java}}):
\begin{plainjava}
String output = (x % 2) == 0 ? " ist durch 2 teilbar"
        : (x % 3) == 0 ? " ist durch 3 teilbar"
        : " ist weder durch 2 noch 3 teilbar";
\end{plainjava}
    \end{itemize}
\end{frame}

\iffull
\section{Bonus: Kellerspeicher}

\tikzset{block/.style={rectangle,draw=gray,minimum width=.7cm,minimum height=.5cm},N/.style={outer sep=0pt,inner sep=0pt}}
% list | pointer
\def\bk#1#2{%
\scalebox{.65}{\begin{tikzpicture}
\foreach[count=\i] \a in {#1} {
    \node[block] (\i) at(\i*.7cm,0) {\a};
    \node[below,gray,font=\footnotesize\sffamily] at (\i.south) {\the\numexpr\i-1\relax};
}
\node[left=.55cm,N] (arr) at (1.west) {\bjava{int[] arr}: };

\node[above,yshift=.15cm] at(\the\numexpr#2+1\relax.north) {\faCaretDown};
\node[above left,yshift=.15cm,N] at(arr.north east) {\bjava{pointer = #2}};
\end{tikzpicture}}%
}

\begin{frame}[fragile]{Exkurs: (Array-)Kellerspeicher}
    \begin{itemize}[<+(1)->]
        \item Einfache Datenstruktur (Stack). \info{Wir werden später mehr kennenlernen}
        \item Repräsentiert durch Array und Zeiger (\bjava{int pointer}).
        \item \strut Betrachten wir ein Array mit 5 Elementen (initial \bjava{pointer = -1}).\smallskip\\
\scalebox{.65}{\begin{tikzpicture}
\foreach[count=\i] \a in {0,0,0,0,0} {
    \node[block] (\i) at(\i*.7cm,0) {\a};
    \node[below,gray,font=\footnotesize\sffamily] at (\i.south) {\the\numexpr\i-1\relax};
}
\node[left=.55cm,N] (arr) at (1.west) {\bjava{int[] arr}: };
\end{tikzpicture}}%
    \end{itemize}
    \begin{multicols}{3}
    \begin{enumerate}[<+(1)->]
        \item \strut Hinzufügen von \bjava{8}\\ \bk{8,0,0,0,0}{0}
        \item \strut Hinzufügen von \bjava{3}\\ \bk{8,3,0,0,0}{1}
        \item \strut Hinzufügen von \bjava{4}\\ \bk{8,3,4,0,0}{2}
        \item \strut Hinzufügen von \bjava{9}\\ \bk{8,3,4,9,0}{3}
        \item \strut Entferne Element\\ \bk{8,3,4,0,0}{2}
        \item \strut Entferne Element\\ \bk{8,3,0,0,0}{1}
    \end{enumerate}
    \end{multicols}
\end{frame}

\begin{frame}[fragile]{Exkurs: (Array-)Kellerspeicher}
    \begin{itemize}[<+(1)->]
        \item Für unser Beispiel, muss die Zahl gar nicht gelöscht werden.
        \item \strut Es reicht, den Zeiger zu verschieben:\smallskip\\
\scalebox{.65}{\begin{tikzpicture}
\foreach[count=\i] \a in {0,0,0,0,0} {
    \node[block] (\i) at(\i*.7cm,0) {\a};
    \node[below,gray,font=\footnotesize\sffamily] at (\i.south) {\the\numexpr\i-1\relax};
}
\node[left=.55cm,N] (arr) at (1.west) {\bjava{int[] arr}: };
\end{tikzpicture}}%
    \end{itemize}
    \begin{multicols}{3}
    \begin{enumerate}[<+(1)->]
        \item \strut Hinzufügen von \bjava{8}\\ \bk{8,0,0,0,0}{0}
        \item \strut Hinzufügen von \bjava{3}\\ \bk{8,3,0,0,0}{1}
        \item \strut Hinzufügen von \bjava{4}\\ \bk{8,3,4,0,0}{2}
        \item \strut Hinzufügen von \bjava{9}\\ \bk{8,3,4,9,0}{3}
        \item \strut Entferne Element\\ \bk{8,3,4,9,0}{2}
        \item \strut Entferne Element\\ \bk{8,3,4,9,0}{1}
    \end{enumerate}
    \end{multicols}
\end{frame}

\def\exr#1#2{\bvoid{#1}~$\Rightarrow$~\bvoid{#2}}
\begin{frame}[fragile]{Exkurs: Umgekehrte polnische Notation}
    \begin{itemize}[<+(1)->]
        \item Herkömmliche Darstellung für arithmetischer Ausdrücke: \bvoid{<a> <op> <b>}
        \item In der umgekehrten polnischen Notation (UPN) ist dies anders!
        \item Zuerst die Operanden (\bvoid{<a>}, \bvoid{<b>}), dann der Operator (\bvoid{<op>}). \begin{itemize}
            \item \exr{1 + 2 + 3 + 4}{1 2 + 3 4 + + }
            \item \exr{(2 * 3) + (20 * 3)}{2 3 * 20 3 * +}
            \item \exr{13 * 12 * -5 + 4}{13 12 * -5 * 4 +}
        \end{itemize}
        \item Wir werden uns auf \say{$+$} und \say{$*$} fokussieren.
        \item Anstelle von \say{$*$} schreiben wir \say{mult}, anstelle von \say{$+$}, \say{add}. \begin{itemize}
            \item \exr{1 + 2 + 3 + 4}{1 2 add 3 4 add add}
            \item \exr{(2 * 3) + (20 * 3)}{2 3 mult 20 3 mult add}
            \item \exr{13 * 12 * -5 + 4}{13 12 mult -5 mult 4 add}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Exkurs: Umgekehrte polnische Notation mit Stack}
    \begin{itemize}[<+(1)->]
        \item Annahme: Die Ausdrücke mit denen wir arbeiten sind gültig.
        \item Wir arbeiten von links nach rechts.
        \item Wir speichern die Operanden auf dem Stack.
        \item Treffen wir auf einen Operator: \info{Ein Beispiel kommt mit der Lösung der alten Präsenzaufgabe} \begin{enumerate}
            \item entnehmen der obersten beiden Elemente des Stack.
            \item verarbeiten mit dem Operator \info{Multiplikation/Addition}.
            \item ablegen der Summe/des Produktes auf dem Stack.
        \end{enumerate}
    \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Eine alte Präsenzaufgabe}
    \rExecute{javac ReversePolishNotation.java}\setcounter{algocf}{0}
    \begin{aufgabe}{Do da' UPN}
        \pause{}Schreiben Sie ein Programm, dass mit (korrekter) UPN gefüttert, den oberen Wert des Stacks ausgibt.\pause{} Die Operanden sollen Integer und die Operatoren \bjava{add} und \bjava{mult} sein. Sie können eine Zeichenkette mit \say{\bjava{Integer.parseInt(x)}} in einen Integer umwandeln.\pause{} Sie können den Stack auf eine kleine Zahl begrenzen.\pause\par
% \rbash[:\pause]{java ReversePolishNotation 1 2 3 4 5 add}
\rbash[:\pause]{java ReversePolishNotation 2 3 mult 20 3 mult add}
        \onslide<1->
    \end{aufgabe}
\end{frame}

\begingroup
\lstfs{10}
\begin{frame}[t,fragile]{Eine alte Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Das volle Programm findet sich hier: \only<2->{\textattachfile{\curpath ReversePolishNotation.java}{ReversePolishNotation.java}}.
    \item Initialisierung:
\begin{java}
int[] stack = new int[100];
int pointer = -1;
\end{java}
    \item Wir iterieren über alle Kommandozeilenargumente:
\begin{java}[firstnumber=3]
for (String arg : args) {
    // Cast epic magic
}

!*\onslide<+(1)->*!System.out.println(stack[pointer]);
\end{java}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Eine alte Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Die epic magic der Addition:
\begin{java}[firstnumber=4]
!*\onslide<3->*!if (arg.equals("add")) {
!*\onslide<4->*!    pointer -= 1;
!*\onslide<4->*!    stack[pointer] += stack[pointer + 1];
!*\onslide<3->*!}
\end{java}
    \item<5-> Die epic magic der Multiplikation:
\begin{java}[firstnumber=10]
!*\onslide<6->*!else if (arg.equals("mult")) {
!*\onslide<7->*!    pointer -= 1;
!*\onslide<7->*!    stack[pointer] *= stack[pointer + 1];
!*\onslide<6->*!}
\end{java}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Eine alte Präsenzaufgabe - Lösung}
\begin{itemize}[<+(1)->]
    \item Die epic magic der Sonstigkeit:
\begin{java}[firstnumber=16]
!*\onslide<3->*!else { // Annahme: Zahl
!*\onslide<4->*!    pointer += 1;
!*\onslide<4->*!    stack[pointer] = Integer.parseInt(arg);
!*\onslide<3->*!}
\end{java}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Eine alte Präsenzaufgabe - Lösung, ein Beispiel}
\begin{itemize}[<+(1)->]
    \item Betrachten wir ein Beispiel für \bjava{3 2 add 5 1 add add 4 mult}
\end{itemize}\vspace*{-\smallskipamount}
\begin{multicols}{3}
\begin{enumerate}[<+(1)->]
    \item Einlesen von \bjava{3}:\\ \bk{3,0,0,0,0}{0}
    \item Einlesen von \bjava{2}:\\ \bk{3,2,0,0,0}{1}
    \item Einlesen von \bjava{add}:\\ \bk{5,2,0,0,0}{0}
    \item Einlesen von \bjava{5}:\\ \bk{5,5,0,0,0}{1}
    \item Einlesen von \bjava{1}:\\ \bk{5,5,1,0,0}{2}
    \item Einlesen von \bjava{add}:\\ \bk{5,6,1,0,0}{1}
    \item Einlesen von \bjava{add}:\\ \bk{11,6,1,0,0}{0}
    \item Einlesen von \bjava{4}:\\ \bk{11,4,1,0,0}{1}
    \item Einlesen von \bjava{mult}:\\ \bk{44,4,1,0,0}{0}
\end{enumerate}
\end{multicols}
\end{frame}
\endgroup

\section{Abgabekommentar}
\newsavebox\shocked
\savebox\shocked{\tikz\pingu[eyes=shock,wings=shock,tie,headband];}

\mode
<beamer>
\begin{frame}[c,plain]
\null\vfill\vfill\null\hspace*{-1cm}\foreach \i in {1,...,11}{%
\only<\the\numexpr\i+1>{\includegraphics[scale=.5]{images/\i.png}%
\tikzpicture[overlay,remember picture]
\node[scale=1 + \i*.175,above right=-7mm,xshift=-1mm] at(current page.south west) {\rotatebox{-45}{\usebox\shocked}};
\endtikzpicture
}%
}\vfill\null
\end{frame}

\mode
<handout>

\begin{frame}[c,plain]
\null\vfill\vfill\null\hspace*{-1cm}
\includegraphics[scale=.5]{images/1.png}%
\tikzpicture[overlay,remember picture]
\node[scale=2.33,above right=-7mm,xshift=-1mm] at(current page.south west) {\rotatebox{-45}{\usebox\shocked}};
\endtikzpicture
\vfill\null
\end{frame}

\mode
<all>
\fi

\section{End Pinguuu}
\begin{frame}[c]
    \hbox{}\vfill
    \centering\onslide<2->{\scalebox{2}{\begin{tikzpicture}
        \pingu[name = herbertine,eyes wink, right wing wave,bow tie,glasses,hat]
        \pingu[name = herbert, xshift=2.75cm, wings grab, cup, eyes shiny, hair 2=pingu@green]
    \end{tikzpicture}}}
\end{frame}
\iffull
\end{document}
\fi
