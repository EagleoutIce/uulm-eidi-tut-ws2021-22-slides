\errorcontextlines 999999
\usepackage{attachfile2}
\attachfilesetup{%
    author={Florian Sihler},%
    color=0.2 0.36 0.494, icon=Tag, mimetype=text/plain%
}

\usepackage[%
    sopra-listings={encoding,cpalette,highlights,numinpar},%
    sopra-tables,
    color-palettes={addons},%
    util,%
    lithie-boxes={germanenv,koma,overwrite},%
    lithie-task-boxes={cpalette},%
    lecture-links={patchurl},%
    lecture-registers={disable}% would interfere with beamer
]{lithie-util}

\RequirePackage{lecture-personal-tikz}

\usepackage[ngerman]{babel}

\UsePalette{NorthernLights}\AtBeginDocument{\colorlet{cprimary}{paletteB}}
\RestyleAlgo{plain}
\solLoadLanguage{bash,cpp,regex}

\def\solcustom{fill=paletteA!30,draw=paletteA!30}

\colorlet{MaterialHeaderColor}{paletteB}%
\colorlet{NextMaterialHeaderColor}{paletteB!75!white}%

\def\linkstyle#1{\textsf{\paletteD{#1}}}
\SetAllLinkStyle{\linkstyle{#1}}
\usepackage{tikzducks,tikzsymbols,lilly-color}
\usetheme{lucy}

\colorlet{chessfieldblack}{lightgray}

\usetikzlibrary{arrows.meta,decorations,decorations.pathreplacing}

\def\info#1{\bgroup\scriptsize\textcolor{gray}{(#1)}\egroup}

\newcommand\parallelcontent[3][t]{%
    \begin{columns}[#1]
    \begin{column}{0.475\linewidth}
        #2
    \end{column}\hfill
    \begin{column}{0.475\linewidth}
        #3
    \end{column}
    \end{columns}
}

\tikzset{
    dot/.style={circle,draw,align=center,text width=1em,execute at begin node={\strut}},
    elem node/.style={inner sep=0pt}%
}

\setcounter{tocdepth}{4}

\title[Dreizehntes Tutorium -- Übungsblatt 13]{Is it Lö Final?\\\small Tutorium 13}
\date{\sffamily KW 30}
\author{Florian Sihler}
\institute{Institute of Distributed Systems \(\circ\) University Ulm}

\usepackage{tikzpingus-old}
\usetikzlibrary{decorations.text}

\hypersetup{colorlinks=false}

\makeatletter
\newif\if@borderstar
\def\bordermatrix{\@ifnextchar*{%
\@borderstartrue\@bordermatrix@i}{\@borderstarfalse\@bordermatrix@i*}%
}
\def\@bordermatrix@i*{\@ifnextchar[{\@bordermatrix@ii}{\@bordermatrix@ii[()]}}
\def\@bordermatrix@ii[#1]#2{%
\begingroup
\m@th\@tempdima8.75\p@\setbox\z@\vbox{%
\def\cr{\crcr\noalign{\kern 2\p@\global\let\cr\endline }}%
\ialign {$##$\hfil\kern 2\p@\kern\@tempdima & \thinspace %
\hfil $##$\hfil && \quad\hfil $##$\hfil\crcr\omit\strut %
\hfil\crcr\noalign{\kern -\baselineskip}#2\crcr\omit %
\strut\cr}}%
\setbox\tw@\vbox{\unvcopy\z@\global\setbox\@ne\lastbox}%
\setbox\tw@\hbox{\unhbox\@ne\unskip\global\setbox\@ne\lastbox}%
\setbox\tw@\hbox{%
$\kern\wd\@ne\kern -\@tempdima\left\@firstoftwo#1%
\if@borderstar\kern2pt\else\kern -\wd\@ne\fi%
\global\setbox\@ne\vbox{\box\@ne\if@borderstar\else\kern 2\p@\fi}%
\vcenter{\if@borderstar\else\kern -\ht\@ne\fi%
\unvbox\z@\kern-\if@borderstar2\fi\baselineskip}%
\if@borderstar\kern-2\@tempdima\kern2\p@\else\,\fi\right\@secondoftwo#1 $%
}\null \;\vbox{\kern\ht\@ne\box\tw@}%
\endgroup
}
\makeatother

\begin{document}
\begin{frame}[c]
    \begin{tikzpicture}[overlay]
        \begin{scope}[xshift=\paperwidth-3cm,yshift=-4.5cm,scale=0.4]
            \lithiebirb[\DisableLinkStyle\href{https://github.com/EagleoutIce/lithie-util}{\Lithie}]
        \end{scope}
        \node[scale=5,below left=2.5pt,color=csecondary,opacity=.4] at(\paperwidth,0.22\paperheight) {13};
    \end{tikzpicture}
    \titlepage
\end{frame}


\section{Übungsblatt 13}
\subsection{Aufgabe 1}

\begin{frame}[t,fragile]{Übungsblatt 13}
\begin{itemize}[<+(1)->]
    \item Ein Blick auf Readable: \begin{plainjava}[morekeywords={[3]{Readable}}]
!*\onslide<3->*!public interface Readable {
!*\onslide<4->*!    public boolean canRead();
!*\onslide<5->*!    public int read();
!*\onslide<3->*!}
    \end{plainjava}
    \item<6-> Im Endeffekt ein Iterator: \begin{itemize}
        \item<7-> Gibt es noch ein weiteres Element zum Iterieren? (\bjava{canRead})
        \item<8-> Betrachte das nächste Element. (\bjava{read})
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1a)}
\begin{itemize}[<+(1)->]
    \item Eine wunderbare Integer-Range (\only<2->{\textattachfile{IntRange.java}{IntRange.java}}).
    \item Wir iterieren also über alle Elemente in \([a, b)\):
\begin{plainjava}
!*\onslide<4->*!public boolean canRead() {
!*\onslide<5->*!    return this.current < this.max;
!*\onslide<4->*!}
!*\onslide<4->*!
!*\onslide<6->*!public int read() {
!*\onslide<7->*!    if(!this.canRead())
!*\onslide<7->*!        throw new IllegalStateException("Interval consumed");
!*\onslide<8->*!    return current++;
!*\onslide<6->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1b)}
\begin{itemize}[<+(1)->]
    \item Nun Integer-Random (\only<2->{\textattachfile{IntRandom.java}{IntRandom.java}}).
    \item Hier iterieren wir an sich über eine unendliche Liste mit Elementen aus \([a, b]\):
\begin{plainjava}
!*\onslide<4->*!public boolean canRead() {
!*\onslide<5->*!    return true;
!*\onslide<4->*!}
!*\onslide<4->*!
!*\onslide<6->*!public int read() {
!*\onslide<7->*!    return rng.nextInt(this.max + 1);
!*\onslide<6->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Intermezzo}
\begin{itemize}[<+(1)->]
    \item Ein Blick auf Writeable: \begin{plainjava}[morekeywords={[3]{Writeable}}]
!*\onslide<3->*!public interface Writeable {
!*\onslide<4->*!    public boolean canWrite();
!*\onslide<5->*!    public void write(int i);
!*\onslide<3->*!}
    \end{plainjava}
    \item<6-> Ein Iterator zum schreiben: \begin{itemize}
        \item<7-> Gibt es noch Schreibplatz? (\bjava{canWrite})
        \item<8-> Schreibe ein Element (\bjava{write}).
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1c)}
\begin{itemize}[<+(1)->]
    \item Nun etwas zum Filter-Charme (\only<2->{\textattachfile{IntFilterQueue.java}{IntFilterQueue.java}}).
    \item Zunächst die \say{can}-Methoden:
\begin{plainjava}
!*\onslide<4->*!public boolean canRead() {
!*\onslide<5->*!    return this.length > 0;
!*\onslide<4->*!}
!*\onslide<3->*!
!*\onslide<6->*!public boolean canWrite() {
!*\onslide<7->*!    return this.length < this.buffer.length;
!*\onslide<6->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1c)}
\begin{itemize}[<+(1)->]
    \item Durch das Modulo erzeugen wir einen Wrap-Around:
\begin{plainjava}
!*\onslide<3->*!public int read() {
!*\onslide<4->*!    if (!this.canRead())
!*\onslide<4->*!        throw new IllegalStateException("Queue leer");
!*\onslide<3->*!
!*\onslide<5->*!    int toReturn = this.buffer[this.first];
!*\onslide<6->*!    this.first = (this.first + 1) % this.buffer.length;
!*\onslide<7->*!    this.length--;
!*\onslide<5->*!    return toReturn;
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1c)}
\begin{itemize}[<+(1)->]
    \item Auch beim Schreiben verwenden wir das bekannte Wrapping in Arrays:
\begin{plainjava}
!*\onslide<3->*!public void write(int i) {
!*\onslide<4->*!    if (!this.canWrite())
!*\onslide<4->*!        throw new IllegalStateException("Queue voll");
!*\onslide<5->*!    if (!this.predicate(i))
!*\onslide<5->*!        return;
!*\onslide<6->*!    int next = (this.first + this.length) % this.buffer.length;
!*\onslide<6->*!    this.buffer[next] = i;
!*\onslide<6->*!    this.length++;
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1d)}
\begin{itemize}[<+(1)->]
    \item Und nun, weil wir das Sieben lieben (\only<2->{\textattachfile{IntSieve.java}{IntSieve.java}}, \only<2->{\textattachfile{Set.java}{Set.java}})
    \item Das Grundgerüst:
\begin{plainjava}[morekeywords={[3]{IntSieve,Set,IntFilterQueue}}]
public class IntSieve extends IntFilterQueue {
    private Set known;

    public IntSieve(int bufferSize) {
        super(bufferSize);
        this.known = new Set();
    }

    public boolean predicate(int v) { /* ... */ }
}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Aufgabe 1d)}
\begin{itemize}[<+(1)->]
    \item Zuletzt die Implementation von \bjava{predicate}:
\begin{plainjava}
!*\onslide<3->*!public boolean predicate(int v) {
!*\onslide<4->*!    if (this.known.isElement(v))
!*\onslide<4->*!        return false;
!*\onslide<5->*!    this.known.write(v);
!*\onslide<6->*!    return true;
!*\onslide<3->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Übungsblatt 13 - Fazit}
\begin{itemize}[<+(1)->]
    \item Diese Interfaces beschreiben unfassbar abstrakt Datenstrukturen.
    \item Readable beschreibt so irgendetwas lesbares. \pause{}Möglich: \begin{itemize}
        \item eine Datei
        \item ein Heap
        \item ein Stack
        \item eine Queue
        \item ein Binär-, Such- oder Spielbaum
        \item eine Zeichenkette
        \item eine Netzwerkverbindung
        \item ein Sensor
        \item \ldots
    \end{itemize}
    \item Ebenso bei Writeable (wobei manche Komponenten Read- oder Writeonly sind).
    \item Reichen die deswegen für alles aus?\pause{}\par\info{Nein. Oftmals brauchen wir mehr Wissen über die Datenstrukturen um ihre Vor- und Nachteile besser ausnutzen zu können. So beispielsweise, ob die Datenstrukturen geordnet sind oder nicht.}
\end{itemize}
\end{frame}


\subsection{Aufgabe 2}
\begin{frame}[t]{Übungsblatt 13 - Aufgabe 2a)}
\begin{itemize}[<+(1)->]
    \item Wie die Algorithmen twerkeln:
\begin{description}[Algorithmus A:]
    \item[Algorithmus A:] Implementiert binäre Suche.\par
    Dabei wird das Array jeweils von einem mittleren Index aus in zwei Teile geteilt, den Teil links vom Mittlepunkt, mit den Werten die kleiner als der am Mittelpunkt sind, und den Teil rechts vom Mittelpunkt, mit den größeren Werten. Dies wird so lange wiederholt, bis entweder der gesuchte Wert am Mittelpunkt zu finden ist, oder das durchsuchte Teilarray leer ist.
    \item[Algorithmus B:] funktioniert Analog zu Algorithmus A, jedoch wird hier das Array in drei Teile geteilt,
    wobei es zwei Trennpunkte gibt. Die Teilung wird ebenfalls wiederholt, bis der gesuchte Wert an einem
    der beiden Trennpunkte gefunden wird, oder das zu durchsuchende Array leer ist.
\end{description}
\end{itemize}
\end{frame}

\begin{frame}[t]{Übungsblatt 13 - Aufgabe 2b)}
\begin{itemize}[<+(1)->]
    \item Die Komplexitätsabschätzung:
\begin{description}[Algorithmus A:]
    \item[Algorithmus A:] hat die Worst-Case-Laufzeit \(\mathcal{O}(\log_2 n)\), da für jeden Iterationsschritt einmal geprüft
    2wird, ob der gesuchte Wert gefunden wurde, und dann der Suchbereich halbiert wird. Durch die Halbierung
    werden \(log_2 n\)-Iterationen durchgeführt.
    \item[Algorithmus B:] hat eine Worst-Case-Laufzeit von \(\mathcal{O}(\log_3 n)\). Die Begründung hierfür ist analog zu
    der Obigen, jedoch wird das Array hier jeweils gedrittelt, was letztendlich zu \(\log_3 n\)-Iterationen führt.
\end{description}
\end{itemize}
\end{frame}

\begin{frame}[t]{Übungsblatt 13 - Aufgabe 2c)}
\begin{itemize}[<+(1)->]
    \item Die Algorithmen sind in der selben Komplexitätsklasse, da der Basiswechsel bei Logarithmen mit einer Konstante funktioniert:\pause
\begin{equation*}
    \log_3 n = \frac{\log_2 n}{\log_2 3} = \frac{1}{\log_2 3} \cdot \log_2 n
\end{equation*}
\pause{} Der konstante Faktor \(\frac{1}{\log_2 3}\) entfällt in der \(\O\)-Notation.\pause{} \info{Deswegen gibt man die Basen in der \(\O\)-Notation auch meist nicht an.}
\end{itemize}
\end{frame}

\section{Der End-Pinguuuu}

\begin{frame}[c]
    \begin{center}
        \scalebox{3}{\begin{tikzpicture}
        \pingu[left wing wave,right eye=!hide, name=monoci,sign post={\raisebox{14pt}{\scalebox{0.8}{\parbox{1.2cm}{\centering\small Good\\\color{white}Job!\\[-0.65cm]}}}},after code={\fill (monoci-right-eye) circle [radius=0.082cm];\draw[line width=0.245pt,fill=pingu@blue,fill opacity=0.035] (monoci-right-eye) circle [radius=0.15cm];\draw[very thin] ($(monoci-right-eye)+(0.15,0)$) to[bend left,looseness=0.2] ++(-0.01,-0.375) coordinate (dt); \fill (dt) circle (0.65pt);\node[left] at(monoci-left-wing) {~~~~~};}]
        \end{tikzpicture}}
    \end{center}
\end{frame}

\end{document}