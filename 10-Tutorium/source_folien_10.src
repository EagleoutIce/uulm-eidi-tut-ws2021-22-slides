\InputIfFileExists{../global.src}\relax\relax

\iffull
\def\smlll{\texorpdfstring{\def\RSsmallest{2pt}\smaller[2]}{}}
\title[Zehntes Tutorium -- Übungsblatt 10]{Ich sortiere das. \textit{Ich}, als Sortierer.\\\small Ordnung 10}
\date{\sffamily KW 4}

\usepackage[glows]{tikzpingus}
\usetikzlibrary{decorations.text,matrix}
\hypersetup{colorlinks=false}

\begin{document}
\Titlepage{9}
\fi


\section{Präsenzaufgabe}
\begin{frame}[c]{Präsenzaufgabe}
    \begin{aufgabe}{Bitte anstellen\ldots}
        \only<-5|handout:0>{\pause{}\small In dieser Aufgabe sollen Sie ihre eigene dynamische Datenstruktur implementieren. Hierbei solle es sich um eine Queue handeln, welche nach dem \textit{FIFO}-Prinzip (\say{first in first out}) arbeitet und Integer Werte speichert.\pause{} Intern benötigen Sie hier zusätzlich zur Klasse \bjava{Queue} eine innere Klasse um die Elemente repräsentieren zu können.

        \pause Implementieren Sie einen Konstruktor für die Klasse \textit{Queue}, welcher die internen Variablen entsprechend initialisiert und zusätzlich die folgenden Methoden: \only<4|handout:0>{\begin{enumerate}
            \item \bjava{public void enqueue(int value)} --- soll ein neues Element mit dem Wert \bjava{value} am Ende der Queue einreihen.
            \item \bjava{public boolean dequeue()} --- soll das vorderste Element aus der \bjava{Queue} entfernen und zurückliefern ob das Entfernen möglich war.
            \item \bjava{public int getLength()} --- soll die Anzahl der eingereihten Elemente zurück geben.
            \item \bjava{public String toString()} --- soll die eingereihten Werte in einem String formatieren und diesen Zurückgeben.
        \end{enumerate}}

        \pause \textit{Bonusfrage}: Angenommen, Sie wollten die Methode \bjava{public :lan:?:ran: head()} implementieren, die den Wert des ersten Elements zurückgibt. Welchen Rückgabetyp würden sie wählen? Warum?}%
        \only<6->{\vspace*{-1.25\baselineskip}\par%
            \small Implementieren Sie eine (Linked-)\bjava{Queue} Klasse, die nach dem \textit{FIFO}-Prinzip (\say{first in first out}) Integer-Werte verwaltet. Schreiben Sie dafür eine interne Klasse um die Elemente zu repräsentieren. Implementieren Sie weiter:\vspace*{-.33\baselineskip} \onslide<7->{\begin{itemize}
                \itemsep0.5pt
                \item Den Konstruktor \bjava{public Queue()}, der alles \textit{explizit} zuweist.
                \item \bjava{public void enqueue(int value)} --- füge \bjava{value} am Ende an.
                \item \bjava{public boolean dequeue()} --- entferne das vorderste Element (\bjava{false} wenn leer).
                \item \bjava{public int getLength()} --- Anzahl der Elemente in der Queue.
                \item \bjava{public String toString()} --- die Inhalte als String formatiert.
            \end{itemize}}\vspace*{-.33\baselineskip}\par
            \onslide<8->{\textit{Bonus:} Welchen Rückgabetyp würden Sie für Die Methode \bjava{public :lan:?:ran: head()} wählen, die den Wert des ersten Elements zurückgibt. Warum? \hfill\textbf{Hilfsmethoden sind erlaubt \Smiley.}}%
        }%
        \onslide<1->
    \end{aufgabe}
    \only<5|handout:0>{
        \begin{tikzpicture}[overlay, remember picture]
            \node[above left=.5cm,text width=6cm,font=\footnotesize] at(current page.south east) {\begin{enumerate}
                \item \bjava{public void enqueue(int value)} --- füge am Ende an.
                \item \bjava{public boolean dequeue()} --- entferne vorderstes Element.
                \item \bjava{public int getLength()} --- Anzahl eingereihter Elemente.
                \item \bjava{public String toString()} --- Formatiert als String.
            \end{enumerate}};
        \end{tikzpicture}
    }
\end{frame}

\begin{frame}{Präsenzaufgabe - Lösung\iffull\hfill\null\llap{\smash{\raisebox{-.3\baselineskip}{\scalebox{.7}{\itshape\footnotesize Or how to make \(\sim\)100 Lines Musterlösung verkraftbar}}}}\fi}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}


\section{Übungsblatt 10}
\subsection{Aufgabe 1}
\begin{frame}[c,fragile]{Übungsblatt 10 - Aufgabe 1}
    \pause Sortieren Sie die Zahlenfolge \(8, 6, 3, 5, 1, 2, 7, 4\) grafisch mit den folgenden Sortieralgorithmen:
    \begin{itemize}[<+(1)->]
        \item Mergesort
        \item Quicksort --- Nutzen Sie jeweils das erste Element als Pivotelement.
        \item Insertionsort
    \end{itemize}
    \bigskip\par\pause

    \resizebox{2cm}!{\tikz[align-half-base]\pingu[eyes wink,left wing wave, sign post left={Note!}];}\hfill\parbox{\linewidth-2cm}{%
    Ich nehmen für die Folien an, dass wir immer \textit{aufsteigend} sortieren. Alle andere Sortierweisen (wie \textit{absteigend}) geht analog.}
\end{frame}

\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Mergesort}
    \begin{center}
\resizebox{.975\linewidth}{!}{%
\begin{tikzpicture}[yscale=0.9]
    \onslide<1->{\node (a) at(0,0) {[\(8, 6, 3, 5, 1, 2, 7, 4\)]};}
    \foreach[count=\i] \l/\x in {{8,6,3,5}/-4,{1,2,7,4}/4}{
        \onslide<+(1)->{
            \node (b\i) at(\x,-1) {[\(\l\)]};
            \draw[-Kite] (a) -- (b\i);
        }
    }

    \foreach[count=\i] \l/\x/\p in {{8,6}/-6/1,{3,5}/-2/1,{1,2}/2/2,{7,4}/6/2}{
        \onslide<+(1)->{
            \node (c\i) at(\x,-2) {[\(\l\)]};
            \draw[-Kite] (b\p) -- (c\i);
        }
    }

    \foreach[count=\i] \l/\x/\p in {{8}/-7/1,{6}/-5/1,{3}/-3/2,{5}/-1/2,%
        {1}/1/3,{2}/3/3,{7}/5/4,{4}/7/4}{
        \onslide<+(1)->{
            \node (d\i) at(\x,-3) {[\(\l\)]};
            \draw[-Kite] (c\p) -- (d\i);
        }
    }

    \onslide<+(1)->{
    \foreach[count=\i] \l/\x/\p in {{8}/-7/1,{6}/-5/2,{3}/-3/3,{5}/-1/4,%
        {1}/1/5,{2}/3/6,{7}/5/7,{4}/7/8}{
            \node (e\i) at(\x,-4) {[\(\l\)]};
            \draw[densely dotted,-Kite,gray] (d\p) -- (e\i);
        }
    }

    \foreach[count=\i] \l/\x/\p/\pt in {{6,8}/-6/1/2,{3,5}/-2/3/4,{1,2}/2/5/6,{7,4}/6/7/8}{
        \onslide<+(1)->{
            \node (f\i) at(\x,-5) {[\(\l\)]};
            \ifnum\p=\pt\draw[densely dotted,gray,-Kite] (e\p) -- (f\i);\else \draw[-Kite] (e\p) -- (f\i);\draw[-Kite] (e\pt) -- (f\i); \fi
        }
    }

    \foreach[count=\i] \l/\x/\p/\pt in {{3,5,6,8}/-4/1/2,{1,2,4,7}/4/3/4}{
        \onslide<+(1)->{
            \node (g\i) at(\x,-6) {[\(\l\)]};
            \ifnum\p=\pt \draw[densely dotted,gray,-Kite] (f\p) -- (g\i);\else \draw[-Kite] (f\p) -- (g\i);\draw[-Kite] (f\pt) -- (g\i); \fi
        }
    }

    \foreach[count=\i] \l/\x/\p/\pt in {{1,2,3,4,5,6,7,8}/0/1/2}{
        \onslide<+(1)->{
            \node (h\i) at(\x,-7) {[\(\l\)]};
            \draw[-Kite] (g\p) -- (h\i); \draw[-Kite] (g\pt) -- (h\i);
        }
    }
    \onslide<+(1)->{\draw[densely dashed] (-8,-3.5) -- ++(17.25,0) node[above left] {\strut Divide} node[below left] {\strut Merge};}
\end{tikzpicture}
}
    \end{center}
\end{frame}

\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort}
    \begin{itemize}[<+(1)->]
        \itemsep12.5pt
        \item Quicksort kann unterschiedlich angewendet werden.
        \item Wir betrachten \iffull drei\else zwei\fi\ verschiedene Varianten: \begin{itemize}
            \iffull \item Eine einfache mit Listen (die direkte Umsetzung, genügt nicht).\fi
            \item Die Version der Vorlesung (Pivot ans Ende, Marker)
            \item Eine etwas schnellere Version (nur mit Markern).
        \end{itemize}
        \item \iffull Alle\else Beide\fi\ folgen dem dem bekannten Schema: \begin{itemize}
            \item Wenn Liste einelementig oder leer: fertig.
            \item Wähle Pivotelement und teile Liste in \say{kleiner} und \say{größergleich}.
            \item Wiederhole rekursiv für beide Teile.
        \end{itemize}
    \end{itemize}
\end{frame}


\iffull
\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Listenversion}
    \begin{center}
\resizebox{.65\linewidth}{!}{%
\begin{tikzpicture}[yscale=0.9]
    \onslide<1->{\node (a) at(0,0) {[\(\pivotelem{8}, 6, 3, 5, 1, 2, 7, 4\)]};}
    \foreach[count=\i] \l/\x in {{}/4,{\pivotelem{6}, 3, 5, 1, 2, 7, 4}/-4}{
        \onslide<+(1)->{
            \node (b\i) at(\x,-1) {[\(\l\)]};
            \draw[-Kite] (a) -- (b\i);
        }
    }

    \foreach[count=\i] \l/\x/\p in {{\pivotelem3,5,1,2,4}/-6/2,{\pivotelem7}/-2/2}{
        \onslide<+(1)->{
            \node (c\i) at(\x,-2) {[\(\l\)]};
            \draw[-Kite] (b\p) -- (c\i);
        }
    }

    \foreach[count=\i] \l/\x/\p in {{\pivotelem1,2}/-7/1,{\pivotelem5,4}/-5/1}{
        \onslide<+(1)->{
            \node (d\i) at(\x,-3) {[\(\l\)]};
            \draw[-Kite] (c\p) -- (d\i);
        }
    }

    \foreach[count=\i] \l/\x/\p/\c in {{\pivotelem2}/-6.5/d1/{},{\pivotelem4}/-5.5/d2/{}}{
        \onslide<+(1)->{
            \node (e\i) at(\x,-4) {[\(\l\)]};
            \expandafter\draw\expandafter[\c,-Kite] (\p) -- (e\i);
        }
    }

    \foreach[count=\i] \l/\x/\p/\px/\pt in {{\pivotelem1,2}/-7/1/d1/1,{4,\pivotelem5}/-5/2/d2/2}{
        \onslide<+(1)->{
            \node (f\i) at(\x,-5) {[\(\l\)]};
            \ifnum\p=\pt\draw[-Kite] (e\p) -- (f\i);\else \draw[-Kite] (e\p) -- (f\i);\draw[-Kite] (e\pt) -- (f\i); \fi
            \draw[densely dotted,gray,-Kite] (\px) -- (f\i);
        }
    }

    \foreach[count=\i] \l/\x/\p/\px/\pt in {{1,2,\pivotelem3,4,5}/-6/f1/c1/f2,{\pivotelem7}/-2/c2//c2}{
        \onslide<+(1)->{
            \node (g\i) at(\x,-6) {[\(\l\)]};
            \ifx\p\pt\draw[densely dotted,gray,-Kite] (\p) -- (g\i);\else \draw[-Kite] (\p) -- (g\i);\draw[-Kite] (\pt) -- (g\i); \fi
            \ifx\px\empty\else\draw[densely dotted,gray,-Kite] (\px) -- (g\i);\fi
        }
    }

    \foreach[count=\i] \l/\x/\p/\px/\pt in {{1,2,3,4,5,\pivotelem6,7}/-4/g1/b2/g2,{}/4/b1//b1}{
        \onslide<+(1)->{
            \node (h\i) at(\x,-7) {[\(\l\)]};
            \ifx\p\pt\draw[densely dotted,gray,-Kite] (\p) -- (h\i);\else \draw[-Kite] (\p) -- (h\i);\draw[-Kite] (\pt) -- (h\i); \fi
            \ifx\px\empty\else\draw[densely dotted,gray,-Kite] (\px) -- (h\i);\fi
        }
    }

    \foreach[count=\i] \l/\x/\p/\px/\pt in {{1,2,3,4,5,6,7,\pivotelem8}/0/h1/a/h2}{
        \onslide<+(1)->{
            \node (i\i) at(\x,-8) {[\(\l\)]};
            \ifx\p\pt\draw[densely dotted,gray,-Kite] (\p) -- (i\i);\else \draw[-Kite] (\p) -- (i\i);\draw[-Kite] (\pt) -- (i\i); \fi
            \ifx\px\empty\else\draw[densely dotted,gray,-Kite] (\px) -- (i\i);\fi
        }
    }

    % \onslide<+(1)->{\draw[densely dashed] (-8,-3.5) -- ++(17.25,0) node[above left] {\strut Divide} node[below left] {\strut Merge};}
\end{tikzpicture}
}
    \end{center}
\end{frame}
\fi

\newsavebox\pinguquicksortA \savebox\pinguquicksortA{\PinguBanner{1}{eyes shiny,santa hat}} \newsavebox\pinguquicksortAx \savebox\pinguquicksortAx{\PinguBanner{1}{eyes wink,santa hat}}
\newsavebox\pinguquicksortB \savebox\pinguquicksortB{\PinguBanner{2}{eyes shiny,construction helmet}} \newsavebox\pinguquicksortBx \savebox\pinguquicksortBx{\PinguBanner{2}{eyes wink,construction helmet}}
\newsavebox\pinguquicksortC \savebox\pinguquicksortC{\PinguBanner{3}{eyes shiny,glasses,halo}} \newsavebox\pinguquicksortCx \savebox\pinguquicksortCx{\PinguBanner{3}{eyes wink,glasses,halo}}
\newsavebox\pinguquicksortD \savebox\pinguquicksortD{\PinguBanner{4}{eyes shiny,headband}} \newsavebox\pinguquicksortDx \savebox\pinguquicksortDx{\PinguBanner{4}{eyes wink,headband}}
\newsavebox\pinguquicksortE \savebox\pinguquicksortE{\PinguBanner{5}{eyes shiny,headphones}} \newsavebox\pinguquicksortEx \savebox\pinguquicksortEx{\PinguBanner{5}{eyes wink,headphones}}
\newsavebox\pinguquicksortF \savebox\pinguquicksortF{\PinguBanner{6}{eyes shiny,crown}} \newsavebox\pinguquicksortFx \savebox\pinguquicksortFx{\PinguBanner{6}{eyes wink,crown}}
\newsavebox\pinguquicksortG \savebox\pinguquicksortG{\PinguBanner{7}{right eye shiny,eye patch left}} \newsavebox\pinguquicksortGx \savebox\pinguquicksortGx{\PinguBanner{7}{right eye wink,eye patch left}}
\newsavebox\pinguquicksortH \savebox\pinguquicksortH{\PinguBanner{8}{eyes shiny,hat}} \newsavebox\pinguquicksortHx \savebox\pinguquicksortHx{\PinguBanner{8}{eyes wink,hat}}

\def\pinguqsbx#1{\scalebox{.325}{\expandafter\usebox\csname pinguquicksort#1\endcsname}}
\makeatletter
\newcommand\pinguqsbb[3][]{\protected@edef\tmp{#3}\savebox0{\smash{\pinguqsbx{#2\ifx\tmp\empty\else x\fi}}}\usebox0\llap{\raisebox{-.285cm}{\parbox{\wd0}{#1\small\centering\strut\ifx\tmp\empty\else\faCaretUp\fi\\[-2mm]\T{\strut#3}}}}}
\def\pingubbfn#1{\hfill\parbox{4.5cm}{\footnotesize\color{gray}#1}\bigskip\par}
\def\pingubbtk#1#2{\begin{tikzpicture}[baseline={([yshift=.4cm]1.base)}]
    \def\l{{\color{gray}\scriptsize\faAngleLeft}}\foreach[count=\i] \col/\pin/\t/\m in {#1} {
        \node[inner ysep=0pt,outer ysep=-2pt] (\i) at(1.2*\i,0) {\pinguqsbb[\col]{\pin}{\t}};
        \ifx\m\empty\else
            \fill[white,opacity=.5]([xshift=1mm,yshift=3mm]\i.south west) rectangle ([xshift=-1mm,yshift=1.25cm]\i.north east);
        \fi
    }
    #2
\end{tikzpicture}}%
\makeatother
\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Vorlesungstreue}
\only<2|handout:0>{Ich köööönnte es wieder mit Klammern machen.}
\only<3->{\pingubbtk{\color{paletteA}/H/Pivot/,/F/{\l\,l}/,/C//,/E//,/A//,/B//,/G//,/D/{\l\,r}/}{\draw[Kite-Kite] (1.south) to[bend right=4] (8.south);}%\b Fl1\x C\x E\x A\x B \x F\b Dr2%
    \onslide<4->{\pingubbfn{Nach der Vorlesung muss das Pivotelement ans Ende!}}
    \onslide<5->{%
        \pingubbtk{/D/l/,/F//,/C//,/E//,/A//,/B//,/G/r/,\color{paletteA}/H/Pivot/}{\onslide<7->{
            \foreach[remember=\i as \li (initially 1)] \i in {2,...,8}{\draw[-Kite,gray] ([xshift=1pt]\li.south) to[bend right] ([xshift=-1pt]\i.south);}
        }}
    }\onslide<6->{\pingubbfn{\T{left} geht nach rechts, solange es auf ein Element zeigt, das kleiner als das Pivotelement ist.}}
    \onslide<8->{%
        \pingubbtk{/D/l/,/F//,/C//,/E//,/A//,/B//,/G/r/,\color{paletteA}/H/{{\color{black}l,}Pivot}/}{\draw[-Kite] (8) to[loop below] (8);}
    }\onslide<9->{\pingubbfn{Es ist \(l \geq r\). Tausche \T{left} mit dem Pivotelement (hier die selben).}}
}\vspace*{-1.33cm}
\end{frame}

\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Vorlesungstreue}
\onslide<2->{\onslide<3->{\pingubbtk{\color{paletteA}/F/Pivot/,/C/{\l\,l}/,/E//,/A//,/B//,/G//,/D/{\l\,r}/,/H//:ghost}{\draw[Kite-Kite] (1.south) to[bend right=4] (7.south);}}
    \onslide<2->{\pingubbfn{Wir wiederholen den Prozess für die linke und die rechte Hälfte. Hier gibt es nur eine linke\ldots}}
    \onslide<4->{\pingubbtk{/D/l/,/C//,/E//,/A//,/B//,/G/r/,\color{paletteA}/F/Pivot/,/H//:ghost}{\onslide<6->{
        \foreach[remember=\i as \li (initially 1)] \i in {2,...,6}{\draw[-Kite,gray] ([xshift=1pt]\li.south) to[bend right] ([xshift=-1pt]\i.south);}
    }}}
    \onslide<5->{\pingubbfn{Every body steps to the right\ldots}}
    \onslide<7->{\pingubbtk{/D//,/C//,/E//,/A//,/B//,/G/{l,r}/,\color{paletteA}/F/Pivot/,/H//:ghost}{\draw[Kite-Kite] (6.south) to[bend right] (7.south);}}
    \onslide<8->{\pingubbfn{Es ist \(l = r\). Tausche \T{left} mit dem Pivotelement.}}
}
\end{frame}

\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Vorlesungstreue}
\onslide<2->{\onslide<3->{\pingubbtk{\color{paletteA}/D/Pivot/,/C/{\l\,l}/,/E//,/A//,/B/{\l\,r}/,/F//:ghost,/G//,/H//:ghost}{\draw[Kite-Kite] (1.south) to[bend right=4] (5.south);}}
    \onslide<2->{\pingubbfn{Wir wiederholen den Prozess zuerst für die linke Hälfte.}}
    \onslide<4->{\pingubbtk{/B/l/,/C//,/E//,/A/r/,\color{paletteA}/D/Pivot/,/F//:ghost,/G//,/H//:ghost}{\onslide<6->{
        \foreach[remember=\i as \li (initially 1)] \i in {2,...,3}{\draw[-Kite,gray] ([xshift=1pt]\li.south) to[bend right] ([xshift=-1pt]\i.south);}
        \draw[Kite-Kite] (3.south) to[bend right] (4.south);
    }}}
    \onslide<5->{\pingubbfn{Es ist \(l < r\), wir vertauschen also zuerst die beiden.}}
    \onslide<6->{\pingubbtk{/B//,/C//,/A/l/,/E/r/,\color{paletteA}/D/Pivot/,/F//:ghost,/G//,/H//:ghost}{
        \draw[Kite-Kite] (4.south) to[bend right] (5.south);
        \foreach[remember=\i as \li (initially 3)] \i in {4}{\draw[-Kite,gray] ([xshift=1pt]\li.south) to[bend right] ([xshift=-1pt]\i.south);}}
    }
    \onslide<7->{\pingubbfn{Nun ist \(l = r\). Tausche \T{left} mit dem Pivotelement.}}
}
\end{frame}

\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Vorlesungstreue}
\onslide<2->{\onslide<3->{\pingubbtk{\color{paletteA}/B/Pivot/,/C/{\l\,l}/,/A/{\l\,r}/,/D//:ghost,/E//,/F//:ghost,/G//,/H//:ghost}{\draw[Kite-Kite] (1.south) to[bend right=4] (3.south);}}
    \onslide<2->{\pingubbfn{Wir wiederholen den Prozess wieder zuerst für die linke Hälfte.}}
    \onslide<4->{\pingubbtk{/A/l/,/C/r/,\color{paletteA}/B/Pivot/,/D//:ghost,/E//,/F//:ghost,/G//,/H//:ghost}{\foreach[remember=\i as \li (initially 1)] \i in {2}{\draw[-Kite,gray] ([xshift=1pt]\li.south) to[bend right] ([xshift=-1pt]\i.south);}\draw[Kite-Kite] (2.south) to[bend right] (3.south);}}
    \onslide<5->{\pingubbfn{Erenut haben wir \(l = r\). Tausche \T{left} mit dem Pivotelement.}}
    \onslide<6->{\pingubbtk{\color{paletteA}/A/{{\color{black}l,r,}Pivot}/,/B//:ghost,/C//,/D//:ghost,/E//,/F//:ghost,/G//,/H//:ghost}{}}
    \onslide<7->{\pingubbfn{Für alle weiteren Teillisten ist \(l = r = \text{Pivot}\). Wir verkürzen das in dieser Variante}}
}
\end{frame}

% list | left | right
\def\shortqspivot#1#2#3{\foreach[count=\i] \l in {#1} {\node (\i) at (.5*\i,0) {\strut\l};}
\ifnum#2>0 \ifnum#2=#3
\node[above=-2.75mm,align=center] (l) at (#2.north) {l,r\\[-2.33mm]\footnotesize\faCaretDown};
\else\node[above=-2.75mm,align=center] (l) at (#2.north) {l\\[-2.33mm]\footnotesize\faCaretDown}; \node[above=-2.75mm,align=center] (r) at (#3.north) {r\\[-2.33mm]\footnotesize\faCaretDown};\fi\fi}
{\def\leftc#1{\parbox{.45\linewidth}{\raggedleft\scriptsize\color{gray}#1}~~}
\def\rightc#1{~~\parbox{.45\linewidth}{\raggedright\scriptsize\color{gray}#1}}
\begin{frame}[c]{Übungsblatt 10 - Aufgabe 1\hfill Quicksort -- Nur mit Markern}
\begin{itemize}[<+(1)->]
    \item Von Hand, müssen wir aber das Pivotelement nirgends \say{hintauschen}.
    \item Im Folgenden eine Kompaktversion. Mit den Pivotelementen \pivotelem{P}:
\end{itemize}
\begin{columns}[c,onlytextwidth]
\column{.5\linewidth}
\centering\leftc{1) Solange \(a[l] < P\) und \(a[r] \geq P\)}\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{8},6,3,5,1,2,7,4}{2}{8}
    \foreach[remember=\i as \li (initially 2)] \i in {3,...,8}{\draw[-Kite,gray] ([xshift=3pt,yshift=7pt]\li.north) -- ([xshift=-3pt,yshift=7pt]\i.north);}
\end{tikzpicture}}\par
\leftc{2) Es ist: \(l \geq r\)}\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{8},6,3,5,1,2,7,4}{8}{8}
    \draw[Kite-Kite] ([yshift=5pt]1.south) to[bend right=10] ([yshift=5pt]8.south);
\end{tikzpicture}}\par
\leftc{3) Rekursion links. Solange \(a[l] < P\) und \(a[r] \geq P\)}\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{4},6,3,5,1,2,7,{\color{gray}8}}{2}{7}
    \foreach[remember=\i as \li (initially 7)] \i in {6}{\draw[-Kite,gray] ([xshift=-3pt,yshift=7pt]\li.north) -- ([xshift=3pt,yshift=7pt]\i.north);}
\end{tikzpicture}}\par
\leftc{4) \(a[l] \geq P\) und \(a[r] < P\)}\scalebox{.85}{\begin{tikzpicture}
    \shortqspivot{\pivotelem{4},6,3,5,1,2,7,{\color{gray}8}}{2}{6}
    \draw[Kite-Kite] ([yshift=5pt]2.south) to[bend right=10] ([yshift=5pt]6.south);
\end{tikzpicture}}
\column{.5\linewidth}
\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{4},2,3,5,1,6,7,{\color{gray}8}}{2}{6}
    \foreach[remember=\i as \li (initially 2)] \i in {3,...,4}{\draw[-Kite,gray] ([xshift=3pt,yshift=7pt]\li.north) -- ([xshift=-3pt,yshift=7pt]\i.north);}
    \foreach[remember=\i as \li (initially 6)] \i in {5}{\draw[-Kite,gray] ([xshift=-3pt,yshift=7pt]\li.north) -- ([xshift=3pt,yshift=7pt]\i.north);}
\end{tikzpicture}}\rightc{5) Solange \(a[l] < P\) und \(a[r] \geq P\)}\par\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{4},2,3,5,1,6,7,{\color{gray}8}}{4}{5}
    \draw[Kite-Kite] ([yshift=5pt]4.south) to[bend right=10] ([yshift=5pt]5.south);
    \draw[Kite-Kite,white] ([yshift=5pt]1.south) to[bend right=10] ([yshift=5pt]8.south);
\end{tikzpicture}}\rightc{6) \(a[l] \geq P\) und \(a[r] < P\)}\par\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{4},2,3,1,5,6,7,{\color{gray}8}}{4}{5}
    \foreach[remember=\i as \li (initially 5)] \i in {4}{\draw[-Kite,gray] ([xshift=-3pt,yshift=7pt]\li.north) -- ([xshift=3pt,yshift=7pt]\i.north);}
\end{tikzpicture}}\rightc{7) Solange \(a[l] < P\) und \(a[r] \geq P\)}\par\scalebox{.85}{\begin{tikzpicture}[align-base]
    \shortqspivot{\pivotelem{4},2,3,1,5,6,7,{\color{gray}8}}{4}{4}
    \draw[Kite-Kite,white] ([yshift=5pt]2.south) to[bend right=10] ([yshift=5pt]6.south);
    \draw[Kite-Kite] ([yshift=5pt]1.south) to[bend right=10] ([yshift=5pt]4.south);
\end{tikzpicture}}\rightc{8) Es ist \(l \geq r\).}
\end{columns}
\begin{center}
    \begin{tikzpicture}
        \shortqspivot{1,2,3,{\color{gray}4},5,6,7,{\color{gray}8}}{0}{0}
    \end{tikzpicture}\vspace*{-1\baselineskip}\par
    {\scriptsize\color{gray}Fertig sortiert, alle weiteren Anwendungen liefern nichts.}
\end{center}
% TODO: Begründungen TODO: deal with scale
\end{frame}}


\subsection{Zusatzaufgabe 4/6}

\begin{frame}[fragile]{Zusatzaufgabe 4/6}
\begin{itemize}[<+(1)->]
    \item
\end{itemize}
\end{frame}


\section{Die End-Pingu-Ente}
\begin{frame}
    \begin{center}
    \begin{tikzpicture}[scale=2.5]
    % \shuffleducks
         \duck[aodai=cprimary!50!black,tshirt=cprimary,conicalhat=brown,water=paletteA]
    \end{tikzpicture}\\\pause{}
    Wieder kein Pingu,\pause{} weil süß!
    \end{center}
\begin{tikzpicture}[overlay, remember picture]
    \fill[black] (current page.north east) -| ++(-2.5cm,-1.9cm) -- ++(0.25cm,-0.25cm) -| cycle;
    \node[below left=2pt,xshift=-1.55mm,scale=0.36] at(current page.north east) {};
\end{tikzpicture}
\end{frame}

\iffull\end{document}\fi